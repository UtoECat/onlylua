--------------------------------------------------------------------------------
Profile data file '../callgrind.out' (creator: callgrind-3.19.0)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 6281008
Trigger: Program termination
Profiled target:  ../luatest all.lua (PID 9403, part 1)
Events recorded:  Ir sysCount sysTime sysCpuTime
Events shown:     Ir sysCount sysTime sysCpuTime
Event sort order: Ir sysCount sysTime sysCpuTime
Thresholds:       99 0 0 0
Include dirs:     
User annotated:   ../lua.c
                  ../test.c
                  ../oldnewbaselib.c
                  ../lualib.c
                  ../lua.h
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                  sysCount     sysTime              sysCpuTime           
--------------------------------------------------------------------------------
21,673,257 (100.0%) 534 (100.0%) 527,350,662 (100.0%) 489,639,588 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                 sysCount     sysTime              sysCpuTime            file:function
--------------------------------------------------------------------------------
1,991,795 ( 9.19%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:llex [/home/buildcat/GitHub/onlylua/luatest]
1,312,808 ( 6.06%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:getlocalvardesc [/home/buildcat/GitHub/onlylua/luatest]
1,212,434 ( 5.59%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/dl-lookup.c:do_lookup_x [/usr/lib/ld-linux-x86-64.so.2]
  900,865 ( 4.16%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:save [/home/buildcat/GitHub/onlylua/luatest]
  887,813 ( 4.10%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_getshortstr [/home/buildcat/GitHub/onlylua/luatest]
  753,422 ( 3.48%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/../sysdeps/generic/dl-new-hash.h:_dl_lookup_symbol_x
  727,252 ( 3.36%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:findsetreg [/home/buildcat/GitHub/onlylua/luatest]
  500,170 ( 2.31%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:savelineinfo [/home/buildcat/GitHub/onlylua/luatest]
  471,698 ( 2.18%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:searchvar [/home/buildcat/GitHub/onlylua/luatest]
  427,857 ( 1.97%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:internshrstr [/home/buildcat/GitHub/onlylua/luatest]
  417,960 ( 1.93%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_code [/home/buildcat/GitHub/onlylua/luatest]
  409,575 ( 1.89%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_finish [/home/buildcat/GitHub/onlylua/luatest]
  397,214 ( 1.83%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_hash [/home/buildcat/GitHub/onlylua/luatest]
  375,230 ( 1.73%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaG_getfuncline [/home/buildcat/GitHub/onlylua/luatest]
  371,790 ( 1.72%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object
  282,825 ( 1.30%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:mainpositionTV [/home/buildcat/GitHub/onlylua/luatest]
  282,386 ( 1.30%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_growaux_ [/home/buildcat/GitHub/onlylua/luatest]
  273,185 ( 1.26%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/dl-lookup.c:_dl_lookup_symbol_x [/usr/lib/ld-linux-x86-64.so.2]
  271,890 ( 1.25%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/do-rel.h:_dl_relocate_object
  260,778 ( 1.20%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_newstring [/home/buildcat/GitHub/onlylua/luatest]
  247,701 ( 1.14%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next [/home/buildcat/GitHub/onlylua/luatest]
  236,223 ( 1.09%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:addk [/home/buildcat/GitHub/onlylua/luatest]
  223,564 ( 1.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_newkey'2 [/home/buildcat/GitHub/onlylua/luatest]
  204,769 ( 0.94%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:traverseproto [/home/buildcat/GitHub/onlylua/luatest]
  197,703 ( 0.91%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:read_string [/home/buildcat/GitHub/onlylua/luatest]
  184,015 ( 0.85%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/dl-reloc.c:_dl_relocate_object [/usr/lib/ld-linux-x86-64.so.2]
  183,592 ( 0.85%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_getlocalname [/home/buildcat/GitHub/onlylua/luatest]
  172,259 ( 0.79%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_newkey [/home/buildcat/GitHub/onlylua/luatest]
  159,645 ( 0.74%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/dl-lookup.c:check_match [/usr/lib/ld-linux-x86-64.so.2]
  155,840 ( 0.72%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk [/home/buildcat/GitHub/onlylua/luatest]
  153,851 ( 0.71%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:reglevel [/home/buildcat/GitHub/onlylua/luatest]
  129,985 ( 0.60%)   .                    .                    .           /usr/src/debug/glibc/glibc/stdio-common/Xprintf_buffer_write.c:__printf_buffer_write [/usr/lib/libc.so.6]
  128,655 ( 0.59%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_dischargevars [/home/buildcat/GitHub/onlylua/luatest]
  121,194 ( 0.56%)   .                    .                    .           /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S:strcmp [/usr/lib/ld-linux-x86-64.so.2]
  116,284 ( 0.54%)   .                    .                    .           /usr/src/debug/glibc/glibc/malloc/malloc.c:_int_malloc [/usr/lib/libc.so.6]
  116,207 ( 0.54%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:exp2reg [/home/buildcat/GitHub/onlylua/luatest]
  115,233 ( 0.53%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:discharge2reg [/home/buildcat/GitHub/onlylua/luatest]
  114,615 ( 0.53%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_get [/home/buildcat/GitHub/onlylua/luatest]
  109,560 ( 0.51%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:stringK [/home/buildcat/GitHub/onlylua/luatest]
  109,276 ( 0.50%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:inclinenumber [/home/buildcat/GitHub/onlylua/luatest]
  100,497 ( 0.46%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_equalobj [/home/buildcat/GitHub/onlylua/luatest]
   97,320 ( 0.45%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:init_exp [/home/buildcat/GitHub/onlylua/luatest]
   91,970 ( 0.42%)   .                    .                    .           /usr/src/debug/glibc/glibc/stdio-common/vfprintf-internal.c:__printf_buffer [/usr/lib/libc.so.6]
   90,526 ( 0.42%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:read_long_string [/home/buildcat/GitHub/onlylua/luatest]
   88,752 ( 0.41%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:traversestrongtable [/home/buildcat/GitHub/onlylua/luatest]
   86,029 ( 0.40%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_getstr [/home/buildcat/GitHub/onlylua/luatest]
   85,030 ( 0.39%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:searchupvalue [/home/buildcat/GitHub/onlylua/luatest]
   83,446 ( 0.39%)   .                    .                    .           /usr/src/debug/glibc/glibc/malloc/malloc.c:_int_free [/usr/lib/libc.so.6]
   82,336 ( 0.38%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_indexed [/home/buildcat/GitHub/onlylua/luatest]
   77,751 ( 0.36%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:registerlocalvar [/home/buildcat/GitHub/onlylua/luatest]
   75,887 ( 0.35%)   .                    .                    .           /usr/src/debug/glibc/glibc/stdio-common/vfprintf-process-arg.c:__printf_buffer
   75,411 ( 0.35%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:statement'2 [/home/buildcat/GitHub/onlylua/luatest]
   72,410 ( 0.33%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_hook [/home/buildcat/GitHub/onlylua/luatest]
   71,959 ( 0.33%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:reinsert [/home/buildcat/GitHub/onlylua/luatest]
   71,364 ( 0.33%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_realloc_ [/home/buildcat/GitHub/onlylua/luatest]
   69,593 ( 0.32%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_checkstack [/home/buildcat/GitHub/onlylua/luatest]
   67,457 ( 0.31%)   .                    .                    .           /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:memcpy@GLIBC_2.2.5 [/usr/lib/libc.so.6]
   65,624 ( 0.30%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_execute [/home/buildcat/GitHub/onlylua/luatest]
   64,532 ( 0.30%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:read_numeral [/home/buildcat/GitHub/onlylua/luatest]
   63,326 ( 0.29%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:removelastlineinfo [/home/buildcat/GitHub/onlylua/luatest]
   61,872 ( 0.29%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:singlevar [/home/buildcat/GitHub/onlylua/luatest]
   61,441 ( 0.28%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:subexpr [/home/buildcat/GitHub/onlylua/luatest]
   61,236 ( 0.28%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaE_incCstack [/home/buildcat/GitHub/onlylua/luatest]
   60,915 ( 0.28%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:new_localvar [/home/buildcat/GitHub/onlylua/luatest]
   60,914 ( 0.28%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:singlevaraux [/home/buildcat/GitHub/onlylua/luatest]
   59,271 ( 0.27%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:subexpr'2 [/home/buildcat/GitHub/onlylua/luatest]
   58,764 ( 0.27%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ [/home/buildcat/GitHub/onlylua/luatest]
   56,852 ( 0.26%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:isKstr [/home/buildcat/GitHub/onlylua/luatest]
   55,457 ( 0.26%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject [/home/buildcat/GitHub/onlylua/luatest]
   54,896 ( 0.25%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_newlstr [/home/buildcat/GitHub/onlylua/luatest]
   54,616 ( 0.25%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:setnodevector [/home/buildcat/GitHub/onlylua/luatest]
   54,490 ( 0.25%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaG_traceexec [/home/buildcat/GitHub/onlylua/luatest]
   54,487 ( 0.25%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:testnext [/home/buildcat/GitHub/onlylua/luatest]
   53,407 ( 0.25%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:getfreepos [/home/buildcat/GitHub/onlylua/luatest]
   49,662 ( 0.23%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2nextreg [/home/buildcat/GitHub/onlylua/luatest]
   48,456 ( 0.22%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:funcargs [/home/buildcat/GitHub/onlylua/luatest]
   47,007 ( 0.22%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:suffixedexp [/home/buildcat/GitHub/onlylua/luatest]
   46,863 ( 0.22%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:auxgetinfo [/home/buildcat/GitHub/onlylua/luatest]
   46,595 ( 0.21%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_remove [/home/buildcat/GitHub/onlylua/luatest]
   46,165 ( 0.21%)   .                    .                    .           /usr/src/debug/glibc/glibc/malloc/malloc.c:realloc [/usr/lib/libc.so.6]
   46,143 ( 0.21%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:sweeplist [/home/buildcat/GitHub/onlylua/luatest]
   45,986 ( 0.21%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:funcinfo [/home/buildcat/GitHub/onlylua/luatest]
   45,290 ( 0.21%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaY_nvarstack [/home/buildcat/GitHub/onlylua/luatest]
   44,252 ( 0.20%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_reserveregs [/home/buildcat/GitHub/onlylua/luatest]
   43,785 ( 0.20%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:l_str2int [/home/buildcat/GitHub/onlylua/luatest]
   43,662 ( 0.20%)   .                    .                    .           /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memcmp-sse2.S:__memcmp_sse2 [/usr/lib/libc.so.6]
   42,357 ( 0.20%)   .                    .                    .           /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strchr-sse2.S:__strchrnul_sse2 [/usr/lib/libc.so.6]
   41,562 ( 0.19%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:check [/home/buildcat/GitHub/onlylua/luatest]
   40,940 ( 0.19%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:currentpc [/home/buildcat/GitHub/onlylua/luatest]
   40,400 ( 0.19%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:lua_getinfo [/home/buildcat/GitHub/onlylua/luatest]
   39,493 ( 0.18%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_finishset [/home/buildcat/GitHub/onlylua/luatest]
   38,868 ( 0.18%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:tablerehash [/home/buildcat/GitHub/onlylua/luatest]
   38,844 ( 0.18%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:codestring [/home/buildcat/GitHub/onlylua/luatest]
   38,243 ( 0.18%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:enterblock [/home/buildcat/GitHub/onlylua/luatest]
   37,165 ( 0.17%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:simpleexp [/home/buildcat/GitHub/onlylua/luatest]
   36,143 ( 0.17%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:removevars [/home/buildcat/GitHub/onlylua/luatest]
   35,973 ( 0.17%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_malloc_ [/home/buildcat/GitHub/onlylua/luatest]
   35,769 ( 0.17%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:leaveblock [/home/buildcat/GitHub/onlylua/luatest]
   35,673 ( 0.16%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_newobj [/home/buildcat/GitHub/onlylua/luatest]
   34,833 ( 0.16%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:freeexp [/home/buildcat/GitHub/onlylua/luatest]
   34,596 ( 0.16%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:str2K [/home/buildcat/GitHub/onlylua/luatest]
   34,192 ( 0.16%)   .                    .                    .           /usr/src/debug/glibc/glibc/malloc/malloc.c:malloc [/usr/lib/libc.so.6]
   33,201 ( 0.15%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:str_checkname [/home/buildcat/GitHub/onlylua/luatest]
   33,098 ( 0.15%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:numusehash [/home/buildcat/GitHub/onlylua/luatest]
   32,662 ( 0.15%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_new [/home/buildcat/GitHub/onlylua/luatest]
   30,693 ( 0.14%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:adjustlocalvars [/home/buildcat/GitHub/onlylua/luatest]
   30,666 ( 0.14%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:init_var [/home/buildcat/GitHub/onlylua/luatest]
   29,708 ( 0.14%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:auxsetstr [/home/buildcat/GitHub/onlylua/luatest]
   29,109 ( 0.13%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:statement [/home/buildcat/GitHub/onlylua/luatest]
   28,621 ( 0.13%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:primaryexp [/home/buildcat/GitHub/onlylua/luatest]
   28,587 ( 0.13%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg [/home/buildcat/GitHub/onlylua/luatest]
   27,200 ( 0.13%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:rehash [/home/buildcat/GitHub/onlylua/luatest]
   27,190 ( 0.13%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:freeobj [/home/buildcat/GitHub/onlylua/luatest]
   26,613 ( 0.12%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:mainpositionfromnode [/home/buildcat/GitHub/onlylua/luatest]
   26,256 ( 0.12%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/dl-tunables.c:__GI___tunables_init [/usr/lib/ld-linux-x86-64.so.2]
   25,968 ( 0.12%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:suffixedexp'2 [/home/buildcat/GitHub/onlylua/luatest]
   24,867 ( 0.11%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:freereg [/home/buildcat/GitHub/onlylua/luatest]
   24,855 ( 0.11%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:exprstat [/home/buildcat/GitHub/onlylua/luatest]
   24,564 ( 0.11%)   .                    .                    .           /usr/src/debug/glibc/glibc/libio/fileops.c:_IO_file_xsputn@@GLIBC_2.2.5 [/usr/lib/libc.so.6]
   24,214 ( 0.11%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:funcnamefromcall [/home/buildcat/GitHub/onlylua/luatest]
   23,789 ( 0.11%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lualib.c:l_alloc [/home/buildcat/GitHub/onlylua/luatest]
   23,243 ( 0.11%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:simpleexp'2 [/home/buildcat/GitHub/onlylua/luatest]
   23,213 ( 0.11%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_finishset'2 [/home/buildcat/GitHub/onlylua/luatest]
   23,004 ( 0.11%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:fixjump [/home/buildcat/GitHub/onlylua/luatest]
   22,818 ( 0.11%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_setoneret [/home/buildcat/GitHub/onlylua/luatest]
   22,817 ( 0.11%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:traversethread [/home/buildcat/GitHub/onlylua/luatest]
   22,736 ( 0.10%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:localdebuginfo [/home/buildcat/GitHub/onlylua/luatest]
   22,661 ( 0.10%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:block_follow [/home/buildcat/GitHub/onlylua/luatest]
   22,421 ( 0.10%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_clearcache [/home/buildcat/GitHub/onlylua/luatest]
   22,060 ( 0.10%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:getbinopr [/home/buildcat/GitHub/onlylua/luatest]
   21,412 ( 0.10%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:createstrobj [/home/buildcat/GitHub/onlylua/luatest]
   21,293 ( 0.10%)   .                    .                    .           /usr/src/debug/glibc/glibc/stdio-common/_itoa.c:_itoa_word [/usr/lib/libc.so.6]
   21,027 ( 0.10%)   .                    .                    .           /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strlen-sse2.S:__strlen_sse2 [/usr/lib/libc.so.6]
   20,592 ( 0.10%)   .                    .                    .           /usr/src/debug/glibc/glibc/libio/fileops.c:new_do_write [/usr/lib/libc.so.6]
   20,383 ( 0.09%)   .                    .                    .           /usr/src/debug/glibc/glibc/stdio-common/vfprintf-internal.c:__vfprintf_internal [/usr/lib/libc.so.6]
   20,364 ( 0.09%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:check_next1 [/home/buildcat/GitHub/onlylua/luatest]
   19,725 ( 0.09%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:index2value [/home/buildcat/GitHub/onlylua/luatest]
   19,558 ( 0.09%)   .                    .                    .           /usr/src/debug/glibc/glibc/malloc/malloc.c:free [/usr/lib/libc.so.6]
   18,564 ( 0.09%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:getcurrentline [/home/buildcat/GitHub/onlylua/luatest]
   18,354 ( 0.08%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_shrinkvector_ [/home/buildcat/GitHub/onlylua/luatest]
   18,290 ( 0.08%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:getobjname [/home/buildcat/GitHub/onlylua/luatest]
   17,904 ( 0.08%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_set [/home/buildcat/GitHub/onlylua/luatest]
   17,871 ( 0.08%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:getbaseline [/home/buildcat/GitHub/onlylua/luatest]
   17,847 ( 0.08%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:singlevaraux'2 [/home/buildcat/GitHub/onlylua/luatest]
   17,338 ( 0.08%)   .                    .                    .           /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strchr-sse2.S:__strchr_sse2 [/usr/lib/libc.so.6]
   17,225 ( 0.08%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/test.c:myHook [/home/buildcat/GitHub/onlylua/luatest]
   17,184 ( 0.08%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABx [/home/buildcat/GitHub/onlylua/luatest]
   16,961 ( 0.08%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:getgclist [/home/buildcat/GitHub/onlylua/luatest]
   16,848 ( 0.08%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:singlestep [/home/buildcat/GitHub/onlylua/luatest]
   16,646 ( 0.08%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_getlabel [/home/buildcat/GitHub/onlylua/luatest]
   16,547 ( 0.08%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:check_next2 [/home/buildcat/GitHub/onlylua/luatest]
   16,473 ( 0.08%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:close_func [/home/buildcat/GitHub/onlylua/luatest]
   16,424 ( 0.08%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:getjumpcontrol [/home/buildcat/GitHub/onlylua/luatest]
   16,256 ( 0.08%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:allocupvalue [/home/buildcat/GitHub/onlylua/luatest]
   15,873 ( 0.07%)   .                    .                    .           /usr/src/debug/glibc/glibc/libio/fileops.c:_IO_file_write@@GLIBC_2.2.5 [/usr/lib/libc.so.6]
   15,824 ( 0.07%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/dl-version.c:_dl_check_map_versions [/usr/lib/ld-linux-x86-64.so.2]
   15,705 ( 0.07%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:getjump [/home/buildcat/GitHub/onlylua/luatest]
   15,367 ( 0.07%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:propagatemark [/home/buildcat/GitHub/onlylua/luatest]
   14,688 ( 0.07%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:funcargs'2 [/home/buildcat/GitHub/onlylua/luatest]
   14,530 ( 0.07%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/../sysdeps/generic/ldsodefs.h:do_lookup_x
   14,471 ( 0.07%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2K [/home/buildcat/GitHub/onlylua/luatest]
   14,394 ( 0.07%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_finishset [/home/buildcat/GitHub/onlylua/luatest]
   14,231 ( 0.07%)   .                    .                    .           /usr/src/debug/glibc/glibc/malloc/malloc.c:_int_realloc [/usr/lib/libc.so.6]
   14,224 ( 0.07%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_saferealloc_ [/home/buildcat/GitHub/onlylua/luatest]
   13,914 ( 0.06%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:check_match [/home/buildcat/GitHub/onlylua/luatest]
   13,899 ( 0.06%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/../sysdeps/generic/ldsodefs.h:_dl_relocate_object
   13,390 ( 0.06%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:localstat [/home/buildcat/GitHub/onlylua/luatest]
   13,373 ( 0.06%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:restassign [/home/buildcat/GitHub/onlylua/luatest]
   13,365 ( 0.06%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:constructor [/home/buildcat/GitHub/onlylua/luatest]
   13,038 ( 0.06%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:finaltarget [/home/buildcat/GitHub/onlylua/luatest]
   12,977 ( 0.06%)   .                    .                    .           /usr/src/debug/glibc/glibc/libio/fileops.c:_IO_file_overflow@@GLIBC_2.2.5 [/usr/lib/libc.so.6]
   12,932 ( 0.06%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:movegotosout [/home/buildcat/GitHub/onlylua/luatest]
   12,805 ( 0.06%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:newupvalue [/home/buildcat/GitHub/onlylua/luatest]
   12,276 ( 0.06%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:explist [/home/buildcat/GitHub/onlylua/luatest]
   12,222 ( 0.06%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_fixline [/home/buildcat/GitHub/onlylua/luatest]
   12,093 ( 0.06%)   .                    .                    .           /usr/src/debug/glibc/glibc/stdio-common/printf_buffer_to_file.c:__printf_buffer_flush_to_file [/usr/lib/libc.so.6]
   11,872 ( 0.05%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_storevar [/home/buildcat/GitHub/onlylua/luatest]
   11,792 ( 0.05%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:patchlistaux [/home/buildcat/GitHub/onlylua/luatest]
   11,766 ( 0.05%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaO_chunkid [/home/buildcat/GitHub/onlylua/luatest]
   11,624 ( 0.05%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/../sysdeps/generic/dl-protected.h:do_lookup_x
   11,571 ( 0.05%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:open_func [/home/buildcat/GitHub/onlylua/luatest]
   11,458 ( 0.05%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:tonumeral [/home/buildcat/GitHub/onlylua/luatest]
   10,829 ( 0.05%)   .                    .                    .           /usr/src/debug/glibc/glibc/stdio-common/printf_buffer_to_file.c:__printf_buffer_to_file_switch [/usr/lib/libc.so.6]
   10,620 ( 0.05%)   .                    .                    .           /usr/src/debug/glibc/glibc/malloc/malloc.c:malloc_consolidate [/usr/lib/libc.so.6]
   10,521 ( 0.05%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:skip_sep [/home/buildcat/GitHub/onlylua/luatest]
   10,502 ( 0.05%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:newlabelentry [/home/buildcat/GitHub/onlylua/luatest]
   10,502 ( 0.05%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:statlist'2 [/home/buildcat/GitHub/onlylua/luatest]
   10,485 ( 0.05%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_settablesize [/home/buildcat/GitHub/onlylua/luatest]
   10,375 ( 0.05%)   .                    .                    .           /usr/src/debug/glibc/glibc/stdio-common/fprintf.c:fprintf [/usr/lib/libc.so.6]
   10,100 ( 0.05%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:getunopr [/home/buildcat/GitHub/onlylua/luatest]
    9,939 ( 0.05%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaO_str2num [/home/buildcat/GitHub/onlylua/luatest]
    9,849 ( 0.05%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:linkgclist_ [/home/buildcat/GitHub/onlylua/luatest]
    9,804 ( 0.05%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:funcnamefromcode [/home/buildcat/GitHub/onlylua/luatest]
    9,492 ( 0.04%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:getfuncname [/home/buildcat/GitHub/onlylua/luatest]
    8,494 ( 0.04%)   .                    .                    .           /usr/src/debug/glibc/glibc/stdio-common/printf-parse.h:__printf_buffer
    8,317 ( 0.04%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:addprototype [/home/buildcat/GitHub/onlylua/luatest]
    8,309 ( 0.04%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:adjust_assign [/home/buildcat/GitHub/onlylua/luatest]
    8,245 ( 0.04%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_posfix [/home/buildcat/GitHub/onlylua/luatest]
    8,094 ( 0.04%)   .                    .                    .           /usr/src/debug/glibc/glibc/stdio-common/Xprintf_buffer_done.c:__printf_buffer_done [/usr/lib/libc.so.6]
    7,950 ( 0.04%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:codesJ [/home/buildcat/GitHub/onlylua/luatest]
    7,923 ( 0.04%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_newproto [/home/buildcat/GitHub/onlylua/luatest]
    7,821 ( 0.04%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:rethook [/home/buildcat/GitHub/onlylua/luatest]
    7,784 ( 0.04%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushcclosure [/home/buildcat/GitHub/onlylua/luatest]
    7,650 ( 0.04%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeAsBx [/home/buildcat/GitHub/onlylua/luatest]
    7,537 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:codeeq [/home/buildcat/GitHub/onlylua/luatest]
    7,304 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_infix [/home/buildcat/GitHub/onlylua/luatest]
    7,296 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_freeproto [/home/buildcat/GitHub/onlylua/luatest]
    7,272 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:filterpc [/home/buildcat/GitHub/onlylua/luatest]
    7,216 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:check_readonly [/home/buildcat/GitHub/onlylua/luatest]
    6,893 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:hashint [/home/buildcat/GitHub/onlylua/luatest]
    6,822 ( 0.03%)   .                    .                    .           /usr/src/debug/glibc/glibc/malloc/malloc.c:unlink_chunk.constprop.0 [/usr/lib/libc.so.6]
    6,798 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:explist'2 [/home/buildcat/GitHub/onlylua/luatest]
    6,459 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop [/home/buildcat/GitHub/onlylua/luatest]
    6,162 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:patchtestreg [/home/buildcat/GitHub/onlylua/luatest]
    6,082 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:deletelist [/home/buildcat/GitHub/onlylua/luatest]
    5,892 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:freeexps [/home/buildcat/GitHub/onlylua/luatest]
    5,888 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:fixforjump [/home/buildcat/GitHub/onlylua/luatest]
    5,879 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_setreturns [/home/buildcat/GitHub/onlylua/luatest]
    5,846 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:codeABRK [/home/buildcat/GitHub/onlylua/luatest]
    5,775 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:isneg [/home/buildcat/GitHub/onlylua/luatest]
    5,711 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:recfield [/home/buildcat/GitHub/onlylua/luatest]
    5,628 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:isSCnumber [/home/buildcat/GitHub/onlylua/luatest]
    5,500 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_patchlist [/home/buildcat/GitHub/onlylua/luatest]
    5,478 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:forbody [/home/buildcat/GitHub/onlylua/luatest]
    5,466 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:reverse [/home/buildcat/GitHub/onlylua/luatest]
    5,446 ( 0.03%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2RK [/home/buildcat/GitHub/onlylua/luatest]
    5,258 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:clearkey [/home/buildcat/GitHub/onlylua/luatest]
    5,244 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:upvalname [/home/buildcat/GitHub/onlylua/luatest]
    5,160 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:fieldsel [/home/buildcat/GitHub/onlylua/luatest]
    5,121 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_concat [/home/buildcat/GitHub/onlylua/luatest]
    5,082 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:checknext [/home/buildcat/GitHub/onlylua/luatest]
    4,921 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:moveresults [/home/buildcat/GitHub/onlylua/luatest]
    4,590 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_realasize [/home/buildcat/GitHub/onlylua/luatest]
    4,582 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:equalkey [/home/buildcat/GitHub/onlylua/luatest]
    4,564 ( 0.02%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/dl-load.c:_dl_map_object_from_fd [/usr/lib/ld-linux-x86-64.so.2]
    4,536 ( 0.02%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/../bits/stdlib-bsearch.h:intel_check_word.constprop.0
    4,502 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:lastlistfield [/home/buildcat/GitHub/onlylua/luatest]
    4,401 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushvalue [/home/buildcat/GitHub/onlylua/luatest]
    4,390 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_setfuncs [/home/buildcat/GitHub/onlylua/luatest]
    4,374 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:traverseLclosure [/home/buildcat/GitHub/onlylua/luatest]
    4,370 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:exchangehashpart [/home/buildcat/GitHub/onlylua/luatest]
    4,366 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:solvegotos [/home/buildcat/GitHub/onlylua/luatest]
    4,329 ( 0.02%)   .                    .                    .           /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strcmp-sse4_2.S:__strcmp_sse42 [/usr/lib/libc.so.6]
    4,280 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyregup [/home/buildcat/GitHub/onlylua/luatest]
    4,265 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:incstep [/home/buildcat/GitHub/onlylua/luatest]
    4,189 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:createlabel [/home/buildcat/GitHub/onlylua/luatest]
    4,189 ( 0.02%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/../sysdeps/x86/dl-cacheinfo.h:intel_check_word.constprop.0 [/usr/lib/ld-linux-x86-64.so.2]
    4,160 ( 0.02%)   .                    .                    .           /usr/src/debug/glibc/glibc/stdio-common/printf_buffer_to_file.c:__printf_buffer_to_file_done [/usr/lib/libc.so.6]
    4,127 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_init [/home/buildcat/GitHub/onlylua/luatest]
    4,116 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_fix [/home/buildcat/GitHub/onlylua/luatest]
    4,096 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:pushclosure [/home/buildcat/GitHub/onlylua/luatest]
    4,004 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:kname [/home/buildcat/GitHub/onlylua/luatest]
    3,996 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:lua_tolstring [/home/buildcat/GitHub/onlylua/luatest]
    3,944 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_resize [/home/buildcat/GitHub/onlylua/luatest]
    3,911 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:parlist [/home/buildcat/GitHub/onlylua/luatest]
    3,910 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:getobjname'2 [/home/buildcat/GitHub/onlylua/luatest]
    3,877 ( 0.02%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/dl-misc.c:_dl_name_match_p [/usr/lib/ld-linux-x86-64.so.2]
    3,800 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:prepCallInfo [/home/buildcat/GitHub/onlylua/luatest]
    3,788 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaO_ceillog2 [/home/buildcat/GitHub/onlylua/luatest]
    3,757 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_getint [/home/buildcat/GitHub/onlylua/luatest]
    3,722 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_concat [/home/buildcat/GitHub/onlylua/luatest]
    3,720 ( 0.02%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/dl-tunables.h:__GI___tunables_init
    3,587 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codek [/home/buildcat/GitHub/onlylua/luatest]
    3,505 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:expr [/home/buildcat/GitHub/onlylua/luatest]
    3,444 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:statlist [/home/buildcat/GitHub/onlylua/luatest]
    3,432 ( 0.02%) 429 (80.34%)   7,591,475 ( 1.44%)   7,236,698 ( 1.48%)  /usr/src/debug/glibc/glibc/io/../sysdeps/unix/sysv/linux/write.c:write [/usr/lib/libc.so.6]
    3,432 ( 0.02%)   .                    .                    .           /usr/src/debug/glibc/glibc/libio/libioP.h:new_do_write
    3,415 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:traversetable [/home/buildcat/GitHub/onlylua/luatest]
    3,348 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushstring [/home/buildcat/GitHub/onlylua/luatest]
    3,333 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_findupval [/home/buildcat/GitHub/onlylua/luatest]
    3,267 ( 0.02%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:markupval [/home/buildcat/GitHub/onlylua/luatest]
    3,245 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:body [/home/buildcat/GitHub/onlylua/luatest]
    3,210 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:fornum [/home/buildcat/GitHub/onlylua/luatest]
    3,191 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_precall [/home/buildcat/GitHub/onlylua/luatest]
    3,139 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:precallC [/home/buildcat/GitHub/onlylua/luatest]
    3,106 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:freeregs [/home/buildcat/GitHub/onlylua/luatest]
    3,035 ( 0.01%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/dl-load.c:_dl_map_object [/usr/lib/ld-linux-x86-64.so.2]
    3,003 ( 0.01%)   .                    .                    .           /usr/src/debug/glibc/glibc/libio/libioP.h:_IO_file_xsputn@@GLIBC_2.2.5
    2,984 ( 0.01%)   .                    .                    .           /usr/src/debug/glibc/glibc/malloc/malloc.c:alloc_perturb [/usr/lib/libc.so.6]
    2,978 ( 0.01%)   .                    .                    .           /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__mempcpy_sse2_unaligned [/usr/lib/libc.so.6]
    2,967 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:auxgetstr [/home/buildcat/GitHub/onlylua/luatest]
    2,951 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_int [/home/buildcat/GitHub/onlylua/luatest]
    2,928 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:finishbinexpval [/home/buildcat/GitHub/onlylua/luatest]
    2,919 ( 0.01%)   .                    .                    .           /usr/src/debug/glibc/glibc/stdio-common/../libio/libioP.h:__printf_buffer_flush_to_file
    2,916 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:code_loadbool [/home/buildcat/GitHub/onlylua/luatest]
    2,911 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_poscall [/home/buildcat/GitHub/onlylua/luatest]
    2,898 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_patchtohere [/home/buildcat/GitHub/onlylua/luatest]
    2,816 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lualib.c:nextrand [/home/buildcat/GitHub/onlylua/luatest]
    2,773 ( 0.01%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/dl-runtime.c:_dl_fixup [/usr/lib/ld-linux-x86-64.so.2]
    2,766 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:getgeneric [/home/buildcat/GitHub/onlylua/luatest]
    2,730 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2val [/home/buildcat/GitHub/onlylua/luatest]
    2,720 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:setlimittosize [/home/buildcat/GitHub/onlylua/luatest]
    2,714 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:copy2buff [/home/buildcat/GitHub/onlylua/luatest]
    2,682 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_goiftrue [/home/buildcat/GitHub/onlylua/luatest]
    2,680 ( 0.01%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/dl-deps.c:_dl_map_object_deps [/usr/lib/ld-linux-x86-64.so.2]
    2,666 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaT_init [/home/buildcat/GitHub/onlylua/luatest]
    2,659 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lualib.c:str_format [/home/buildcat/GitHub/onlylua/luatest]
    2,640 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:codeclosure [/home/buildcat/GitHub/onlylua/luatest]
    2,628 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:markmt [/home/buildcat/GitHub/onlylua/luatest]
    2,566 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:previousinstruction [/home/buildcat/GitHub/onlylua/luatest]
    2,504 ( 0.01%)   .                    .                    .           /usr/src/debug/glibc/glibc/stdio-common/printf_fp.c:__printf_fp_buffer_1.constprop.0.isra.0 [/usr/lib/libc.so.6]
    2,496 ( 0.01%)   .                    .                    .           /usr/src/debug/glibc/glibc/stdio-common/../include/printf_buffer.h:__printf_buffer_to_file_init
    2,484 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:getbuff [/home/buildcat/GitHub/onlylua/luatest]
    2,482 ( 0.01%)   .                    .                    .           /usr/src/debug/glibc/glibc/elf/dl-cache.c:_dl_cache_libcmp [/usr/lib/ld-linux-x86-64.so.2]
    2,473 ( 0.01%)   .                    .                    .           /usr/src/debug/glibc/glibc/stdio-common/../include/printf_buffer.h:__printf_buffer
    2,463 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_isKint [/home/buildcat/GitHub/onlylua/luatest]
    2,451 ( 0.01%)   .                    .                    .           /usr/src/debug/glibc/glibc/malloc/arena.c:free
    2,412 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:freehash [/home/buildcat/GitHub/onlylua/luatest]
    2,408 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:forstat [/home/buildcat/GitHub/onlylua/luatest]
    2,383 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:need_value [/home/buildcat/GitHub/onlylua/luatest]
    2,369 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:negatecondition [/home/buildcat/GitHub/onlylua/luatest]
    2,360 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:expr'2 [/home/buildcat/GitHub/onlylua/luatest]
    2,354 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:sweepstep [/home/buildcat/GitHub/onlylua/luatest]
    2,331 ( 0.01%)   .                    .                    .           /home/utoecat/Github/protected_github/onlylua/lua.c:nilK [/home/buildcat/GitHub/onlylua/luatest]

--------------------------------------------------------------------------------
-- User-annotated source: ../test.c
--------------------------------------------------------------------------------
  No information has been collected for ../test.c

--------------------------------------------------------------------------------
-- User-annotated source: ../oldnewbaselib.c
--------------------------------------------------------------------------------
  No information has been collected for ../oldnewbaselib.c

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/utoecat/Github/protected_github/onlylua/lua.c
--------------------------------------------------------------------------------
Ir                 sysCount sysTime sysCpuTime 

-- line 1470 ----------------------------------------
        .          .          .          .             "$LuaAuthors: " LUA_AUTHORS " $";
        .          .          .          .           
        .          .          .          .           #define isvalid(L, o)	(!ttisnil(o) || o != &G(L)->nilvalue)
        .          .          .          .           
        .          .          .          .           #define ispseudo(i)		((i) <= LUA_REGISTRYINDEX)
        .          .          .          .           
        .          .          .          .           #define isupvalue(i)		((i) < LUA_REGISTRYINDEX)
        .          .          .          .           
    2,475 ( 0.01%) .          .          .           static TValue *index2value (lua_State *L, int idx) {
    2,200 ( 0.01%) .          .          .             CallInfo *ci = L->ci;
      550 ( 0.00%) .          .          .             if (idx > 0) {
      816 ( 0.00%) .          .          .               StkId o = ci->func + idx;
    1,700 ( 0.01%) .          .          .               api_check(L, idx <= L->ci->top - (ci->func + 1), "unacceptable index");
      447 ( 0.00%) .          .          .               if (o >= L->top) return &G(L)->nilvalue;
      390 ( 0.00%) .          .          .               else return s2v(o);
        .          .          .          .             }
      414 ( 0.00%) .          .          .             else if (!ispseudo(idx)) {  
    5,148 ( 0.02%) .          .          .               api_check(L, idx != 0 && -idx <= L->top - (ci->func + 1), "invalid index");
    3,168 ( 0.01%) .          .          .               return s2v(L->top + idx);
        .          .          .          .             }
       18 ( 0.00%) .          .          .             else if (idx == LUA_REGISTRYINDEX)
      112 ( 0.00%) .          .          .               return &G(L)->l_registry;
        .          .          .          .             else {  
        4 ( 0.00%) .          .          .               idx = LUA_REGISTRYINDEX - idx;
        2 ( 0.00%) .          .          .               api_check(L, idx <= MAXUPVAL + 1, "upvalue index too large");
       15 ( 0.00%) .          .          .               if (ttisCclosure(s2v(ci->func))) {  
       38 ( 0.00%) .          .          .                 CClosure *func = clCvalue(s2v(ci->func));
       10 ( 0.00%) .          .          .                 return (idx <= func->nupvalues) ? &func->upvalue[idx-1]
       18 ( 0.00%) .          .          .                                                 : &G(L)->nilvalue;
        .          .          .          .               }
        .          .          .          .               else {  
        .          .          .          .                 api_check(L, ttislcf(s2v(ci->func)), "caller not a C function");
        .          .          .          .                 return &G(L)->nilvalue;  
        .          .          .          .               }
        .          .          .          .             }
    2,200 ( 0.01%) .          .          .           }
        .          .          .          .           
      133 ( 0.00%) .          .          .           l_sinline StkId index2stack (lua_State *L, int idx) {
      152 ( 0.00%) .          .          .             CallInfo *ci = L->ci;
       38 ( 0.00%) .          .          .             if (idx > 0) {
       24 ( 0.00%) .          .          .               StkId o = ci->func + idx;
       12 ( 0.00%) .          .          .               api_check(L, o < L->top, "invalid index");
        .          .          .          .               return o;
        .          .          .          .             }
        .          .          .          .             else {    
      408 ( 0.00%) .          .          .               api_check(L, idx != 0 && -idx <= L->top - (ci->func + 1), "invalid index");
       34 ( 0.00%) .          .          .               api_check(L, !ispseudo(idx), "invalid index");
      204 ( 0.00%) .          .          .               return L->top + idx;
        .          .          .          .             }
      133 ( 0.00%) .          .          .           }
        .          .          .          .           
       72 ( 0.00%) .          .          .           LUA_API int lua_checkstack (lua_State *L, int n) {
        .          .          .          .             int res;
        .          .          .          .             CallInfo *ci;
        .          .          .          .             lua_lock(L);
       64 ( 0.00%) .          .          .             ci = L->ci;
       16 ( 0.00%) .          .          .             api_check(L, n >= 0, "negative 'n'");
      144 ( 0.00%) .          .          .             if (L->stack_last - L->top > n)  
        8 ( 0.00%) .          .          .               res = 1;  
        .          .          .          .             else {  
        .          .          .          .               int inuse = cast_int(L->top - L->stack) + EXTRA_STACK;
        .          .          .          .               if (inuse > LUAI_MAXSTACK - n)  
        .          .          .          .                 res = 0;  
        .          .          .          .               else  
        .          .          .          .                 res = luaD_growstack(L, n, 0);
        .          .          .          .             }
      176 ( 0.00%) .          .          .             if (res && ci->top < L->top + n)
        .          .          .          .               ci->top = L->top + n;  
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return res;
       72 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
        .          .          .          .             int i;
        .          .          .          .             if (from == to) return;
        .          .          .          .             lua_lock(to);
        .          .          .          .             api_checknelems(from, n);
        .          .          .          .             api_check(from, G(from) == G(to), "moving among independent states");
        .          .          .          .             api_check(from, to->ci->top - to->top >= n, "stack overflow");
-- line 1548 ----------------------------------------
-- line 1549 ----------------------------------------
        .          .          .          .             from->top -= n;
        .          .          .          .             for (i = 0; i < n; i++) {
        .          .          .          .               setobjs2s(to, to->top, from->top + i);
        .          .          .          .               to->top++;  
        .          .          .          .             }
        .          .          .          .             lua_unlock(to);
        .          .          .          .           }
        .          .          .          .           
        7 ( 0.00%) .          .          .           LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
        .          .          .          .             lua_CFunction old;
        .          .          .          .             lua_lock(L);
       16 ( 0.00%) .          .          .             old = G(L)->panic;
        9 ( 0.00%) .          .          .             G(L)->panic = panicf;
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return old;
        7 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API lua_Number lua_version (lua_State* L) {
        .          .          .          .             UNUSED(L);
        .          .          .          .             return LUA_VERSION_NUM;
       10 ( 0.00%) .          .          .           }
        .          .          .          .           
       76 ( 0.00%) .          .          .           LUA_API int lua_absindex (lua_State *L, int idx) {
       19 ( 0.00%) .          .          .             return (idx > 0 || ispseudo(idx))
        .          .          .          .                    ? idx
       38 ( 0.00%) .          .          .                    : cast_int(L->top - L->ci->func) + idx;
       95 ( 0.00%) .          .          .           }
        .          .          .          .           
       64 ( 0.00%) .          .          .           LUA_API int lua_gettop (lua_State *L) {
      448 ( 0.00%) .          .          .             return cast_int(L->top - (L->ci->func + 1));
       64 ( 0.00%) .          .          .           }
        .          .          .          .           
      639 ( 0.00%) .          .          .           LUA_API void lua_settop (lua_State *L, int idx) {
        .          .          .          .             CallInfo *ci;
        .          .          .          .             StkId func, newtop;
        .          .          .          .             ptrdiff_t diff;  
        .          .          .          .             lua_lock(L);
      568 ( 0.00%) .          .          .             ci = L->ci;
      355 ( 0.00%) .          .          .             func = ci->func;
      142 ( 0.00%) .          .          .             if (idx >= 0) {
       85 ( 0.00%) .          .          .               api_check(L, idx <= ci->top - (func + 1), "new top too large");
       70 ( 0.00%) .          .          .               diff = ((func + 1) + idx) - L->top;
       15 ( 0.00%) .          .          .               for (; diff > 0; diff--)
        .          .          .          .                 setnilvalue(s2v(L->top++));  
        .          .          .          .             }
        .          .          .          .             else {
    1,056 ( 0.00%) .          .          .               api_check(L, -(idx+1) <= (L->top - (func + 1)), "invalid new top");
      264 ( 0.00%) .          .          .               diff = idx + 1;  
        .          .          .          .             }
    1,065 ( 0.00%) .          .          .             api_check(L, L->tbclist < L->top, "previous pop of an unclosed slot");
      781 ( 0.00%) .          .          .             newtop = L->top + diff;
      496 ( 0.00%) .          .          .             if (diff < 0 && L->tbclist >= newtop) {
        .          .          .          .               lua_assert(hastocloseCfunc(ci->nresults));
        .          .          .          .               luaF_close(L, newtop, CLOSEKTOP, 0);
        .          .          .          .             }
      355 ( 0.00%) .          .          .             L->top = newtop;  
        .          .          .          .             lua_unlock(L);
      568 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API void lua_closeslot (lua_State *L, int idx) {
        .          .          .          .             StkId level;
        .          .          .          .             lua_lock(L);
        .          .          .          .             level = index2stack(L, idx);
        .          .          .          .             api_check(L, hastocloseCfunc(L->ci->nresults) && L->tbclist == level,
        .          .          .          .                "no variable to close at given level");
        .          .          .          .             luaF_close(L, level, CLOSEKTOP, 0);
        .          .          .          .             level = index2stack(L, idx);  
        .          .          .          .             setnilvalue(s2v(level));
        .          .          .          .             lua_unlock(L);
        .          .          .          .           }
        .          .          .          .           
      663 ( 0.00%) .          .          .           l_sinline void reverse (lua_State *L, StkId from, StkId to) {
      323 ( 0.00%) .          .          .             for (; from < to; from++, to--) {
        .          .          .          .               TValue temp;
      882 ( 0.00%) .          .          .               setobj(L, &temp, s2v(from));
    1,904 ( 0.01%) .          .          .               setobjs2s(L, from, to);
    1,133 ( 0.01%) .          .          .               setobj2s(L, to, &temp);
        .          .          .          .             }
      561 ( 0.00%) .          .          .           }
        .          .          .          .           
      170 ( 0.00%) .          .          .           LUA_API void lua_rotate (lua_State *L, int idx, int n) {
        .          .          .          .             StkId p, t, m;
        .          .          .          .             lua_lock(L);
      204 ( 0.00%) .          .          .             t = L->top - 1;  
       68 ( 0.00%) .          .          .             p = index2stack(L, idx);  
    1,014 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:index2stack (17x)
      255 ( 0.00%) .          .          .             api_check(L, (n >= 0 ? n : -n) <= (t - p + 1), "invalid 'n'");
      204 ( 0.00%) .          .          .             m = (n >= 0 ? t - n : p - n - 1);  
       68 ( 0.00%) .          .          .             reverse(L, p, m);  
      459 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reverse (17x)
      119 ( 0.00%) .          .          .             reverse(L, m + 1, t);  
      459 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reverse (17x)
       68 ( 0.00%) .          .          .             reverse(L, p, t);  
    4,548 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reverse (17x)
        .          .          .          .             lua_unlock(L);
      136 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API void lua_copy (lua_State *L, int fromidx, int toidx) {
        .          .          .          .             TValue *fr, *to;
        .          .          .          .             lua_lock(L);
        .          .          .          .             fr = index2value(L, fromidx);
        .          .          .          .             to = index2value(L, toidx);
        .          .          .          .             api_check(L, isvalid(L, to), "invalid index");
        .          .          .          .             setobj(L, to, fr);
        .          .          .          .             if (isupvalue(toidx))  
        .          .          .          .               luaC_barrier(L, clCvalue(s2v(L->ci->func)), fr);
        .          .          .          .             
        .          .          .          .             lua_unlock(L);
        .          .          .          .           }
        .          .          .          .           
      189 ( 0.00%) .          .          .           LUA_API void lua_pushvalue (lua_State *L, int idx) {
        .          .          .          .             lua_lock(L);
    3,105 ( 0.01%) .          .          .             setobj2s(L, L->top, index2value(L, idx));
    1,962 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:index2value (27x)
      945 ( 0.00%) .          .          .             api_incr_top(L);
        .          .          .          .             lua_unlock(L);
      162 ( 0.00%) .          .          .           }
        .          .          .          .           
      148 ( 0.00%) .          .          .           LUA_API int lua_type (lua_State *L, int idx) {
       74 ( 0.00%) .          .          .             const TValue *o = index2value(L, idx);
    2,788 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:index2value (37x)
      694 ( 0.00%) .          .          .             return (isvalid(L, o) ? ttype(o) : LUA_TNONE);
      185 ( 0.00%) .          .          .           }
        .          .          .          .           
        2 ( 0.00%) .          .          .           LUA_API const char *lua_typename (lua_State *L, int t) {
        .          .          .          .             UNUSED(L);
        6 ( 0.00%) .          .          .             api_check(L, LUA_TNONE <= t && t < LUA_NUMTYPES, "invalid type");
       48 ( 0.00%) .          .          .             return ttypename(t);
        4 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API int lua_iscfunction (lua_State *L, int idx) {
        .          .          .          .             const TValue *o = index2value(L, idx);
        .          .          .          .             return (ttislcf(o) || (ttisCclosure(o)));
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API int lua_isinteger (lua_State *L, int idx) {
        .          .          .          .             const TValue *o = index2value(L, idx);
-- line 1679 ----------------------------------------
-- line 1738 ----------------------------------------
        .          .          .          .           
        .          .          .          .           LUA_API size_t lua_stringtonumber (lua_State *L, const char *s) {
        .          .          .          .             size_t sz = luaO_str2num(s, s2v(L->top));
        .          .          .          .             if (sz != 0)
        .          .          .          .               api_incr_top(L);
        .          .          .          .             return sz;
        .          .          .          .           }
        .          .          .          .           
       28 ( 0.00%) .          .          .           LUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *pisnum) {
        4 ( 0.00%) .          .          .             lua_Number n = 0;
        8 ( 0.00%) .          .          .             const TValue *o = index2value(L, idx);
      304 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:index2value (4x)
       80 ( 0.00%) .          .          .             int isnum = tonumber(o, &n);
        8 ( 0.00%) .          .          .             if (pisnum)
       16 ( 0.00%) .          .          .               *pisnum = isnum;
        4 ( 0.00%) .          .          .             return n;
       28 ( 0.00%) .          .          .           }
        .          .          .          .           
       16 ( 0.00%) .          .          .           LUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *pisnum) {
        2 ( 0.00%) .          .          .             lua_Integer res = 0;
        4 ( 0.00%) .          .          .             const TValue *o = index2value(L, idx);
      152 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:index2value (2x)
       46 ( 0.00%) .          .          .             int isnum = tointeger(o, &res);
        4 ( 0.00%) .          .          .             if (pisnum)
        8 ( 0.00%) .          .          .               *pisnum = isnum;
        2 ( 0.00%) .          .          .             return res;
       16 ( 0.00%) .          .          .           }
        .          .          .          .           
       27 ( 0.00%) .          .          .           LUA_API int lua_toboolean (lua_State *L, int idx) {
       18 ( 0.00%) .          .          .             const TValue *o = index2value(L, idx);
      654 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:index2value (9x)
      162 ( 0.00%) .          .          .             return !l_isfalse(o);
       36 ( 0.00%) .          .          .           }
        .          .          .          .           
      224 ( 0.00%) .          .          .           LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {
        .          .          .          .             TValue *o;
        .          .          .          .             lua_lock(L);
       56 ( 0.00%) .          .          .             o = index2value(L, idx);
    2,023 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:index2value (28x)
      336 ( 0.00%) .          .          .             if (!ttisstring(o)) {
        .          .          .          .               if (!cvt2str(o)) {  
        .          .          .          .                 if (len != NULL) *len = 0;
        .          .          .          .                 lua_unlock(L);
        .          .          .          .                 return NULL;
        .          .          .          .               }
        .          .          .          .               luaO_tostring(L, o);
        .          .          .          .               luaC_checkGC(L);
        .          .          .          .               o = index2value(L, idx);  
        .          .          .          .             }
       56 ( 0.00%) .          .          .             if (len != NULL)
    1,868 ( 0.01%) .          .          .               *len = vslen(o);
        .          .          .          .             lua_unlock(L);
    1,288 ( 0.01%) .          .          .             return svalue(o);
      168 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API lua_Unsigned lua_rawlen (lua_State *L, int idx) {
        .          .          .          .             const TValue *o = index2value(L, idx);
        .          .          .          .             switch (ttypetag(o)) {
        .          .          .          .               case LUA_VSHRSTR: return tsvalue(o)->shrlen;
        .          .          .          .               case LUA_VLNGSTR: return tsvalue(o)->u.lnglen;
        .          .          .          .               case LUA_VUSERDATA: return uvalue(o)->len;
        .          .          .          .               case LUA_VTABLE: return luaH_getn(hvalue(o));
-- line 1795 ----------------------------------------
-- line 1800 ----------------------------------------
        .          .          .          .           LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
        .          .          .          .             const TValue *o = index2value(L, idx);
        .          .          .          .             if (ttislcf(o)) return fvalue(o);
        .          .          .          .             else if (ttisCclosure(o))
        .          .          .          .               return clCvalue(o)->f;
        .          .          .          .             else return NULL;  
        .          .          .          .           }
        .          .          .          .           
      108 ( 0.00%) .          .          .           l_sinline void *touserdata (const TValue *o) {
      326 ( 0.00%) .          .          .             switch (ttype(o)) {
       64 ( 0.00%) .          .          .               case LUA_TUSERDATA: return getudatamem(uvalue(o));
      312 ( 0.00%) .          .          .               case LUA_TLIGHTUSERDATA: return pvalue(o);
        .          .          .          .               default: return NULL;
        .          .          .          .             }
      108 ( 0.00%) .          .          .           }
        .          .          .          .           
       27 ( 0.00%) .          .          .           LUA_API void *lua_touserdata (lua_State *L, int idx) {
       54 ( 0.00%) .          .          .             const TValue *o = index2value(L, idx);
    1,964 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:index2value (27x)
       27 ( 0.00%) .          .          .             return touserdata(o);
      918 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:touserdata (27x)
       54 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
        .          .          .          .             const TValue *o = index2value(L, idx);
        .          .          .          .             return (!ttisthread(o)) ? NULL : thvalue(o);
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API const void *lua_topointer (lua_State *L, int idx) {
        .          .          .          .             const TValue *o = index2value(L, idx);
-- line 1827 ----------------------------------------
-- line 1840 ----------------------------------------
        .          .          .          .           
        .          .          .          .           LUA_API void lua_pushnil (lua_State *L) {
        .          .          .          .             lua_lock(L);
        .          .          .          .             setnilvalue(s2v(L->top));
        .          .          .          .             api_incr_top(L);
        .          .          .          .             lua_unlock(L);
        .          .          .          .           }
        .          .          .          .           
       25 ( 0.00%) .          .          .           LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
        .          .          .          .             lua_lock(L);
      125 ( 0.00%) .          .          .             setfltvalue(s2v(L->top), n);
      175 ( 0.00%) .          .          .             api_incr_top(L);
        .          .          .          .             lua_unlock(L);
       20 ( 0.00%) .          .          .           }
        .          .          .          .           
       30 ( 0.00%) .          .          .           LUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {
        .          .          .          .             lua_lock(L);
      150 ( 0.00%) .          .          .             setivalue(s2v(L->top), n);
      210 ( 0.00%) .          .          .             api_incr_top(L);
        .          .          .          .             lua_unlock(L);
       24 ( 0.00%) .          .          .           }
        .          .          .          .           
       56 ( 0.00%) .          .          .           LUA_API const char *lua_pushlstring (lua_State *L, const char *s, size_t len) {
        .          .          .          .             TString *ts;
        .          .          .          .             lua_lock(L);
       35 ( 0.00%) .          .          .             ts = (len == 0) ? luaS_new(L, "") : luaS_newlstr(L, s, len);
    5,918 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_newlstr (7x)
      784 ( 0.00%) .          .          .             setsvalue2s(L, L->top, ts);
      245 ( 0.00%) .          .          .             api_incr_top(L);
       98 ( 0.00%) .          .          .             luaC_checkGC(L);
        .          .          .          .             lua_unlock(L);
       63 ( 0.00%) .          .          .             return getstr(ts);
       56 ( 0.00%) .          .          .           }
        .          .          .          .           
      126 ( 0.00%) .          .          .           LUA_API const char *lua_pushstring (lua_State *L, const char *s) {
        .          .          .          .             lua_lock(L);
       36 ( 0.00%) .          .          .             if (s == NULL)
        .          .          .          .               setnilvalue(s2v(L->top));
        .          .          .          .             else {
        .          .          .          .               TString *ts;
       36 ( 0.00%) .          .          .               ts = luaS_new(L, s);
    6,052 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_new (18x)
    1,944 ( 0.01%) .          .          .               setsvalue2s(L, L->top, ts);
      144 ( 0.00%) .          .          .               s = getstr(ts);  
        .          .          .          .             }
      684 ( 0.00%) .          .          .             api_incr_top(L);
      252 ( 0.00%) .          .          .             luaC_checkGC(L);
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return s;
      126 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
        4 ( 0.00%) .          .          .                                                 va_list argp) {
        .          .          .          .             const char *ret;
        .          .          .          .             lua_lock(L);
        2 ( 0.00%) .          .          .             ret = luaO_pushvfstring(L, fmt, argp);
    2,521 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaO_pushvfstring (1x)
       17 ( 0.00%) .          .          .             luaC_checkGC(L);
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return ret;
        5 ( 0.00%) .          .          .           }
        .          .          .          .           
      126 ( 0.00%) .          .          .           LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
        .          .          .          .             const char *ret;
        .          .          .          .             va_list argp;
        .          .          .          .             lua_lock(L);
       54 ( 0.00%) .          .          .             va_start(argp, fmt);
       36 ( 0.00%) .          .          .             ret = luaO_pushvfstring(L, fmt, argp);
   19,957 ( 0.09%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaO_pushvfstring (9x)
        .          .          .          .             va_end(argp);
      153 ( 0.00%) .          .          .             luaC_checkGC(L);
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return ret;
       81 ( 0.00%) .          .          .           }
        .          .          .          .           
      900 ( 0.00%) .          .          .           LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
        .          .          .          .             lua_lock(L);
      180 ( 0.00%) .          .          .             if (n == 0) {
    2,200 ( 0.01%) .          .          .               setfvalue(s2v(L->top), fn);
    3,080 ( 0.01%) .          .          .               api_incr_top(L);
        .          .          .          .             }
        .          .          .          .             else {
        .          .          .          .               CClosure *cl;
       52 ( 0.00%) .          .          .               api_checknelems(L, n);
        4 ( 0.00%) .          .          .               api_check(L, n <= MAXUPVAL, "upvalue index too large");
        8 ( 0.00%) .          .          .               cl = luaF_newCclosure(L, n);
      784 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_newCclosure (2x)
       16 ( 0.00%) .          .          .               cl->f = fn;
       40 ( 0.00%) .          .          .               L->top -= n;
       30 ( 0.00%) .          .          .               while (n--) {
      268 ( 0.00%) .          .          .                 setobj2n(L, &cl->upvalue[n], s2v(L->top + n));
        .          .          .          .                 
       12 ( 0.00%) .          .          .                 lua_assert(iswhite(cl));
        .          .          .          .               }
      182 ( 0.00%) .          .          .               setclCvalue(L, s2v(L->top), cl);
       64 ( 0.00%) .          .          .               api_incr_top(L);
       28 ( 0.00%) .          .          .               luaC_checkGC(L);
        .          .          .          .             }
        .          .          .          .             lua_unlock(L);
      720 ( 0.00%) .          .          .           }
        .          .          .          .           
       40 ( 0.00%) .          .          .           LUA_API void lua_pushboolean (lua_State *L, int b) {
        .          .          .          .             lua_lock(L);
       20 ( 0.00%) .          .          .             if (b)
        .          .          .          .               setbtvalue(s2v(L->top));
        .          .          .          .             else
      170 ( 0.00%) .          .          .               setbfvalue(s2v(L->top));
      380 ( 0.00%) .          .          .             api_incr_top(L);
        .          .          .          .             lua_unlock(L);
       40 ( 0.00%) .          .          .           }
        .          .          .          .           
       30 ( 0.00%) .          .          .           LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
        .          .          .          .             lua_lock(L);
      150 ( 0.00%) .          .          .             setpvalue(s2v(L->top), p);
      210 ( 0.00%) .          .          .             api_incr_top(L);
        .          .          .          .             lua_unlock(L);
       24 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API int lua_pushthread (lua_State *L) {
        .          .          .          .             lua_lock(L);
        .          .          .          .             setthvalue(L, s2v(L->top), L);
        .          .          .          .             api_incr_top(L);
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return (G(L)->mainthread == L);
        .          .          .          .           }
        .          .          .          .           
      120 ( 0.00%) .          .          .           l_sinline int auxgetstr (lua_State *L, const TValue *t, const char *k) {
        .          .          .          .             const TValue *slot;
       24 ( 0.00%) .          .          .             TString *str = luaS_new(L, k);
    7,939 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_new (12x)
      588 ( 0.00%) .          .          .             if (luaV_fastget(L, t, str, slot, luaH_getstr)) {
    2,461 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_getstr (12x)
      550 ( 0.00%) .          .          .               setobj2s(L, L->top, slot);
      175 ( 0.00%) .          .          .               api_incr_top(L);
        .          .          .          .             }
        .          .          .          .             else {
      770 ( 0.00%) .          .          .               setsvalue2s(L, L->top, str);
      245 ( 0.00%) .          .          .               api_incr_top(L);
      147 ( 0.00%) .          .          .               luaV_finishget(L, t, s2v(L->top - 1), L->top - 1, slot);
      630 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_finishget (7x)
        .          .          .          .             }
        .          .          .          .             lua_unlock(L);
      252 ( 0.00%) .          .          .             return ttype(s2v(L->top - 1));
       96 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #define getGtable(L)  	(&hvalue(&G(L)->l_registry)->array[LUA_RIDX_GLOBALS - 1])
        .          .          .          .           
        .          .          .          .           LUA_API int lua_getglobal (lua_State *L, const char *name) {
        .          .          .          .             const TValue *G;
        .          .          .          .             lua_lock(L);
        .          .          .          .             G = getGtable(L);
        .          .          .          .             return auxgetstr(L, G, name);
-- line 1983 ----------------------------------------
-- line 1992 ----------------------------------------
        .          .          .          .               setobj2s(L, L->top - 1, slot);
        .          .          .          .             }
        .          .          .          .             else
        .          .          .          .               luaV_finishget(L, t, s2v(L->top - 1), L->top - 1, slot);
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return ttype(s2v(L->top - 1));
        .          .          .          .           }
        .          .          .          .           
       60 ( 0.00%) .          .          .           LUA_API int lua_getfield (lua_State *L, int idx, const char *k) {
        .          .          .          .             lua_lock(L);
       60 ( 0.00%) .          .          .             return auxgetstr(L, index2value(L, idx), k);
   13,997 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:auxgetstr (12x)
      696 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:index2value (12x)
       48 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API int lua_geti (lua_State *L, int idx, lua_Integer n) {
        .          .          .          .             TValue *t;
        .          .          .          .             const TValue *slot;
        .          .          .          .             lua_lock(L);
        .          .          .          .             t = index2value(L, idx);
        .          .          .          .             if (luaV_fastgeti(L, t, n, slot)) {
        .          .          .          .               setobj2s(L, L->top, slot);
-- line 2011 ----------------------------------------
-- line 2015 ----------------------------------------
        .          .          .          .               setivalue(&aux, n);
        .          .          .          .               luaV_finishget(L, t, &aux, L->top, slot);
        .          .          .          .             }
        .          .          .          .             api_incr_top(L);
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return ttype(s2v(L->top - 1));
        .          .          .          .           }
        .          .          .          .           
      105 ( 0.00%) .          .          .           l_sinline int finishrawget (lua_State *L, const TValue *val) {
      135 ( 0.00%) .          .          .             if (isempty(val))  
      224 ( 0.00%) .          .          .               setnilvalue(s2v(L->top));
        .          .          .          .             else
      108 ( 0.00%) .          .          .               setobj2s(L, L->top, val);
      570 ( 0.00%) .          .          .             api_incr_top(L);
        .          .          .          .             lua_unlock(L);
      195 ( 0.00%) .          .          .             return ttype(s2v(L->top - 1));
       90 ( 0.00%) .          .          .           }
        .          .          .          .           
       45 ( 0.00%) .          .          .           static Table *gettable (lua_State *L, int idx) {
       30 ( 0.00%) .          .          .             TValue *t = index2value(L, idx);
    1,064 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:index2value (15x)
      135 ( 0.00%) .          .          .             api_check(L, ttistable(t), "table expected");
      390 ( 0.00%) .          .          .             return hvalue(t);
       75 ( 0.00%) .          .          .           }
        .          .          .          .           
       98 ( 0.00%) .          .          .           LUA_API int lua_rawget (lua_State *L, int idx) {
        .          .          .          .             Table *t;
        .          .          .          .             const TValue *val;
        .          .          .          .             lua_lock(L);
      322 ( 0.00%) .          .          .             api_checknelems(L, 1);
       56 ( 0.00%) .          .          .             t = gettable(L, idx);
    1,649 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:gettable (14x)
      238 ( 0.00%) .          .          .             val = luaH_get(t, s2v(L->top - 1));
    3,264 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_get (14x)
      196 ( 0.00%) .          .          .             L->top--;  
       42 ( 0.00%) .          .          .             return finishrawget(L, val);
    1,246 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:finishrawget (14x)
       84 ( 0.00%) .          .          .           }
        .          .          .          .           
        5 ( 0.00%) .          .          .           LUA_API int lua_rawgeti (lua_State *L, int idx, lua_Integer n) {
        .          .          .          .             Table *t;
        .          .          .          .             lua_lock(L);
        2 ( 0.00%) .          .          .             t = gettable(L, idx);
       90 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:gettable (1x)
        5 ( 0.00%) .          .          .             return finishrawget(L, luaH_getint(t, n));
      181 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:finishrawget (1x)
       41 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_getint (1x)
        4 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API int lua_rawgetp (lua_State *L, int idx, const void *p) {
        .          .          .          .             Table *t;
        .          .          .          .             TValue k;
        .          .          .          .             lua_lock(L);
        .          .          .          .             t = gettable(L, idx);
        .          .          .          .             setpvalue(&k, cast_voidp(p));
        .          .          .          .             return finishrawget(L, luaH_get(t, &k));
        .          .          .          .           }
        .          .          .          .           
       70 ( 0.00%) .          .          .           LUA_API void lua_createtable (lua_State *L, int narray, int nrec) {
        .          .          .          .             Table *t;
        .          .          .          .             lua_lock(L);
       14 ( 0.00%) .          .          .             t = luaH_new(L);
    2,802 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_new (7x)
      700 ( 0.00%) .          .          .             sethvalue2s(L, L->top, t);
      245 ( 0.00%) .          .          .             api_incr_top(L);
       42 ( 0.00%) .          .          .             if (narray > 0 || nrec > 0)
       36 ( 0.00%) .          .          .               luaH_resize(L, t, narray, nrec);
    7,148 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_resize (6x)
      100 ( 0.00%) .          .          .             luaC_checkGC(L);
   13,549 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_step (1x)
        .          .          .          .             lua_unlock(L);
       57 ( 0.00%) .          .          .           }
        .          .          .          .           
       60 ( 0.00%) .          .          .           LUA_API int lua_getmetatable (lua_State *L, int objindex) {
        .          .          .          .             const TValue *obj;
        .          .          .          .             Table *mt;
        2 ( 0.00%) .          .          .             int res = 0;
        .          .          .          .             lua_lock(L);
       20 ( 0.00%) .          .          .             obj = index2value(L, objindex);
      760 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:index2value (10x)
      160 ( 0.00%) .          .          .             switch (ttype(obj)) {
        .          .          .          .               case LUA_TTABLE:
        .          .          .          .                 mt = hvalue(obj)->metatable;
        .          .          .          .                 break;
        .          .          .          .               case LUA_TUSERDATA:
        .          .          .          .                 mt = uvalue(obj)->metatable;
        .          .          .          .                 break;
        .          .          .          .               default:
      250 ( 0.00%) .          .          .                 mt = G(L)->mt[ttype(obj)];
        .          .          .          .                 break;
        .          .          .          .             }
       20 ( 0.00%) .          .          .             if (mt != NULL) {
      918 ( 0.00%) .          .          .               sethvalue2s(L, L->top, mt);
      315 ( 0.00%) .          .          .               api_incr_top(L);
        9 ( 0.00%) .          .          .               res = 1;
        .          .          .          .             }
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return res;
       60 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API int lua_getiuservalue (lua_State *L, int idx, int n) {
        .          .          .          .             TValue *o;
        .          .          .          .             int t;
        .          .          .          .             lua_lock(L);
        .          .          .          .             o = index2value(L, idx);
        .          .          .          .             api_check(L, ttisfulluserdata(o), "full userdata expected");
        .          .          .          .             if (n <= 0 || n > uvalue(o)->nuvalue) {
-- line 2110 ----------------------------------------
-- line 2115 ----------------------------------------
        .          .          .          .               setobj2s(L, L->top, &uvalue(o)->uv[n - 1].uv);
        .          .          .          .               t = ttype(s2v(L->top));
        .          .          .          .             }
        .          .          .          .             api_incr_top(L);
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return t;
        .          .          .          .           }
        .          .          .          .           
    1,120 ( 0.01%) .          .          .           static void auxsetstr (lua_State *L, const TValue *t, const char *k) {
        .          .          .          .             const TValue *slot;
      224 ( 0.00%) .          .          .             TString *str = luaS_new(L, k);
  100,478 ( 0.46%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_new (112x)
    2,576 ( 0.01%) .          .          .             api_checknelems(L, 1);
    5,488 ( 0.03%) .          .          .             if (luaV_fastget(L, t, str, slot, luaH_getstr)) {
   23,647 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_getstr (112x)
    1,362 ( 0.01%) .          .          .               luaV_finishfastset(L, t, slot, s2v(L->top - 1));
      165 ( 0.00%) .          .          .               L->top--;  
        .          .          .          .             }
        .          .          .          .             else {
   10,504 ( 0.05%) .          .          .               setsvalue2s(L, L->top, str);  
    3,232 ( 0.01%) .          .          .               api_incr_top(L);
    2,727 ( 0.01%) .          .          .               luaV_finishset(L, t, s2v(L->top - 1), s2v(L->top - 2), slot);
  141,963 ( 0.66%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_finishset (101x)
    1,414 ( 0.01%) .          .          .               L->top -= 2;  
        .          .          .          .             }
        .          .          .          .             lua_unlock(L);  
      896 ( 0.00%) .          .          .           }
        .          .          .          .           
       63 ( 0.00%) .          .          .           LUA_API void lua_setglobal (lua_State *L, const char *name) {
        .          .          .          .             const TValue *G;
        .          .          .          .             lua_lock(L);  
      531 ( 0.00%) .          .          .             G = getGtable(L);
       27 ( 0.00%) .          .          .             auxsetstr(L, G, name);
   15,885 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:auxsetstr (9x)
       54 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API void lua_settable (lua_State *L, int idx) {
        .          .          .          .             TValue *t;
        .          .          .          .             const TValue *slot;
        .          .          .          .             lua_lock(L);
        .          .          .          .             api_checknelems(L, 2);
        .          .          .          .             t = index2value(L, idx);
        .          .          .          .             if (luaV_fastget(L, t, s2v(L->top - 2), slot, luaH_get)) {
-- line 2153 ----------------------------------------
-- line 2154 ----------------------------------------
        .          .          .          .               luaV_finishfastset(L, t, slot, s2v(L->top - 1));
        .          .          .          .             }
        .          .          .          .             else
        .          .          .          .               luaV_finishset(L, t, s2v(L->top - 2), s2v(L->top - 1), slot);
        .          .          .          .             L->top -= 2;  
        .          .          .          .             lua_unlock(L);
        .          .          .          .           }
        .          .          .          .           
      515 ( 0.00%) .          .          .           LUA_API void lua_setfield (lua_State *L, int idx, const char *k) {
        .          .          .          .             lua_lock(L);  
      515 ( 0.00%) .          .          .             auxsetstr(L, index2value(L, idx), k);
  279,911 ( 1.29%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:auxsetstr (103x)
    7,287 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:index2value (103x)
      412 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API void lua_seti (lua_State *L, int idx, lua_Integer n) {
        .          .          .          .             TValue *t;
        .          .          .          .             const TValue *slot;
        .          .          .          .             lua_lock(L);
        .          .          .          .             api_checknelems(L, 1);
        .          .          .          .             t = index2value(L, idx);
        .          .          .          .             if (luaV_fastgeti(L, t, n, slot)) {
-- line 2173 ----------------------------------------
-- line 2210 ----------------------------------------
        .          .          .          .             api_checknelems(L, 1);
        .          .          .          .             t = gettable(L, idx);
        .          .          .          .             luaH_setint(L, t, n, s2v(L->top - 1));
        .          .          .          .             luaC_barrierback(L, obj2gco(t), s2v(L->top - 1));
        .          .          .          .             L->top--;
        .          .          .          .             lua_unlock(L);
        .          .          .          .           }
        .          .          .          .           
        9 ( 0.00%) .          .          .           LUA_API int lua_setmetatable (lua_State *L, int objindex) {
        .          .          .          .             TValue *obj;
        .          .          .          .             Table *mt;
        .          .          .          .             lua_lock(L);
       23 ( 0.00%) .          .          .             api_checknelems(L, 1);
        4 ( 0.00%) .          .          .             obj = index2value(L, objindex);
       71 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:index2value (1x)
       19 ( 0.00%) .          .          .             if (ttisnil(s2v(L->top - 1)))
        .          .          .          .               mt = NULL;
        .          .          .          .             else {
       10 ( 0.00%) .          .          .               api_check(L, ttistable(s2v(L->top - 1)), "table expected");
       38 ( 0.00%) .          .          .               mt = hvalue(s2v(L->top - 1));
        .          .          .          .             }
       16 ( 0.00%) .          .          .             switch (ttype(obj)) {
        .          .          .          .               case LUA_TTABLE: {
        .          .          .          .                 hvalue(obj)->metatable = mt;
        .          .          .          .                 if (mt) {
        .          .          .          .                   luaC_objbarrier(L, gcvalue(obj), mt);
        .          .          .          .                   luaC_checkfinalizer(L, gcvalue(obj), mt);
        .          .          .          .                 }
        .          .          .          .                 break;
        .          .          .          .               }
-- line 2238 ----------------------------------------
-- line 2240 ----------------------------------------
        .          .          .          .                 uvalue(obj)->metatable = mt;
        .          .          .          .                 if (mt) {
        .          .          .          .                   luaC_objbarrier(L, uvalue(obj), mt);
        .          .          .          .                   luaC_checkfinalizer(L, gcvalue(obj), mt);
        .          .          .          .                 }
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: {
       22 ( 0.00%) .          .          .                 G(L)->mt[ttype(obj)] = mt;
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .             }
       14 ( 0.00%) .          .          .             L->top--;
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return 1;
        9 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API int lua_setiuservalue (lua_State *L, int idx, int n) {
        .          .          .          .             TValue *o;
        .          .          .          .             int res;
        .          .          .          .             lua_lock(L);
        .          .          .          .             api_checknelems(L, 1);
        .          .          .          .             o = index2value(L, idx);
        .          .          .          .             api_check(L, ttisfulluserdata(o), "full userdata expected");
-- line 2263 ----------------------------------------
-- line 2271 ----------------------------------------
        .          .          .          .             L->top--;
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return res;
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #define checkresults(L,na,nr)      api_check(L, (nr) == LUA_MULTRET || (L->ci->top - L->top >= (nr) - (na)), 	"results from function overflow current stack size")
        .          .          .          .           
        .          .          .          .           LUA_API void lua_callk (lua_State *L, int nargs, int nresults,
       72 ( 0.00%) .          .          .                                   lua_KContext ctx, lua_KFunction k) {
        .          .          .          .             StkId func;
        .          .          .          .             lua_lock(L);
       12 ( 0.00%) .          .          .             api_check(L, k == NULL || !isLua(L->ci),
        .          .          .          .               "cannot use continuations inside hooks");
      180 ( 0.00%) .          .          .             api_checknelems(L, nargs+1);
       36 ( 0.00%) .          .          .             api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
      180 ( 0.00%) .          .          .             checkresults(L, nargs, nresults);
       78 ( 0.00%) .          .          .             func = L->top - (nargs+1);
       12 ( 0.00%) .          .          .             if (k != NULL && yieldable(L)) {  
        .          .          .          .               L->ci->u.c.k = k;  
        .          .          .          .               L->ci->u.c.ctx = ctx;  
        .          .          .          .               luaD_call(L, func, nresults);  
        .          .          .          .             }
        .          .          .          .             else  
       24 ( 0.00%) .          .          .               luaD_callnoyield(L, func, nresults);  
  354,175 ( 1.63%) 13 ( 2.43%) 386,380 ( 0.07%) 363,695 ( 0.07%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_callnoyield'2 (6x)
       12 ( 0.00%) .          .          .             adjustresults(L, nresults);
        .          .          .          .             lua_unlock(L);
       48 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           struct CallS {  
        .          .          .          .             StkId func;
        .          .          .          .             int nresults;
        .          .          .          .           };
        .          .          .          .           
       10 ( 0.00%) .          .          .           static void f_call (lua_State *L, void *ud) {
        .          .          .          .             struct CallS *c = cast(struct CallS *, ud);
       22 ( 0.00%) .          .          .             luaD_callnoyield(L, c->func, c->nresults);
14,072,128 (64.93%) 441 (82.58%) 7,762,098 ( 1.47%) 7,394,886 ( 1.51%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_callnoyield (2x)
        4 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,
       32 ( 0.00%) .          .          .                                   lua_KContext ctx, lua_KFunction k) {
        .          .          .          .             struct CallS c;
        .          .          .          .             int status;
        .          .          .          .             ptrdiff_t func;
        .          .          .          .             lua_lock(L);
        4 ( 0.00%) .          .          .             api_check(L, k == NULL || !isLua(L->ci),
        .          .          .          .               "cannot use continuations inside hooks");
       60 ( 0.00%) .          .          .             api_checknelems(L, nargs+1);
       12 ( 0.00%) .          .          .             api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
       54 ( 0.00%) .          .          .             checkresults(L, nargs, nresults);
        4 ( 0.00%) .          .          .             if (errfunc == 0)
        .          .          .          .               func = 0;
        .          .          .          .             else {
        8 ( 0.00%) .          .          .               StkId o = index2stack(L, errfunc);
      124 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:index2stack (2x)
       22 ( 0.00%) .          .          .               api_check(L, ttisfunction(s2v(o)), "error handler must be a function");
       18 ( 0.00%) .          .          .               func = savestack(L, o);
        .          .          .          .             }
       30 ( 0.00%) .          .          .             c.func = L->top - (nargs+1);  
        4 ( 0.00%) .          .          .             if (k == NULL || !yieldable(L)) {  
        2 ( 0.00%) .          .          .               c.nresults = nresults;  
       30 ( 0.00%) .          .          .               status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);
14,076,933 (64.95%) 441 (82.58%) 7,762,098 ( 1.47%) 7,394,886 ( 1.51%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_pcall (2x)
        .          .          .          .             }
        .          .          .          .             else {  
        .          .          .          .               CallInfo *ci = L->ci;
        .          .          .          .               ci->u.c.k = k;  
        .          .          .          .               ci->u.c.ctx = ctx;  
        .          .          .          .               
        .          .          .          .               ci->u2.funcidx = cast_int(savestack(L, c.func));
        .          .          .          .               ci->u.c.old_errfunc = L->errfunc;
-- line 2338 ----------------------------------------
-- line 2339 ----------------------------------------
        .          .          .          .               L->errfunc = func;
        .          .          .          .               setoah(ci->callstatus, L->allowhook);  
        .          .          .          .               ci->callstatus |= CIST_YPCALL;  
        .          .          .          .               luaD_call(L, c.func, nresults);  
        .          .          .          .               ci->callstatus &= ~CIST_YPCALL;
        .          .          .          .               L->errfunc = ci->u.c.old_errfunc;
        .          .          .          .               status = LUA_OK;  
        .          .          .          .             }
        4 ( 0.00%) .          .          .             adjustresults(L, nresults);
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return status;
       24 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,
       26 ( 0.00%) .          .          .                                 const char *chunkname, const char *mode) {
        .          .          .          .             ZIO z;
        .          .          .          .             int status;
        .          .          .          .             lua_lock(L);
        4 ( 0.00%) .          .          .             if (!chunkname) chunkname = "?";
       12 ( 0.00%) .          .          .             luaZ_init(L, &z, reader, data);
       86 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaZ_init (2x)
       12 ( 0.00%) .          .          .             status = luaD_protectedparser(L, &z, chunkname, mode);
14,763,960 (68.12%) 8 ( 1.50%) 156,491 ( 0.03%) 146,870 ( 0.03%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_protectedparser (2x)
        4 ( 0.00%) .          .          .             if (status == LUA_OK) {  
      102 ( 0.00%) .          .          .               LClosure *f = clLvalue(s2v(L->top - 1));  
       18 ( 0.00%) .          .          .               if (f->nupvalues >= 1) {  
        .          .          .          .                 
      118 ( 0.00%) .          .          .                 const TValue *gt = getGtable(L);
        .          .          .          .                 
      252 ( 0.00%) .          .          .                 setobj(L, f->upvals[0]->v, gt);
       40 ( 0.00%) .          .          .                 luaC_barrier(L, f->upvals[0], gt);
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return status;
       24 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data, int strip) {
        .          .          .          .             int status;
        .          .          .          .             TValue *o;
        .          .          .          .             lua_lock(L);
        .          .          .          .             api_checknelems(L, 1);
        .          .          .          .             o = s2v(L->top - 1);
        .          .          .          .             if (isLfunction(o))
-- line 2380 ----------------------------------------
-- line 2384 ----------------------------------------
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return status;
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API int lua_status (lua_State *L) {
        .          .          .          .             return L->status;
        .          .          .          .           }
        .          .          .          .           
       36 ( 0.00%) .          .          .           LUA_API int lua_gc (lua_State *L, int what, ...) {
        .          .          .          .             va_list argp;
        .          .          .          .             int res = 0;
       16 ( 0.00%) .          .          .             global_State *g = G(L);
       18 ( 0.00%) .          .          .             if (g->gcstp & GCSTPGC)  
        .          .          .          .               return -1;  
        .          .          .          .             lua_lock(L);
       12 ( 0.00%) .          .          .             va_start(argp, what);
       14 ( 0.00%) .          .          .             switch (what) {
        .          .          .          .               case LUA_GCSTOP: {
        .          .          .          .                 g->gcstp = GCSTPUSR;  
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case LUA_GCRESTART: {
        .          .          .          .                 luaE_setdebt(g, 0);
        .          .          .          .                 g->gcstp = 0;  
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case LUA_GCCOLLECT: {
        .          .          .          .                 luaC_fullgc(L, 0);
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case LUA_GCCOUNT: {
        .          .          .          .                 
       14 ( 0.00%) .          .          .                 res = cast_int(gettotalbytes(g) >> 10);
        1 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case LUA_GCCOUNTB: {
       11 ( 0.00%) .          .          .                 res = cast_int(gettotalbytes(g) & 0x3ff);
        1 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case LUA_GCSTEP: {
        .          .          .          .                 int data = va_arg(argp, int);
        .          .          .          .                 l_mem debt = 1;  
        .          .          .          .                 lu_byte oldstp = g->gcstp;
        .          .          .          .                 g->gcstp = 0;  
        .          .          .          .                 if (data == 0) {
        .          .          .          .                   luaE_setdebt(g, 0);  
-- line 2429 ----------------------------------------
-- line 2480 ----------------------------------------
        .          .          .          .                 luaC_changemode(L, KGC_INC);
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: res = -1;  
        .          .          .          .             }
        .          .          .          .             va_end(argp);
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return res;
       24 ( 0.00%) .          .          .           }
        .          .          .          .           
        6 ( 0.00%) .          .          .           LUA_API int lua_error (lua_State *L) {
        .          .          .          .             TValue *errobj;
        .          .          .          .             lua_lock(L);
       17 ( 0.00%) .          .          .             errobj = s2v(L->top - 1);
       20 ( 0.00%) .          .          .             api_checknelems(L, 1);
        .          .          .          .             
       10 ( 0.00%) .          .          .             if (ttisshrstring(errobj) && eqshrstr(tsvalue(errobj), G(L)->memerrmsg))
        .          .          .          .               luaM_error(L);  
        .          .          .          .             else
        2 ( 0.00%) .          .          .               luaG_errormsg(L);  
   90,292 ( 0.42%) 31 ( 5.81%) 578,926 ( 0.11%) 556,494 ( 0.11%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaG_errormsg (1x)
        .          .          .          .             
        .          .          .          .             return 0;  
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API int lua_next (lua_State *L, int idx) {
        .          .          .          .             Table *t;
        .          .          .          .             int more;
        .          .          .          .             lua_lock(L);
-- line 2507 ----------------------------------------
-- line 2526 ----------------------------------------
        .          .          .          .             api_check(L, L->tbclist < o, "given index below or equal a marked one");
        .          .          .          .             luaF_newtbcupval(L, o);  
        .          .          .          .             if (!hastocloseCfunc(nresults))  
        .          .          .          .               L->ci->nresults = codeNresults(nresults);  
        .          .          .          .             lua_assert(hastocloseCfunc(L->ci->nresults));
        .          .          .          .             lua_unlock(L);
        .          .          .          .           }
        .          .          .          .           
        7 ( 0.00%) .          .          .           LUA_API void lua_concat (lua_State *L, int n) {
        .          .          .          .             lua_lock(L);
       26 ( 0.00%) .          .          .             api_checknelems(L, n);
        2 ( 0.00%) .          .          .             if (n > 0)
        3 ( 0.00%) .          .          .               luaV_concat(L, n);
    1,178 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_concat (1x)
        .          .          .          .             else {  
        .          .          .          .               setsvalue2s(L, L->top, luaS_newlstr(L, "", 0));  
        .          .          .          .               api_incr_top(L);
        .          .          .          .             }
       14 ( 0.00%) .          .          .             luaC_checkGC(L);
        .          .          .          .             lua_unlock(L);
        6 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API void lua_len (lua_State *L, int idx) {
        .          .          .          .             TValue *t;
        .          .          .          .             lua_lock(L);
        .          .          .          .             t = index2value(L, idx);
        .          .          .          .             luaV_objlen(L, L->top, t);
        .          .          .          .             api_incr_top(L);
        .          .          .          .             lua_unlock(L);
-- line 2553 ----------------------------------------
-- line 2577 ----------------------------------------
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           void lua_warning (lua_State *L, const char *msg, int tocont) {
        .          .          .          .             lua_lock(L);
        .          .          .          .             luaE_warning(L, msg, tocont);
        .          .          .          .             lua_unlock(L);
        .          .          .          .           }
        .          .          .          .           
        5 ( 0.00%) .          .          .           LUA_API void *lua_newuserdatauv (lua_State *L, size_t size, int nuvalue) {
        .          .          .          .             Udata *u;
        .          .          .          .             lua_lock(L);
        3 ( 0.00%) .          .          .             api_check(L, 0 <= nuvalue && nuvalue < USHRT_MAX, "invalid value");
        2 ( 0.00%) .          .          .             u = luaS_newudata(L, size, nuvalue);
      413 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_newudata (1x)
      100 ( 0.00%) .          .          .             setuvalue(L, s2v(L->top), u);
       35 ( 0.00%) .          .          .             api_incr_top(L);
       17 ( 0.00%) .          .          .             luaC_checkGC(L);
   32,964 ( 0.15%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_step (1x)
        .          .          .          .             lua_unlock(L);
       16 ( 0.00%) .          .          .             return getudatamem(u);
        6 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static const char *aux_upvalue (TValue *fi, int n, TValue **val,
        .          .          .          .                                           GCObject **owner) {
        .          .          .          .             switch (ttypetag(fi)) {
        .          .          .          .               case LUA_VCCL: {  
        .          .          .          .                 CClosure *f = clCvalue(fi);
        .          .          .          .                 if (!(cast_uint(n) - 1u < cast_uint(f->nupvalues)))
        .          .          .          .                   return NULL;  
-- line 2603 ----------------------------------------
-- line 3302 ----------------------------------------
        .          .          .          .           
        .          .          .          .           static int codesJ (FuncState *fs, OpCode o, int sj, int k);
        .          .          .          .           
        .          .          .          .           l_noret luaK_semerror (LexState *ls, const char *msg) {
        .          .          .          .             ls->t.token = 0;  
        .          .          .          .             luaX_syntaxerror(ls, msg);
        .          .          .          .           }
        .          .          .          .           
    1,460 ( 0.01%) .          .          .           static int tonumeral (const expdesc *e, TValue *v) {
    4,964 ( 0.02%) .          .          .             if (hasjumps(e))
        .          .          .          .               return 0;  
    3,064 ( 0.01%) .          .          .             switch (e->k) {
        .          .          .          .               case VKINT:
      654 ( 0.00%) .          .          .                 if (v) setivalue(v, e->u.ival);
      132 ( 0.00%) .          .          .                 return 1;
        .          .          .          .               case VKFLT:
        8 ( 0.00%) .          .          .                 if (v) setfltvalue(v, e->u.nval);
        8 ( 0.00%) .          .          .                 return 1;
        .          .          .          .               default: return 0;
        .          .          .          .             }
    1,168 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static TValue *const2val (FuncState *fs, const expdesc *e) {
        .          .          .          .             lua_assert(e->k == VCONST);
        .          .          .          .             return &fs->ls->dyd->actvar.arr[e->u.info].k;
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           int luaK_exp2const (FuncState *fs, const expdesc *e, TValue *v) {
        .          .          .          .             if (hasjumps(e))
-- line 3330 ----------------------------------------
-- line 3346 ----------------------------------------
        .          .          .          .               case VCONST: {
        .          .          .          .                 setobj(fs->ls->L, v, const2val(fs, e));
        .          .          .          .                 return 1;
        .          .          .          .               }
        .          .          .          .               default: return tonumeral(e, v);
        .          .          .          .             }
        .          .          .          .           }
        .          .          .          .           
      220 ( 0.00%) .          .          .           static Instruction *previousinstruction (FuncState *fs) {
        .          .          .          .             static const Instruction invalidinstruction = ~(Instruction)0;
      935 ( 0.00%) .          .          .             if (fs->pc > fs->lasttarget)
    1,175 ( 0.01%) .          .          .               return &fs->f->code[fs->pc - 1];  
        .          .          .          .             else
       16 ( 0.00%) .          .          .               return cast(Instruction*, &invalidinstruction);
      220 ( 0.00%) .          .          .           }
        .          .          .          .           
      320 ( 0.00%) .          .          .           void luaK_nil (FuncState *fs, int from, int n) {
      231 ( 0.00%) .          .          .             int l = from + n - 1;  
       96 ( 0.00%) .          .          .             Instruction *previous = previousinstruction(fs);
    1,416 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:previousinstruction (32x)
      288 ( 0.00%) .          .          .             if (GET_OPCODE(*previous) == OP_LOADNIL) {  
       49 ( 0.00%) .          .          .               int pfrom = GETARG_A(*previous);  
      238 ( 0.00%) .          .          .               int pl = pfrom + GETARG_B(*previous);
       49 ( 0.00%) .          .          .               if ((pfrom <= from && from <= pl + 1) ||
        .          .          .          .                   (from <= pfrom && pfrom <= l + 1)) {  
       14 ( 0.00%) .          .          .                 if (pfrom < from) from = pfrom;  
       14 ( 0.00%) .          .          .                 if (pl > l) l = pl;  
       98 ( 0.00%) .          .          .                 SETARG_A(*previous, from);
      112 ( 0.00%) .          .          .                 SETARG_B(*previous, l - from);
        7 ( 0.00%) .          .          .                 return;
        .          .          .          .               }  
        .          .          .          .             }
      250 ( 0.00%) .          .          .             luaK_codeABC(fs, OP_LOADNIL, from, n - 1, 0);  
   11,350 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (25x)
      256 ( 0.00%) .          .          .           }
        .          .          .          .           
    1,566 ( 0.01%) .          .          .           static int getjump (FuncState *fs, int pc) {
   12,180 ( 0.06%) .          .          .             int offset = GETARG_sJ(fs->f->code[pc]);
      348 ( 0.00%) .          .          .             if (offset == NO_JUMP)  
        .          .          .          .               return NO_JUMP;  
        .          .          .          .             else
       45 ( 0.00%) .          .          .               return (pc+1)+offset;  
    1,566 ( 0.01%) .          .          .           }
        .          .          .          .           
    3,240 ( 0.01%) .          .          .           static void fixjump (FuncState *fs, int pc, int dest) {
    6,480 ( 0.03%) .          .          .             Instruction *jmp = &fs->f->code[pc];
    2,268 ( 0.01%) .          .          .             int offset = dest - (pc + 1);
      648 ( 0.00%) .          .          .             lua_assert(dest != NO_JUMP);
      972 ( 0.00%) .          .          .             if (!(-OFFSET_sJ <= offset && offset <= MAXARG_sJ - OFFSET_sJ))
        .          .          .          .               luaX_syntaxerror(fs->ls, "control structure too long");
    2,592 ( 0.01%) .          .          .             lua_assert(GET_OPCODE(*jmp) == OP_JMP);
    4,212 ( 0.02%) .          .          .             SETARG_sJ(*jmp, offset);
    2,592 ( 0.01%) .          .          .           }
        .          .          .          .           
    1,392 ( 0.01%) .          .          .           void luaK_concat (FuncState *fs, int *l1, int l2) {
      348 ( 0.00%) .          .          .             if (l2 == NO_JUMP) return;  
    1,218 ( 0.01%) .          .          .             else if (*l1 == NO_JUMP)  
    1,008 ( 0.00%) .          .          .               *l1 = l2;  
        .          .          .          .             else {
       24 ( 0.00%) .          .          .               int list = *l1;
        .          .          .          .               int next;
       63 ( 0.00%) .          .          .               while ((next = getjump(fs, list)) != NO_JUMP)  
      825 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getjump (9x)
        .          .          .          .                 list = next;
       24 ( 0.00%) .          .          .               fixjump(fs, list, l2);  
      426 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:fixjump (6x)
        .          .          .          .             }
    1,044 ( 0.00%) .          .          .           }
        .          .          .          .           
      159 ( 0.00%) .          .          .           int luaK_jump (FuncState *fs) {
      636 ( 0.00%) .          .          .             return codesJ(fs, OP_JMP, NO_JUMP, 0);
   63,270 ( 0.29%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codesJ (159x)
      318 ( 0.00%) .          .          .           }
        .          .          .          .           
      553 ( 0.00%) .          .          .           void luaK_ret (FuncState *fs, int first, int nret) {
        .          .          .          .             OpCode op;
      316 ( 0.00%) .          .          .             switch (nret) {
        .          .          .          .               case 0: op = OP_RETURN0; break;
       18 ( 0.00%) .          .          .               case 1: op = OP_RETURN1; break;
        6 ( 0.00%) .          .          .               default: op = OP_RETURN; break;
        .          .          .          .             }
      790 ( 0.00%) .          .          .             luaK_codeABC(fs, op, first, nret + 1, 0);
   38,684 ( 0.18%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (79x)
      474 ( 0.00%) .          .          .           }
        .          .          .          .           
      288 ( 0.00%) .          .          .           static int condjump (FuncState *fs, OpCode op, int A, int B, int C, int k) {
      144 ( 0.00%) .          .          .             luaK_codeABCk(fs, op, A, B, C, k);
   62,803 ( 0.29%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (144x)
      288 ( 0.00%) .          .          .             return luaK_jump(fs);
   57,692 ( 0.27%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_jump (144x)
      288 ( 0.00%) .          .          .           }
        .          .          .          .           
    2,296 ( 0.01%) .          .          .           int luaK_getlabel (FuncState *fs) {
    9,184 ( 0.04%) .          .          .             fs->lasttarget = fs->pc;
    2,296 ( 0.01%) .          .          .             return fs->pc;
    2,870 ( 0.01%) .          .          .           }
        .          .          .          .           
    1,345 ( 0.01%) .          .          .           static Instruction *getjumpcontrol (FuncState *fs, int pc) {
    5,380 ( 0.02%) .          .          .             Instruction *pi = &fs->f->code[pc];
    8,339 ( 0.04%) .          .          .             if (pc >= 1 && testTMode(GET_OPCODE(*(pi-1))))
        .          .          .          .               return pi-1;
        .          .          .          .             else
       15 ( 0.00%) .          .          .               return pi;
    1,345 ( 0.01%) .          .          .           }
        .          .          .          .           
    1,272 ( 0.01%) .          .          .           static int patchtestreg (FuncState *fs, int node, int reg) {
      318 ( 0.00%) .          .          .             Instruction *i = getjumpcontrol(fs, node);
    9,714 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getjumpcontrol (159x)
    1,431 ( 0.01%) .          .          .             if (GET_OPCODE(*i) != OP_TESTSET)
      132 ( 0.00%) .          .          .               return 0;  
      240 ( 0.00%) .          .          .             if (reg != NO_REG && reg != GETARG_B(*i))
       14 ( 0.00%) .          .          .               SETARG_A(*i, reg);
        .          .          .          .             else {
        .          .          .          .                
    1,430 ( 0.01%) .          .          .               *i = CREATE_ABCk(OP_TEST, GETARG_B(*i), 0, 0, GETARG_k(*i));
        .          .          .          .             }
       53 ( 0.00%) .          .          .             return 1;
    1,272 ( 0.01%) .          .          .           }
        .          .          .          .           
      120 ( 0.00%) .          .          .           static void removevalues (FuncState *fs, int list) {
       72 ( 0.00%) .          .          .             for (; list != NO_JUMP; list = getjump(fs, list))
        .          .          .          .                 patchtestreg(fs, list, NO_REG);
       96 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
    4,887 ( 0.02%) .          .          .                                     int dtarget) {
    1,500 ( 0.01%) .          .          .             while (list != NO_JUMP) {
      636 ( 0.00%) .          .          .               int next = getjump(fs, list);
   14,340 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getjump (159x)
      954 ( 0.00%) .          .          .               if (patchtestreg(fs, list, reg))
   15,876 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:patchtestreg (159x)
      135 ( 0.00%) .          .          .                 fixjump(fs, list, vtarget);
    1,917 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:fixjump (27x)
        .          .          .          .               else
      528 ( 0.00%) .          .          .                 fixjump(fs, list, dtarget);  
    9,372 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:fixjump (132x)
        .          .          .          .               list = next;
        .          .          .          .             }
    3,152 ( 0.01%) .          .          .           }
        .          .          .          .           
    1,320 ( 0.01%) .          .          .           void luaK_patchlist (FuncState *fs, int list, int target) {
    1,980 ( 0.01%) .          .          .             lua_assert(target <= fs->pc);
    1,320 ( 0.01%) .          .          .             patchlistaux(fs, list, target, NO_REG, target);
   22,606 ( 0.10%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:patchlistaux (220x)
      880 ( 0.00%) .          .          .           }
        .          .          .          .           
    1,035 ( 0.00%) .          .          .           void luaK_patchtohere (FuncState *fs, int list) {
      414 ( 0.00%) .          .          .             int hr = luaK_getlabel(fs);  
    6,003 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_getlabel (207x)
      621 ( 0.00%) .          .          .             luaK_patchlist(fs, list, hr);
   23,711 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_patchlist (207x)
      828 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #define LIMLINEDIFF	0x80
        .          .          .          .           
   39,190 ( 0.18%) .          .          .           static void savelineinfo (FuncState *fs, Proto *f, int line) {
   47,028 ( 0.22%) .          .          .             int linedif = line - fs->previousline;
   31,352 ( 0.14%) .          .          .             int pc = fs->pc - 1;  
   94,056 ( 0.43%) .          .          .             if (abs(linedif) >= LIMLINEDIFF || fs->iwthabs++ >= MAXIWTHABS) {
    1,155 ( 0.01%) .          .          .               luaM_growvector(fs->ls->L, f->abslineinfo, fs->nabslineinfo,
    2,546 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_growaux_ (21x)
        .          .          .          .                               f->sizeabslineinfo, AbsLineInfo, MAX_INT, "lines");
      399 ( 0.00%) .          .          .               f->abslineinfo[fs->nabslineinfo].pc = pc;
      714 ( 0.00%) .          .          .               f->abslineinfo[fs->nabslineinfo++].line = line;
       21 ( 0.00%) .          .          .               linedif = ABSLINEINFO;  
      168 ( 0.00%) .          .          .               fs->iwthabs = 1;  
        .          .          .          .             }
  180,274 ( 0.83%) .          .          .             luaM_growvector(fs->ls->L, f->lineinfo, pc, f->sizelineinfo, ls_byte,
  170,166 ( 0.79%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_growaux_ (3,919x)
        .          .          .          .                             MAX_INT, "opcodes");
   54,866 ( 0.25%) .          .          .             f->lineinfo[pc] = linedif;
   19,595 ( 0.09%) .          .          .             fs->previousline = line;  
   31,352 ( 0.14%) .          .          .           }
        .          .          .          .           
    5,504 ( 0.03%) .          .          .           static void removelastlineinfo (FuncState *fs) {
    3,440 ( 0.02%) .          .          .             Proto *f = fs->f;
    7,568 ( 0.03%) .          .          .             int pc = fs->pc - 1;  
   13,760 ( 0.06%) .          .          .             if (f->lineinfo[pc] != ABSLINEINFO) {  
   17,810 ( 0.08%) .          .          .               fs->previousline -= f->lineinfo[pc];  
    9,590 ( 0.04%) .          .          .               fs->iwthabs--;  
        .          .          .          .             }
        .          .          .          .             else {  
       87 ( 0.00%) .          .          .               lua_assert(f->abslineinfo[fs->nabslineinfo - 1].pc == pc);
       36 ( 0.00%) .          .          .               fs->nabslineinfo--;  
       24 ( 0.00%) .          .          .               fs->iwthabs = MAXIWTHABS + 1;  
        .          .          .          .             }
    5,507 ( 0.03%) .          .          .           }
        .          .          .          .           
       36 ( 0.00%) .          .          .           static void removelastinstruction (FuncState *fs) {
        9 ( 0.00%) .          .          .             removelastlineinfo(fs);
      828 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:removelastlineinfo (9x)
      144 ( 0.00%) .          .          .             fs->pc--;
       36 ( 0.00%) .          .          .           }
        .          .          .          .           
   29,160 ( 0.13%) .          .          .           int luaK_code (FuncState *fs, Instruction i) {
   16,200 ( 0.07%) .          .          .             Proto *f = fs->f;
        .          .          .          .             
  171,720 ( 0.79%) .          .          .             luaM_growvector(fs->ls->L, f->code, fs->pc, f->sizecode, Instruction,
  162,094 ( 0.75%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_growaux_ (3,240x)
        .          .          .          .                             MAX_INT, "opcodes");
   93,960 ( 0.43%) .          .          .             f->code[fs->pc++] = i;
   51,840 ( 0.24%) .          .          .             savelineinfo(fs, f, fs->ls->lastline);
  565,156 ( 2.61%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:savelineinfo (3,240x)
   25,920 ( 0.12%) .          .          .             return fs->pc - 1;  
   29,160 ( 0.13%) .          .          .           }
        .          .          .          .           
   31,655 ( 0.15%) .          .          .           int luaK_codeABCk (FuncState *fs, OpCode o, int a, int b, int c, int k) {
   43,830 ( 0.20%) .          .          .             lua_assert(getOpMode(o) == iABC);
   34,090 ( 0.16%) .          .          .             lua_assert(a <= MAXARG_A && b <= MAXARG_B &&
        .          .          .          .                        c <= MAXARG_C && (k & ~1) == 0);
   26,785 ( 0.12%) .          .          .             return luaK_code(fs, CREATE_ABCk(o, a, b, c, k));
  863,172 ( 3.98%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_code (2,435x)
   19,480 ( 0.09%) .          .          .           }
        .          .          .          .           
    3,222 ( 0.01%) .          .          .           int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {
    7,160 ( 0.03%) .          .          .             lua_assert(getOpMode(o) == iABx);
    2,148 ( 0.01%) .          .          .             lua_assert(a <= MAXARG_A && bc <= MAXARG_Bx);
    2,506 ( 0.01%) .          .          .             return luaK_code(fs, CREATE_ABx(o, a, bc));
  124,786 ( 0.58%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_code (358x)
    2,148 ( 0.01%) .          .          .           }
        .          .          .          .           
    1,224 ( 0.01%) .          .          .           int luaK_codeAsBx (FuncState *fs, OpCode o, int a, int bc) {
      459 ( 0.00%) .          .          .             unsigned int b = bc + OFFSET_sBx;
    3,060 ( 0.01%) .          .          .             lua_assert(getOpMode(o) == iAsBx);
      918 ( 0.00%) .          .          .             lua_assert(a <= MAXARG_A && b <= MAXARG_Bx);
    1,071 ( 0.00%) .          .          .             return luaK_code(fs, CREATE_ABx(o, a, b));
   55,487 ( 0.26%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_code (153x)
      918 ( 0.00%) .          .          .           }
        .          .          .          .           
    1,272 ( 0.01%) .          .          .           static int codesJ (FuncState *fs, OpCode o, int sj, int k) {
      477 ( 0.00%) .          .          .             unsigned int j = sj + OFFSET_sJ;
    3,180 ( 0.01%) .          .          .             lua_assert(getOpMode(o) == isJ);
      954 ( 0.00%) .          .          .             lua_assert(j <= MAXARG_sJ && (k & ~1) == 0);
    1,113 ( 0.01%) .          .          .             return luaK_code(fs, CREATE_sJ(o, j, k));
   55,320 ( 0.26%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_code (159x)
      954 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static int codeextraarg (FuncState *fs, int a) {
        .          .          .          .             lua_assert(a <= MAXARG_Ax);
        .          .          .          .             return luaK_code(fs, CREATE_Ax(OP_EXTRAARG, a));
        .          .          .          .           }
        .          .          .          .           
    1,055 ( 0.00%) .          .          .           static int luaK_codek (FuncState *fs, int reg, int k) {
      422 ( 0.00%) .          .          .             if (k <= MAXARG_Bx)
    1,055 ( 0.00%) .          .          .               return luaK_codeABx(fs, OP_LOADK, reg, k);
   82,290 ( 0.38%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABx (211x)
        .          .          .          .             else {
        .          .          .          .               int p = luaK_codeABx(fs, OP_LOADKX, reg, 0);
        .          .          .          .               codeextraarg(fs, k);
        .          .          .          .               return p;
        .          .          .          .             }
    1,055 ( 0.00%) .          .          .           }
        .          .          .          .           
    9,670 ( 0.04%) .          .          .           void luaK_checkstack (FuncState *fs, int n) {
   21,274 ( 0.10%) .          .          .             int newstack = fs->freereg + n;
   29,010 ( 0.13%) .          .          .             if (newstack > fs->f->maxstacksize) {
      346 ( 0.00%) .          .          .               if (newstack >= MAXREGS)
        .          .          .          .                 luaX_syntaxerror(fs->ls,
        .          .          .          .                   "function or expression needs too many registers");
    1,557 ( 0.01%) .          .          .               fs->f->maxstacksize = cast_byte(newstack);
        .          .          .          .             }
    7,736 ( 0.04%) .          .          .           }
        .          .          .          .           
    9,620 ( 0.04%) .          .          .           void luaK_reserveregs (FuncState *fs, int n) {
    1,924 ( 0.01%) .          .          .             luaK_checkstack(fs, n);
   69,232 ( 0.32%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_checkstack (1,924x)
   25,012 ( 0.12%) .          .          .             fs->freereg += n;
    7,696 ( 0.04%) .          .          .           }
        .          .          .          .           
    5,225 ( 0.02%) .          .          .           static void freereg (FuncState *fs, int reg) {
    3,135 ( 0.01%) .          .          .             if (reg >= luaY_nvarstack(fs)) {
  112,129 ( 0.52%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaY_nvarstack (1,045x)
    8,218 ( 0.04%) .          .          .               fs->freereg--;
    4,109 ( 0.02%) .          .          .               lua_assert(reg == fs->freereg);
        .          .          .          .             }
    4,180 ( 0.02%) .          .          .           }
        .          .          .          .           
    1,128 ( 0.01%) .          .          .           static void freeregs (FuncState *fs, int r1, int r2) {
      376 ( 0.00%) .          .          .             if (r1 > r2) {
      139 ( 0.00%) .          .          .               freereg(fs, r1);
   18,644 ( 0.09%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freereg (139x)
      417 ( 0.00%) .          .          .               freereg(fs, r2);
   16,670 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freereg (139x)
        .          .          .          .             }
        .          .          .          .             else {
       98 ( 0.00%) .          .          .               freereg(fs, r2);
    6,769 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freereg (49x)
      147 ( 0.00%) .          .          .               freereg(fs, r1);
    6,475 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freereg (49x)
        .          .          .          .             }
      801 ( 0.00%) .          .          .           }
        .          .          .          .           
    9,565 ( 0.04%) .          .          .           static void freeexp (FuncState *fs, expdesc *e) {
   11,478 ( 0.05%) .          .          .             if (e->k == VNONRELOC)
    5,580 ( 0.03%) .          .          .               freereg(fs, e->u.info);
   73,223 ( 0.34%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freereg (558x)
    8,210 ( 0.04%) .          .          .           }
        .          .          .          .           
      936 ( 0.00%) .          .          .           static void freeexps (FuncState *fs, expdesc *e1, expdesc *e2) {
    2,332 ( 0.01%) .          .          .             int r1 = (e1->k == VNONRELOC) ? e1->u.info : -1;
    1,532 ( 0.01%) .          .          .             int r2 = (e2->k == VNONRELOC) ? e2->u.info : -1;
      468 ( 0.00%) .          .          .             freeregs(fs, r1, r2);
   42,735 ( 0.20%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeregs (156x)
      624 ( 0.00%) .          .          .           }
        .          .          .          .           
   13,923 ( 0.06%) .          .          .           static int addk (FuncState *fs, TValue *key, TValue *v) {
        .          .          .          .             TValue val;
   18,207 ( 0.08%) .          .          .             lua_State *L = fs->ls->L;
    5,355 ( 0.02%) .          .          .             Proto *f = fs->f;
   16,065 ( 0.07%) .          .          .             const TValue *idx = luaH_get(fs->ls->h, key);  
  288,463 ( 1.33%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_get (1,071x)
        .          .          .          .             int k, oldsize;
    9,639 ( 0.04%) .          .          .             if (ttisinteger(idx)) {  
    7,740 ( 0.04%) .          .          .               k = cast_int(ivalue(idx));
        .          .          .          .               
   34,783 ( 0.16%) .          .          .               if (k < fs->nk && ttypetag(&f->k[k]) == ttypetag(v) &&
    9,968 ( 0.05%) .          .          .                                 luaV_rawequalobj(&f->k[k], v))
  100,352 ( 0.46%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_equalobj (712x)
        .          .          .          .                 return k;  
        .          .          .          .             }
        .          .          .          .             
    3,762 ( 0.02%) .          .          .             oldsize = f->sizek;
    3,762 ( 0.02%) .          .          .             k = fs->nk;
        .          .          .          .             
    1,254 ( 0.01%) .          .          .             setivalue(&val, k);
    7,524 ( 0.03%) .          .          .             luaH_finishset(L, fs->ls->h, key, idx, &val);
   39,581 ( 0.18%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_finishset (418x)
   11,704 ( 0.05%) .          .          .             luaM_growvector(L, f->k, k, f->sizek, TValue, MAXARG_Ax, "constants");
   36,756 ( 0.17%) 1 ( 0.19%) 26,259 ( 0.00%) 24,752 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_growaux_ (418x)
   22,994 ( 0.11%) .          .          .             while (oldsize < f->sizek) setnilvalue(&f->k[oldsize++]);
   46,463 ( 0.21%) .          .          .             setobj(L, &f->k[k], v);
    5,434 ( 0.03%) .          .          .             fs->nk++;
    4,794 ( 0.02%) .          .          .             luaC_barrier(L, f, v);
        .          .          .          .             return k;
   12,852 ( 0.06%) .          .          .           }
        .          .          .          .           
   10,956 ( 0.05%) .          .          .           static int stringK (FuncState *fs, TString *s) {
        .          .          .          .             TValue o;
   84,660 ( 0.39%) .          .          .             setsvalue(fs->ls->L, &o, s);
    3,984 ( 0.02%) .          .          .             return addk(fs, &o, &o);  
  641,974 ( 2.96%) 1 ( 0.19%) 26,259 ( 0.00%) 24,752 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:addk (996x)
    9,960 ( 0.05%) .          .          .           }
        .          .          .          .           
      132 ( 0.00%) .          .          .           static int luaK_intK (FuncState *fs, lua_Integer n) {
        .          .          .          .             TValue o;
       66 ( 0.00%) .          .          .             setivalue(&o, n);
       99 ( 0.00%) .          .          .             return addk(fs, &o, &o);  
   31,640 ( 0.15%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:addk (33x)
      165 ( 0.00%) .          .          .           }
        .          .          .          .           
       64 ( 0.00%) .          .          .           static int luaK_numberK (FuncState *fs, lua_Number r) {
        .          .          .          .             TValue o;
        .          .          .          .             lua_Integer ik;
       16 ( 0.00%) .          .          .             setfltvalue(&o, r);
       40 ( 0.00%) .          .          .             if (!luaV_flttointeger(r, &ik, F2Ieq))  
      335 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_flttointeger (8x)
        5 ( 0.00%) .          .          .               return addk(fs, &o, &o);  
    2,104 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:addk (1x)
        .          .          .          .             else {  
        .          .          .          .               const int nbm = l_floatatt(MANT_DIG);
        .          .          .          .               const lua_Number q = l_mathop(ldexp)(l_mathop(1.0), -nbm + 1);
       49 ( 0.00%) .          .          .               const lua_Number k = (ik == 0) ? q : r + r*q;  
        .          .          .          .               TValue kv;
       14 ( 0.00%) .          .          .               setfltvalue(&kv, k);
        .          .          .          .               
       35 ( 0.00%) .          .          .               lua_assert(!luaV_flttointeger(k, &ik, F2Ieq) ||
      238 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_flttointeger (7x)
        .          .          .          .                           l_mathop(fabs)(r) >= l_mathop(1e6));
       28 ( 0.00%) .          .          .               return addk(fs, &kv, &o);
    4,991 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:addk (7x)
        .          .          .          .             }
       56 ( 0.00%) .          .          .           }
        .          .          .          .           
       16 ( 0.00%) .          .          .           static int boolF (FuncState *fs) {
        .          .          .          .             TValue o;
        4 ( 0.00%) .          .          .             setbfvalue(&o);
       12 ( 0.00%) .          .          .             return addk(fs, &o, &o);  
    2,787 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:addk (4x)
       20 ( 0.00%) .          .          .           }
        .          .          .          .           
       36 ( 0.00%) .          .          .           static int boolT (FuncState *fs) {
        .          .          .          .             TValue o;
        9 ( 0.00%) .          .          .             setbtvalue(&o);
       27 ( 0.00%) .          .          .             return addk(fs, &o, &o);  
    5,813 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:addk (9x)
       45 ( 0.00%) .          .          .           }
        .          .          .          .           
      210 ( 0.00%) .          .          .           static int nilK (FuncState *fs) {
        .          .          .          .             TValue k, v;
       21 ( 0.00%) .          .          .             setnilvalue(&v);
        .          .          .          .             
    1,806 ( 0.01%) .          .          .             sethvalue(fs->ls->L, &k, fs->ls->h);
       84 ( 0.00%) .          .          .             return addk(fs, &k, &v);
   12,066 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:addk (21x)
      210 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static int fitsC (lua_Integer i) {
      204 ( 0.00%) .          .          .             return (l_castS2U(i) + OFFSET_sC <= cast_uint(MAXARG_C));
       51 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static int fitsBx (lua_Integer i) {
      636 ( 0.00%) .          .          .             return (-OFFSET_sBx <= i && i <= MAXARG_Bx - OFFSET_sBx);
      159 ( 0.00%) .          .          .           }
        .          .          .          .           
      930 ( 0.00%) .          .          .           void luaK_int (FuncState *fs, int reg, lua_Integer i) {
      620 ( 0.00%) .          .          .             if (fitsBx(i))
      775 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:fitsBx (155x)
      765 ( 0.00%) .          .          .               luaK_codeAsBx(fs, OP_LOADI, reg, cast_int(i));
   63,137 ( 0.29%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeAsBx (153x)
        .          .          .          .             else
       14 ( 0.00%) .          .          .               luaK_codek(fs, reg, luaK_intK(fs, i));
    6,836 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_intK (2x)
      766 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codek (2x)
      622 ( 0.00%) .          .          .           }
        .          .          .          .           
       44 ( 0.00%) .          .          .           static void luaK_float (FuncState *fs, int reg, lua_Number f) {
        .          .          .          .             lua_Integer fi;
       40 ( 0.00%) .          .          .             if (luaV_flttointeger(f, &fi, F2Ieq) && fitsBx(fi))
      172 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_flttointeger (4x)
       20 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:fitsBx (4x)
        .          .          .          .               luaK_codeAsBx(fs, OP_LOADF, reg, cast_int(fi));
        .          .          .          .             else
       28 ( 0.00%) .          .          .               luaK_codek(fs, reg, luaK_numberK(fs, f));
    3,045 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_numberK (4x)
    1,532 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codek (4x)
       36 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void const2exp (TValue *v, expdesc *e) {
        .          .          .          .             switch (ttypetag(v)) {
        .          .          .          .               case LUA_VNUMINT:
        .          .          .          .                 e->k = VKINT; e->u.ival = ivalue(v);
        .          .          .          .                 break;
        .          .          .          .               case LUA_VNUMFLT:
        .          .          .          .                 e->k = VKFLT; e->u.nval = fltvalue(v);
-- line 3724 ----------------------------------------
-- line 3734 ----------------------------------------
        .          .          .          .                 break;
        .          .          .          .               case LUA_VSHRSTR:  case LUA_VLNGSTR:
        .          .          .          .                 e->k = VKSTR; e->u.strval = tsvalue(v);
        .          .          .          .                 break;
        .          .          .          .               default: luai_unreachable();
        .          .          .          .             }
        .          .          .          .           }
        .          .          .          .           
      720 ( 0.00%) .          .          .           void luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {
    2,430 ( 0.01%) .          .          .             Instruction *pc = &getinstruction(fs, e);
      630 ( 0.00%) .          .          .             if (e->k == VCALL)  
    1,513 ( 0.01%) .          .          .               SETARG_C(*pc, nresults + 1);
        .          .          .          .             else {
        6 ( 0.00%) .          .          .               lua_assert(e->k == VVARARG);
       17 ( 0.00%) .          .          .               SETARG_C(*pc, nresults + 1);
       20 ( 0.00%) .          .          .               SETARG_A(*pc, fs->freereg);
        3 ( 0.00%) .          .          .               luaK_reserveregs(fs, 1);
       69 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_reserveregs (1x)
        .          .          .          .             }
      540 ( 0.00%) .          .          .           }
        .          .          .          .           
    4,805 ( 0.02%) .          .          .           static void str2K (FuncState *fs, expdesc *e) {
    5,766 ( 0.03%) .          .          .             lua_assert(e->k == VKSTR);
   15,376 ( 0.07%) .          .          .             e->u.info = stringK(fs, e->u.strval);
  724,818 ( 3.34%) 1 ( 0.19%) 26,259 ( 0.00%) 24,752 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:stringK (961x)
    4,805 ( 0.02%) .          .          .             e->k = VK;
    3,844 ( 0.02%) .          .          .           }
        .          .          .          .           
    2,511 ( 0.01%) .          .          .           void luaK_setoneret (FuncState *fs, expdesc *e) {
    1,953 ( 0.01%) .          .          .             if (e->k == VCALL) {  
        .          .          .          .               
   10,062 ( 0.05%) .          .          .               lua_assert(GETARG_C(getinstruction(fs, e)) == 2);
      645 ( 0.00%) .          .          .               e->k = VNONRELOC;  
    4,515 ( 0.02%) .          .          .               e->u.info = GETARG_A(getinstruction(fs, e));
        .          .          .          .             }
      900 ( 0.00%) .          .          .             else if (e->k == VVARARG) {
        .          .          .          .               SETARG_C(getinstruction(fs, e), 2);
        .          .          .          .               e->k = VRELOC;  
        .          .          .          .             }
    2,232 ( 0.01%) .          .          .           }
        .          .          .          .           
   23,575 ( 0.11%) .          .          .           void luaK_dischargevars (FuncState *fs, expdesc *e) {
   51,810 ( 0.24%) .          .          .             switch (e->k) {
        .          .          .          .               case VCONST: {
        .          .          .          .                 const2exp(const2val(fs, e), e);
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VLOCAL: {  
    5,252 ( 0.02%) .          .          .                 e->u.info = e->u.var.ridx;
    2,020 ( 0.01%) .          .          .                 e->k = VNONRELOC;  
      404 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VUPVAL: {  
    1,580 ( 0.01%) .          .          .                 e->u.info = luaK_codeABC(fs, OP_GETUPVAL, 0, e->u.info, 0);
   42,211 ( 0.19%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (79x)
      395 ( 0.00%) .          .          .                 e->k = VRELOC;
       79 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VINDEXUP: {
   15,260 ( 0.07%) .          .          .                 e->u.info = luaK_codeABC(fs, OP_GETTABUP, 0, e->u.ind.t, e->u.ind.idx);
  224,373 ( 1.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (545x)
    2,725 ( 0.01%) .          .          .                 e->k = VRELOC;
      545 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VINDEXI: {
      110 ( 0.00%) .          .          .                 freereg(fs, e->u.ind.t);
    1,394 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freereg (11x)
      242 ( 0.00%) .          .          .                 e->u.info = luaK_codeABC(fs, OP_GETI, 0, e->u.ind.t, e->u.ind.idx);
    4,202 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (11x)
       55 ( 0.00%) .          .          .                 e->k = VRELOC;
       11 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VINDEXSTR: {
    1,000 ( 0.00%) .          .          .                 freereg(fs, e->u.ind.t);
   13,821 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freereg (100x)
    2,200 ( 0.01%) .          .          .                 e->u.info = luaK_codeABC(fs, OP_GETFIELD, 0, e->u.ind.t, e->u.ind.idx);
   39,554 ( 0.18%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (100x)
      500 ( 0.00%) .          .          .                 e->k = VRELOC;
      100 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VINDEXED: {
      608 ( 0.00%) .          .          .                 freeregs(fs, e->u.ind.t, e->u.ind.idx);
    8,929 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeregs (32x)
      704 ( 0.00%) .          .          .                 e->u.info = luaK_codeABC(fs, OP_GETTABLE, 0, e->u.ind.t, e->u.ind.idx);
   13,278 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (32x)
      160 ( 0.00%) .          .          .                 e->k = VRELOC;
       32 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VVARARG: case VCALL: {
      321 ( 0.00%) .          .          .                 luaK_setoneret(fs, e);
   15,194 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_setoneret (107x)
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: break;  
        .          .          .          .             }
   18,967 ( 0.09%) .          .          .           }
        .          .          .          .           
   13,536 ( 0.06%) .          .          .           static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
    1,692 ( 0.01%) .          .          .             luaK_dischargevars(fs, e);
   35,265 ( 0.16%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_dischargevars (1,692x)
   20,304 ( 0.09%) .          .          .             switch (e->k) {
        .          .          .          .               case VNIL: {
       68 ( 0.00%) .          .          .                 luaK_nil(fs, reg, 1);
    8,481 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_nil (17x)
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VFALSE: {
       70 ( 0.00%) .          .          .                 luaK_codeABC(fs, OP_LOADFALSE, reg, 0, 0);
    4,880 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (10x)
       10 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VTRUE: {
       77 ( 0.00%) .          .          .                 luaK_codeABC(fs, OP_LOADTRUE, reg, 0, 0);
    8,137 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (11x)
       11 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VKSTR: {
      615 ( 0.00%) .          .          .                 str2K(fs, e);
  180,181 ( 0.83%) 1 ( 0.19%) 26,259 ( 0.00%) 24,752 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:str2K (205x)
    2,255 ( 0.01%) .          .          .           			luaK_codek(fs, reg, e->u.info);
   83,579 ( 0.39%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codek (205x)
      205 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VK: {
        .          .          .          .                 luaK_codek(fs, reg, e->u.info);
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VKFLT: {
       44 ( 0.00%) .          .          .                 luaK_float(fs, reg, e->u.nval);
    4,917 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_float (4x)
        4 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VKINT: {
    1,342 ( 0.01%) .          .          .                 luaK_int(fs, reg, e->u.ival);
   61,381 ( 0.28%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_int (122x)
      122 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VRELOC: {
   22,802 ( 0.11%) .          .          .                 Instruction *pc = &getinstruction(fs, e);
   13,155 ( 0.06%) .          .          .                 SETARG_A(*pc, reg);  
      877 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VNONRELOC: {
    3,660 ( 0.02%) .          .          .                 if (reg != e->u.info)
    2,796 ( 0.01%) .          .          .                   luaK_codeABC(fs, OP_MOVE, reg, e->u.info, 0);
   92,192 ( 0.43%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (233x)
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: {
      480 ( 0.00%) .          .          .                 lua_assert(e->k == VJMP);
        .          .          .          .                 return;  
        .          .          .          .               }
        .          .          .          .             }
   12,896 ( 0.06%) .          .          .             e->u.info = reg;
    8,060 ( 0.04%) .          .          .             e->k = VNONRELOC;
   10,152 ( 0.05%) .          .          .           }
        .          .          .          .           
      195 ( 0.00%) .          .          .           static void discharge2anyreg (FuncState *fs, expdesc *e) {
      234 ( 0.00%) .          .          .             if (e->k != VNONRELOC) {  
       60 ( 0.00%) .          .          .               luaK_reserveregs(fs, 1);  
    1,160 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_reserveregs (20x)
      300 ( 0.00%) .          .          .               discharge2reg(fs, e, fs->freereg-1);  
    3,288 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:discharge2reg (20x)
        .          .          .          .             }
      176 ( 0.00%) .          .          .           }
        .          .          .          .           
      972 ( 0.00%) .          .          .           static int code_loadbool (FuncState *fs, int A, OpCode op) {
      162 ( 0.00%) .          .          .             luaK_getlabel(fs);  
    4,698 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_getlabel (162x)
    1,134 ( 0.01%) .          .          .             return luaK_codeABC(fs, op, A, 0, 0);
   65,199 ( 0.30%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (162x)
      648 ( 0.00%) .          .          .           }
        .          .          .          .           
      470 ( 0.00%) .          .          .           static int need_value (FuncState *fs, int list) {
      318 ( 0.00%) .          .          .             for (; list != NO_JUMP; list = getjump(fs, list)) {
      540 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getjump (6x)
      783 ( 0.00%) .          .          .               Instruction i = *getjumpcontrol(fs, list);
    5,307 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getjumpcontrol (87x)
      423 ( 0.00%) .          .          .               if (GET_OPCODE(i) != OP_TESTSET) return 1;
        .          .          .          .             }
       13 ( 0.00%) .          .          .             return 0;  
      376 ( 0.00%) .          .          .           }
        .          .          .          .           
   16,720 ( 0.08%) .          .          .           static void exp2reg (FuncState *fs, expdesc *e, int reg) {
    1,672 ( 0.01%) .          .          .             discharge2reg(fs, e, reg);
  590,958 ( 2.73%) 1 ( 0.19%) 26,259 ( 0.00%) 24,752 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:discharge2reg (1,672x)
   10,032 ( 0.05%) .          .          .             if (e->k == VJMP)  
    1,280 ( 0.01%) .          .          .               luaK_concat(fs, &e->t, e->u.info);  
    3,034 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_concat (80x)
   28,424 ( 0.13%) .          .          .             if (hasjumps(e)) {
        .          .          .          .               int final;  
       12 ( 0.00%) .          .          .               int p_f = NO_JUMP;  
        6 ( 0.00%) .          .          .               int p_t = NO_JUMP;  
      846 ( 0.00%) .          .          .               if (need_value(fs, e->t) || need_value(fs, e->f)) {
    8,230 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:need_value (94x)
      570 ( 0.00%) .          .          .                 int fj = (e->k == VJMP) ? NO_JUMP : luaK_jump(fs);
      375 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_jump (1x)
      405 ( 0.00%) .          .          .                 p_f = code_loadbool(fs, reg, OP_LFALSESKIP);  
   36,459 ( 0.17%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:code_loadbool (81x)
      405 ( 0.00%) .          .          .                 p_t = code_loadbool(fs, reg, OP_LOADTRUE);
   36,354 ( 0.17%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:code_loadbool (81x)
        .          .          .          .                 
      243 ( 0.00%) .          .          .                 luaK_patchtohere(fs, fj);
    7,639 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_patchtohere (81x)
        .          .          .          .               }
      261 ( 0.00%) .          .          .               final = luaK_getlabel(fs);
    2,523 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_getlabel (87x)
      870 ( 0.00%) .          .          .               patchlistaux(fs, e->f, final, reg, p_f);
    3,870 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:patchlistaux (87x)
      957 ( 0.00%) .          .          .               patchlistaux(fs, e->t, final, reg, p_t);
   26,821 ( 0.12%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:patchlistaux (87x)
        .          .          .          .             }
   23,408 ( 0.11%) .          .          .             e->f = e->t = NO_JUMP;
    8,360 ( 0.04%) .          .          .             e->u.info = reg;
    8,360 ( 0.04%) .          .          .             e->k = VNONRELOC;
   13,376 ( 0.06%) .          .          .           }
        .          .          .          .           
    8,010 ( 0.04%) .          .          .           void luaK_exp2nextreg (FuncState *fs, expdesc *e) {
    1,602 ( 0.01%) .          .          .             luaK_dischargevars(fs, e);
  287,802 ( 1.33%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_dischargevars (1,602x)
    4,806 ( 0.02%) .          .          .             freeexp(fs, e);
   69,501 ( 0.32%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeexp (1,602x)
    4,806 ( 0.02%) .          .          .             luaK_reserveregs(fs, 1);
   94,533 ( 0.44%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_reserveregs (1,602x)
   24,030 ( 0.11%) .          .          .             exp2reg(fs, e, fs->freereg - 1);
  797,492 ( 3.68%) 1 ( 0.19%) 26,259 ( 0.00%) 24,752 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:exp2reg (1,602x)
    6,408 ( 0.03%) .          .          .           }
        .          .          .          .           
    4,085 ( 0.02%) .          .          .           int luaK_exp2anyreg (FuncState *fs, expdesc *e) {
      817 ( 0.00%) .          .          .             luaK_dischargevars(fs, e);
  100,872 ( 0.47%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_dischargevars (817x)
    4,902 ( 0.02%) .          .          .             if (e->k == VNONRELOC) {  
    9,248 ( 0.04%) .          .          .               if (!hasjumps(e))  
    3,264 ( 0.02%) .          .          .                 return e->u.info;  
        .          .          .          .               if (e->u.info >= luaY_nvarstack(fs)) {  
        .          .          .          .                 exp2reg(fs, e, e->u.info);  
        .          .          .          .                 return e->u.info;
        .          .          .          .               }
        .          .          .          .               
        .          .          .          .             }
      819 ( 0.00%) .          .          .             luaK_exp2nextreg(fs, e);  
  102,457 ( 0.47%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2nextreg (273x)
    2,184 ( 0.01%) .          .          .             return e->u.info;
    3,268 ( 0.02%) .          .          .           }
        .          .          .          .           
    1,080 ( 0.00%) .          .          .           void luaK_exp2anyregup (FuncState *fs, expdesc *e) {
    1,772 ( 0.01%) .          .          .             if (e->k != VUPVAL || hasjumps(e))
      564 ( 0.00%) .          .          .               luaK_exp2anyreg(fs, e);
  115,911 ( 0.53%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (188x)
      864 ( 0.00%) .          .          .           }
        .          .          .          .           
      455 ( 0.00%) .          .          .           void luaK_exp2val (FuncState *fs, expdesc *e) {
    1,547 ( 0.01%) .          .          .             if (hasjumps(e))
        .          .          .          .               luaK_exp2anyreg(fs, e);
        .          .          .          .             else
      273 ( 0.00%) .          .          .               luaK_dischargevars(fs, e);
    6,273 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_dischargevars (91x)
      455 ( 0.00%) .          .          .           }
        .          .          .          .           
    1,710 ( 0.01%) .          .          .           static int luaK_exp2K (FuncState *fs, expdesc *e) {
    5,814 ( 0.03%) .          .          .             if (!hasjumps(e)) {
        .          .          .          .               int info;
    3,363 ( 0.02%) .          .          .               switch (e->k) {  
       27 ( 0.00%) .          .          .                 case VTRUE: info = boolT(fs); break;
    5,930 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:boolT (9x)
       16 ( 0.00%) .          .          .                 case VFALSE: info = boolF(fs); break;
    2,839 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:boolF (4x)
       84 ( 0.00%) .          .          .                 case VNIL: info = nilK(fs); break;
   14,397 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:nilK (21x)
      279 ( 0.00%) .          .          .                 case VKINT: info = luaK_intK(fs, e->u.ival); break;
   25,266 ( 0.12%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_intK (31x)
       36 ( 0.00%) .          .          .                 case VKFLT: info = luaK_numberK(fs, e->u.nval); break;
    4,930 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_numberK (4x)
      315 ( 0.00%) .          .          .                 case VKSTR: info = stringK(fs, e->u.strval); break;
   26,716 ( 0.12%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:stringK (35x)
        .          .          .          .                 case VK: info = e->u.info; break;
        .          .          .          .                 default: return 0;  
        .          .          .          .               }
      208 ( 0.00%) .          .          .               if (info <= MAXINDEXRK) {  
      520 ( 0.00%) .          .          .                 e->k = VK;  
      520 ( 0.00%) .          .          .                 e->u.info = info;
      208 ( 0.00%) .          .          .                 return 1;
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .             
        3 ( 0.00%) .          .          .             return 0;
    1,368 ( 0.01%) .          .          .           }
        .          .          .          .           
    1,605 ( 0.01%) .          .          .           int luaK_exp2RK (FuncState *fs, expdesc *e) {
      963 ( 0.00%) .          .          .             if (luaK_exp2K(fs, e))
   76,158 ( 0.35%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2K (321x)
       83 ( 0.00%) .          .          .               return 1;
        .          .          .          .             else {  
      714 ( 0.00%) .          .          .               luaK_exp2anyreg(fs, e);
   37,826 ( 0.17%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (238x)
      238 ( 0.00%) .          .          .               return 0;
        .          .          .          .             }
    1,843 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void codeABRK (FuncState *fs, OpCode o, int a, int b,
    1,896 ( 0.01%) .          .          .                                 expdesc *ec) {
      474 ( 0.00%) .          .          .             int k = luaK_exp2RK(fs, ec);
   63,435 ( 0.29%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2RK (158x)
    2,212 ( 0.01%) .          .          .             luaK_codeABCk(fs, o, a, b, ec->u.info, k);
   65,364 ( 0.30%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (158x)
    1,264 ( 0.01%) .          .          .           }
        .          .          .          .           
    1,944 ( 0.01%) .          .          .           void luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {
    3,159 ( 0.01%) .          .          .             switch (var->k) {
        .          .          .          .               case VLOCAL: {
      210 ( 0.00%) .          .          .                 freeexp(fs, ex);
    6,864 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeexp (70x)
      770 ( 0.00%) .          .          .                 exp2reg(fs, ex, var->u.var.ridx);  
   34,978 ( 0.16%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:exp2reg (70x)
       70 ( 0.00%) .          .          .                 return;
        .          .          .          .               }
        .          .          .          .               case VUPVAL: {
       64 ( 0.00%) .          .          .                 int e = luaK_exp2anyreg(fs, ex);
   13,424 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (16x)
      224 ( 0.00%) .          .          .                 luaK_codeABC(fs, OP_SETUPVAL, e, var->u.info, 0);
    6,112 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (16x)
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VINDEXUP: {
      924 ( 0.00%) .          .          .                 codeABRK(fs, OP_SETTABUP, var->u.ind.t, var->u.ind.idx, ex);
   40,982 ( 0.19%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codeABRK (44x)
       44 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VINDEXI: {
      126 ( 0.00%) .          .          .                 codeABRK(fs, OP_SETI, var->u.ind.t, var->u.ind.idx, ex);
    3,897 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codeABRK (6x)
        6 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VINDEXSTR: {
    1,407 ( 0.01%) .          .          .                 codeABRK(fs, OP_SETFIELD, var->u.ind.t, var->u.ind.idx, ex);
   59,061 ( 0.27%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codeABRK (67x)
       67 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VINDEXED: {
      840 ( 0.00%) .          .          .                 codeABRK(fs, OP_SETTABLE, var->u.ind.t, var->u.ind.idx, ex);
   29,480 ( 0.14%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codeABRK (40x)
       40 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: luai_unreachable();  
        .          .          .          .             }
      519 ( 0.00%) .          .          .             freeexp(fs, ex);
   20,798 ( 0.10%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeexp (173x)
    1,458 ( 0.01%) .          .          .           }
        .          .          .          .           
        8 ( 0.00%) .          .          .           void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
        .          .          .          .             int ereg;
        1 ( 0.00%) .          .          .             luaK_exp2anyreg(fs, e);
       80 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (1x)
        8 ( 0.00%) .          .          .             ereg = e->u.info;  
        3 ( 0.00%) .          .          .             freeexp(fs, e);
      147 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeexp (1x)
       13 ( 0.00%) .          .          .             e->u.info = fs->freereg;  
        5 ( 0.00%) .          .          .             e->k = VNONRELOC;  
        3 ( 0.00%) .          .          .             luaK_reserveregs(fs, 2);  
       58 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_reserveregs (1x)
       10 ( 0.00%) .          .          .             codeABRK(fs, OP_SELF, e->u.info, ereg, key);
    1,225 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codeABRK (1x)
        3 ( 0.00%) .          .          .             freeexp(fs, key);
       15 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeexp (1x)
        6 ( 0.00%) .          .          .           }
        .          .          .          .           
      207 ( 0.00%) .          .          .           static void negatecondition (FuncState *fs, expdesc *e) {
      253 ( 0.00%) .          .          .             Instruction *pc = getjumpcontrol(fs, e->u.info);
    1,403 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getjumpcontrol (23x)
      897 ( 0.00%) .          .          .             lua_assert(testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET &&
        .          .          .          .                                                      GET_OPCODE(*pc) != OP_TEST);
      828 ( 0.00%) .          .          .             SETARG_k(*pc, (GETARG_k(*pc) ^ 1));
      184 ( 0.00%) .          .          .           }
        .          .          .          .           
      288 ( 0.00%) .          .          .           static int jumponcond (FuncState *fs, expdesc *e, int cond) {
      216 ( 0.00%) .          .          .             if (e->k == VRELOC) {
      620 ( 0.00%) .          .          .               Instruction ie = getinstruction(fs, e);
       80 ( 0.00%) .          .          .               if (GET_OPCODE(ie) == OP_NOT) {
       18 ( 0.00%) .          .          .                 removelastinstruction(fs);  
    1,053 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:removelastinstruction (9x)
      279 ( 0.00%) .          .          .                 return condjump(fs, OP_TEST, GETARG_B(ie), 0, 0, !cond);
    6,876 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:condjump (9x)
        .          .          .          .               }
        .          .          .          .               
        .          .          .          .             }
       81 ( 0.00%) .          .          .             discharge2anyreg(fs, e);
    3,785 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:discharge2anyreg (27x)
       81 ( 0.00%) .          .          .             freeexp(fs, e);
    4,305 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeexp (27x)
      378 ( 0.00%) .          .          .             return condjump(fs, OP_TESTSET, NO_REG, e->u.info, 0, cond);
   21,310 ( 0.10%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:condjump (27x)
      216 ( 0.00%) .          .          .           }
        .          .          .          .           
      265 ( 0.00%) .          .          .           void luaK_goiftrue (FuncState *fs, expdesc *e) {
        .          .          .          .             int pc;  
       53 ( 0.00%) .          .          .             luaK_dischargevars(fs, e);
    6,285 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_dischargevars (53x)
      477 ( 0.00%) .          .          .             switch (e->k) {
        .          .          .          .               case VJMP: {  
       69 ( 0.00%) .          .          .                 negatecondition(fs, e);  
    3,772 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:negatecondition (23x)
      184 ( 0.00%) .          .          .                 pc = e->u.info;  
       23 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VK: case VKFLT: case VKINT: case VKSTR: case VTRUE: {
        .          .          .          .                 pc = NO_JUMP;  
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: {
      150 ( 0.00%) .          .          .                 pc = jumponcond(fs, e, 0);  
   31,398 ( 0.14%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:jumponcond (30x)
       30 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .             }
      583 ( 0.00%) .          .          .             luaK_concat(fs, &e->f, pc);  
    1,537 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_concat (53x)
      371 ( 0.00%) .          .          .             luaK_patchtohere(fs, e->t);  
    4,823 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_patchtohere (53x)
      265 ( 0.00%) .          .          .             e->t = NO_JUMP;
      212 ( 0.00%) .          .          .           }
        .          .          .          .           
       55 ( 0.00%) .          .          .           void luaK_goiffalse (FuncState *fs, expdesc *e) {
        .          .          .          .             int pc;  
       11 ( 0.00%) .          .          .             luaK_dischargevars(fs, e);
      217 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_dischargevars (11x)
      111 ( 0.00%) .          .          .             switch (e->k) {
        .          .          .          .               case VJMP: {
       40 ( 0.00%) .          .          .                 pc = e->u.info;  
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VNIL: case VFALSE: {
        .          .          .          .                 pc = NO_JUMP;  
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: {
       30 ( 0.00%) .          .          .                 pc = jumponcond(fs, e, 1);  
    8,188 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:jumponcond (6x)
        6 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .             }
      121 ( 0.00%) .          .          .             luaK_concat(fs, &e->t, pc);  
      761 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_concat (11x)
      110 ( 0.00%) .          .          .             luaK_patchtohere(fs, e->f);  
    2,395 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_patchtohere (11x)
       55 ( 0.00%) .          .          .             e->f = NO_JUMP;
       44 ( 0.00%) .          .          .           }
        .          .          .          .           
       84 ( 0.00%) .          .          .           static void codenot (FuncState *fs, expdesc *e) {
      144 ( 0.00%) .          .          .             switch (e->k) {
        .          .          .          .               case VNIL: case VFALSE: {
        .          .          .          .                 e->k = VTRUE;  
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VK: case VKFLT: case VKINT: case VKSTR: case VTRUE: {
        .          .          .          .                 e->k = VFALSE;  
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VJMP: {
        .          .          .          .                 negatecondition(fs, e);
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VRELOC:
        .          .          .          .               case VNONRELOC: {
       36 ( 0.00%) .          .          .                 discharge2anyreg(fs, e);
    1,628 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:discharge2anyreg (12x)
       36 ( 0.00%) .          .          .                 freeexp(fs, e);
    1,953 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeexp (12x)
      240 ( 0.00%) .          .          .                 e->u.info = luaK_codeABC(fs, OP_NOT, 0, e->u.info, 0);
    4,584 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (12x)
       60 ( 0.00%) .          .          .                 e->k = VRELOC;
       12 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: luai_unreachable();  
        .          .          .          .             }
        .          .          .          .             
      276 ( 0.00%) .          .          .             { int temp = e->f; e->f = e->t; e->t = temp; }
       84 ( 0.00%) .          .          .             removevalues(fs, e->f);  
      144 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:removevalues (12x)
       84 ( 0.00%) .          .          .             removevalues(fs, e->t);
      144 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:removevalues (12x)
       72 ( 0.00%) .          .          .           }
        .          .          .          .           
    4,300 ( 0.02%) .          .          .           static int isKstr (FuncState *fs, expdesc *e) {
   26,432 ( 0.12%) .          .          .             return (e->k == VK && !hasjumps(e) && e->u.info <= MAXARG_B &&
   22,680 ( 0.10%) .          .          .                     ttisshrstring(&fs->f->k[e->u.info]));
    3,440 ( 0.02%) .          .          .           }
        .          .          .          .           
      484 ( 0.00%) .          .          .           int luaK_isKint (expdesc *e) {
    1,495 ( 0.01%) .          .          .             return (e->k == VKINT && !hasjumps(e));
      484 ( 0.00%) .          .          .           }
        .          .          .          .           
      178 ( 0.00%) .          .          .           static int isCint (expdesc *e) {
      437 ( 0.00%) .          .          .             return luaK_isKint(e) && (l_castS2U(e->u.ival) <= l_castS2U(MAXARG_C));
    1,641 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_isKint (89x)
      178 ( 0.00%) .          .          .           }
        .          .          .          .           
       46 ( 0.00%) .          .          .           static int isSCint (expdesc *e) {
      284 ( 0.00%) .          .          .             return luaK_isKint(e) && fitsC(e->u.ival);
      669 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_isKint (23x)
       90 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:fitsC (18x)
       46 ( 0.00%) .          .          .           }
        .          .          .          .           
    1,496 ( 0.01%) .          .          .           static int isSCnumber (expdesc *e, int *pi, int *isfloat) {
        .          .          .          .             lua_Integer i;
      952 ( 0.00%) .          .          .             if (e->k == VKINT)
      279 ( 0.00%) .          .          .               i = e->u.ival;
      630 ( 0.00%) .          .          .             else if (e->k == VKFLT && luaV_flttointeger(e->u.nval, &i, F2Ieq))
        .          .          .          .               *isfloat = 1;
        .          .          .          .             else
      105 ( 0.00%) .          .          .               return 0;  
      682 ( 0.00%) .          .          .             if (!hasjumps(e) && fitsC(i)) {
      155 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:fitsC (31x)
      208 ( 0.00%) .          .          .               *pi = int2sC(cast_int(i));
       52 ( 0.00%) .          .          .               return 1;
        .          .          .          .             }
        .          .          .          .             else
        .          .          .          .               return 0;
    1,224 ( 0.01%) .          .          .           }
        .          .          .          .           
    6,760 ( 0.03%) .          .          .           void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {
    5,070 ( 0.02%) .          .          .             if (k->k == VKSTR)
    3,024 ( 0.01%) .          .          .               str2K(fs, k);
  579,233 ( 2.67%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:str2K (756x)
   21,125 ( 0.10%) .          .          .             lua_assert(!hasjumps(t) &&
        .          .          .          .                        (t->k == VLOCAL || t->k == VNONRELOC || t->k == VUPVAL));
    8,090 ( 0.04%) .          .          .             if (t->k == VUPVAL && !isKstr(fs, k))  
   43,237 ( 0.20%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:isKstr (604x)
       60 ( 0.00%) .          .          .               luaK_exp2anyreg(fs, t);  
   13,890 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (15x)
    5,915 ( 0.03%) .          .          .             if (t->k == VUPVAL) {
    5,890 ( 0.03%) .          .          .               t->u.ind.t = t->u.info;  
    7,657 ( 0.04%) .          .          .               t->u.ind.idx = k->u.info;  
    3,534 ( 0.02%) .          .          .               t->k = VINDEXUP;
        .          .          .          .             }
        .          .          .          .             else {
        .          .          .          .               
    4,096 ( 0.02%) .          .          .               t->u.ind.t = (t->k == VLOCAL) ? t->u.var.ridx: t->u.info;
    1,280 ( 0.01%) .          .          .               if (isKstr(fs, k)) {
   13,615 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:isKstr (256x)
    2,171 ( 0.01%) .          .          .                 t->u.ind.idx = k->u.info;  
      835 ( 0.00%) .          .          .                 t->k = VINDEXSTR;
        .          .          .          .               }
      356 ( 0.00%) .          .          .               else if (isCint(k)) {
    2,434 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:isCint (89x)
      221 ( 0.00%) .          .          .                 t->u.ind.idx = cast_int(k->u.ival);  
      102 ( 0.00%) .          .          .                 t->k = VINDEXI;
        .          .          .          .               }
        .          .          .          .               else {
      648 ( 0.00%) .          .          .                 t->u.ind.idx = luaK_exp2anyreg(fs, k);  
    6,366 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (72x)
      360 ( 0.00%) .          .          .                 t->k = VINDEXED;
        .          .          .          .               }
        .          .          .          .             }
    5,142 ( 0.02%) .          .          .           }
        .          .          .          .           
       99 ( 0.00%) .          .          .           static int validop (int op, TValue *v1, TValue *v2) {
      113 ( 0.00%) .          .          .             switch (op) {
        .          .          .          .               case LUA_OPBAND: case LUA_OPBOR: case LUA_OPBXOR:
        .          .          .          .               case LUA_OPSHL: case LUA_OPSHR: case LUA_OPBNOT: {  
        .          .          .          .                 lua_Integer i;
        .          .          .          .                 return (luaV_tointegerns(v1, &i, LUA_FLOORN2I) &&
        .          .          .          .                         luaV_tointegerns(v2, &i, LUA_FLOORN2I));
        .          .          .          .               }
        .          .          .          .               case LUA_OPDIV: case LUA_OPIDIV: case LUA_OPMOD:  
       35 ( 0.00%) .          .          .                 return (nvalue(v2) != 0);
        .          .          .          .               default: return 1;  
        .          .          .          .             }
       77 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static int constfolding (FuncState *fs, int op, expdesc *e1,
      708 ( 0.00%) .          .          .                                                   const expdesc *e2) {
        .          .          .          .             TValue v1, v2, res;
      451 ( 0.00%) .          .          .             if (!tonumeral(e1, &v1) || !tonumeral(e2, &v2) || !validop(op, &v1, &v2))
    3,429 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:tonumeral (77x)
      324 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:validop (11x)
       48 ( 0.00%) .          .          .               return 0;  
      231 ( 0.00%) .          .          .             luaO_rawarith(fs->ls->L, op, &v1, &v2, &res);  
    3,168 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaO_rawarith (11x)
       33 ( 0.00%) .          .          .             if (ttisinteger(&res)) {
       20 ( 0.00%) .          .          .               e1->k = VKINT;
       44 ( 0.00%) .          .          .               e1->u.ival = ivalue(&res);
        .          .          .          .             }
        .          .          .          .             else {  
       21 ( 0.00%) .          .          .               lua_Number n = fltvalue(&res);
       91 ( 0.00%) .          .          .               if (luai_numisnan(n) || n == 0)
        .          .          .          .                 return 0;
       35 ( 0.00%) .          .          .               e1->k = VKFLT;
       56 ( 0.00%) .          .          .               e1->u.nval = n;
        .          .          .          .             }
       22 ( 0.00%) .          .          .             return 1;
      531 ( 0.00%) .          .          .           }
        .          .          .          .           
       36 ( 0.00%) .          .          .           static void codeunexpval (FuncState *fs, OpCode op, expdesc *e, int line) {
       12 ( 0.00%) .          .          .             int r = luaK_exp2anyreg(fs, e);  
      513 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (4x)
       12 ( 0.00%) .          .          .             freeexp(fs, e);
      609 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeexp (4x)
       64 ( 0.00%) .          .          .             e->u.info = luaK_codeABC(fs, op, 0, r, 0);  
    1,528 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (4x)
       20 ( 0.00%) .          .          .             e->k = VRELOC;  
       12 ( 0.00%) .          .          .             luaK_fixline(fs, line);
    1,072 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_fixline (4x)
       24 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void finishbinexpval (FuncState *fs, expdesc *e1, expdesc *e2,
        .          .          .          .                                        OpCode op, int v2, int flip, int line,
      624 ( 0.00%) .          .          .                                        OpCode mmop, TMS event) {
       96 ( 0.00%) .          .          .             int v1 = luaK_exp2anyreg(fs, e1);
    5,856 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (48x)
      384 ( 0.00%) .          .          .             int pc = luaK_codeABCk(fs, op, 0, v1, v2, 0);
   20,240 ( 0.09%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (48x)
      192 ( 0.00%) .          .          .             freeexps(fs, e1, e2);
   14,375 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeexps (48x)
      384 ( 0.00%) .          .          .             e1->u.info = pc;
      240 ( 0.00%) .          .          .             e1->k = VRELOC;  
      144 ( 0.00%) .          .          .             luaK_fixline(fs, line);
   12,864 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_fixline (48x)
      336 ( 0.00%) .          .          .             luaK_codeABCk(fs, mmop, v1, v2, event, flip);  
   20,812 ( 0.10%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (48x)
      144 ( 0.00%) .          .          .             luaK_fixline(fs, line);
   12,864 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_fixline (48x)
      384 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void codebinexpval (FuncState *fs, OpCode op,
       90 ( 0.00%) .          .          .                                      expdesc *e1, expdesc *e2, int line) {
       27 ( 0.00%) .          .          .             int v2 = luaK_exp2anyreg(fs, e2);  
    2,560 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (9x)
       27 ( 0.00%) .          .          .             lua_assert(OP_ADD <= op && op <= OP_SHR);
       90 ( 0.00%) .          .          .             finishbinexpval(fs, e1, e2, op, v2, 0, line, OP_MMBIN,
   20,188 ( 0.09%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:finishbinexpval (9x)
        9 ( 0.00%) .          .          .                             cast(TMS, (op - OP_ADD) + TM_ADD));
       63 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void codebini (FuncState *fs, OpCode op,
        .          .          .          .                                  expdesc *e1, expdesc *e2, int flip, int line,
      221 ( 0.00%) .          .          .                                  TMS event) {
      187 ( 0.00%) .          .          .             int v2 = int2sC(cast_int(e2->u.ival));  
      102 ( 0.00%) .          .          .             lua_assert(e2->k == VKINT);
      204 ( 0.00%) .          .          .             finishbinexpval(fs, e1, e2, op, v2, flip, line, OP_MMBINI, event);
   29,609 ( 0.14%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:finishbinexpval (17x)
      136 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static int finishbinexpneg (FuncState *fs, expdesc *e1, expdesc *e2,
      117 ( 0.00%) .          .          .                                        OpCode op, int line, TMS event) {
       36 ( 0.00%) .          .          .             if (!luaK_isKint(e2))
      153 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_isKint (9x)
        .          .          .          .               return 0;  
        .          .          .          .             else {
        8 ( 0.00%) .          .          .               lua_Integer i2 = e2->u.ival;
       11 ( 0.00%) .          .          .               if (!(fitsC(i2) && fitsC(-i2)))
       10 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:fitsC (2x)
        .          .          .          .                 return 0;  
        .          .          .          .               else {  
        2 ( 0.00%) .          .          .                 int v2 = cast_int(i2);
       17 ( 0.00%) .          .          .                 finishbinexpval(fs, e1, e2, op, int2sC(-v2), 0, line, OP_MMBINI, event);
    1,710 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:finishbinexpval (1x)
        .          .          .          .                 
       69 ( 0.00%) .          .          .                 SETARG_B(fs->f->code[fs->pc - 1], int2sC(v2));
        2 ( 0.00%) .          .          .                 return 1;  
        .          .          .          .               }
        .          .          .          .             }
       72 ( 0.00%) .          .          .           }
        .          .          .          .           
       50 ( 0.00%) .          .          .           static void swapexps (expdesc *e1, expdesc *e2) {
      280 ( 0.00%) .          .          .             expdesc temp = *e1; *e1 = *e2; *e2 = temp;  
       40 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void codearith (FuncState *fs, BinOpr opr,
      390 ( 0.00%) .          .          .                                  expdesc *e1, expdesc *e2, int flip, int line) {
       30 ( 0.00%) .          .          .             TMS event = cast(TMS, opr + TM_ADD);
      297 ( 0.00%) .          .          .             if (tonumeral(e2, NULL) && luaK_exp2K(fs, e2)) {  
   18,391 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2K (21x)
    1,144 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:tonumeral (30x)
      147 ( 0.00%) .          .          .               int v2 = e2->u.info;  
       21 ( 0.00%) .          .          .               OpCode op = cast(OpCode, opr + OP_ADDK);
      231 ( 0.00%) .          .          .               finishbinexpval(fs, e1, e2, op, v2, flip, line, OP_MMBINK, event);
   38,432 ( 0.18%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:finishbinexpval (21x)
        .          .          .          .             }
        .          .          .          .             else {  
        9 ( 0.00%) .          .          .               OpCode op = cast(OpCode, opr + OP_ADD);
       18 ( 0.00%) .          .          .               if (flip)
        .          .          .          .                 swapexps(e1, e2);  
       54 ( 0.00%) .          .          .               codebinexpval(fs, op, e1, e2, line);  
   23,054 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codebinexpval (9x)
        .          .          .          .             }
      240 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void codecommutative (FuncState *fs, BinOpr op,
      408 ( 0.00%) .          .          .                                        expdesc *e1, expdesc *e2, int line) {
        .          .          .          .             int flip = 0;
      204 ( 0.00%) .          .          .             if (tonumeral(e1, NULL)) {  
    1,266 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:tonumeral (34x)
       12 ( 0.00%) .          .          .               swapexps(e1, e2);  
      148 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:swapexps (4x)
        8 ( 0.00%) .          .          .               flip = 1;
        .          .          .          .             }
      160 ( 0.00%) .          .          .             if (op == OPR_ADD && isSCint(e2))  
    1,135 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:isSCint (23x)
      187 ( 0.00%) .          .          .               codebini(fs, cast(OpCode, OP_ADDI), e1, e2, flip, line, TM_ADD);
   30,459 ( 0.14%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codebini (17x)
        .          .          .          .             else
      119 ( 0.00%) .          .          .               codearith(fs, op, e1, e2, flip, line);
   47,020 ( 0.22%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codearith (17x)
      272 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void codebitwise (FuncState *fs, BinOpr opr,
        .          .          .          .                                    expdesc *e1, expdesc *e2, int line) {
        .          .          .          .             int flip = 0;
        .          .          .          .             int v2;
        .          .          .          .             OpCode op;
        .          .          .          .             if (e1->k == VKINT && luaK_exp2RK(fs, e1)) {
        .          .          .          .               swapexps(e1, e2);  
-- line 4319 ----------------------------------------
-- line 4326 ----------------------------------------
        .          .          .          .             }
        .          .          .          .             v2 = e2->u.info;  
        .          .          .          .             op = cast(OpCode, opr + OP_ADDK);
        .          .          .          .             lua_assert(ttisinteger(&fs->f->k[v2]));
        .          .          .          .             finishbinexpval(fs, e1, e2, op, v2, flip, line, OP_MMBINK,
        .          .          .          .                             cast(TMS, opr + TM_ADD));
        .          .          .          .           }
        .          .          .          .           
      196 ( 0.00%) .          .          .           static void codeorder (FuncState *fs, OpCode op, expdesc *e1, expdesc *e2) {
        .          .          .          .             int r1, r2;
        .          .          .          .             int im;
       14 ( 0.00%) .          .          .             int isfloat = 0;
       84 ( 0.00%) .          .          .             if (isSCnumber(e2, &im, &isfloat)) {
      563 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:isSCnumber (14x)
        .          .          .          .               
        .          .          .          .               r1 = luaK_exp2anyreg(fs, e1);
        .          .          .          .               r2 = im;
        .          .          .          .               op = cast(OpCode, (op - OP_LT) + OP_LTI);
        .          .          .          .             }
       84 ( 0.00%) .          .          .             else if (isSCnumber(e1, &im, &isfloat)) {
      515 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:isSCnumber (14x)
        .          .          .          .               
        4 ( 0.00%) .          .          .               r1 = luaK_exp2anyreg(fs, e2);
       56 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (1x)
        1 ( 0.00%) .          .          .               r2 = im;
        4 ( 0.00%) .          .          .               op = (op == OP_LT) ? OP_GTI : OP_GEI;
        .          .          .          .             }
        .          .          .          .             else {  
       52 ( 0.00%) .          .          .               r1 = luaK_exp2anyreg(fs, e1);
    2,173 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (13x)
       65 ( 0.00%) .          .          .               r2 = luaK_exp2anyreg(fs, e2);
    4,196 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (13x)
        .          .          .          .             }
       56 ( 0.00%) .          .          .             freeexps(fs, e1, e2);
    4,684 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeexps (14x)
      224 ( 0.00%) .          .          .             e1->u.info = condjump(fs, op, r1, r2, isfloat, 1);
   11,735 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:condjump (14x)
       70 ( 0.00%) .          .          .             e1->k = VJMP;
      154 ( 0.00%) .          .          .           }
        .          .          .          .           
    1,316 ( 0.01%) .          .          .           static void codeeq (FuncState *fs, BinOpr opr, expdesc *e1, expdesc *e2) {
        .          .          .          .             int r1, r2;
        .          .          .          .             int im;
       94 ( 0.00%) .          .          .             int isfloat = 0;  
        .          .          .          .             OpCode op;
      658 ( 0.00%) .          .          .             if (e1->k != VNONRELOC) {
        .          .          .          .               lua_assert(e1->k == VK || e1->k == VKINT || e1->k == VKFLT);
        .          .          .          .               swapexps(e1, e2);
        .          .          .          .             }
      376 ( 0.00%) .          .          .             r1 = luaK_exp2anyreg(fs, e1);  
    5,264 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (94x)
      564 ( 0.00%) .          .          .             if (isSCnumber(e2, &im, &isfloat)) {
    4,229 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:isSCnumber (94x)
       25 ( 0.00%) .          .          .               op = OP_EQI;
       25 ( 0.00%) .          .          .               r2 = im;  
        .          .          .          .             }
      345 ( 0.00%) .          .          .             else if (luaK_exp2RK(fs, e2)) {  
   38,502 ( 0.18%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2RK (69x)
       74 ( 0.00%) .          .          .               op = OP_EQK;
      296 ( 0.00%) .          .          .               r2 = e2->u.info;  
        .          .          .          .             }
        .          .          .          .             else {
       64 ( 0.00%) .          .          .               op = OP_EQ;  
      128 ( 0.00%) .          .          .               r2 = luaK_exp2anyreg(fs, e2);
    1,792 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (32x)
        .          .          .          .             }
      376 ( 0.00%) .          .          .             freeexps(fs, e1, e2);
   29,568 ( 0.14%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeexps (94x)
    1,692 ( 0.01%) .          .          .             e1->u.info = condjump(fs, op, r1, r2, isfloat, (opr == OPR_EQ));
   81,582 ( 0.38%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:condjump (94x)
      470 ( 0.00%) .          .          .             e1->k = VJMP;
    1,034 ( 0.00%) .          .          .           }
        .          .          .          .           
      162 ( 0.00%) .          .          .           void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e, int line) {
        .          .          .          .             static const expdesc ef = {VKINT, {0}, NO_JUMP, NO_JUMP};
       36 ( 0.00%) .          .          .             luaK_dischargevars(fs, e);
    6,355 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_dischargevars (18x)
       54 ( 0.00%) .          .          .             switch (op) {
        .          .          .          .               case OPR_MINUS: case OPR_BNOT:  
       14 ( 0.00%) .          .          .                 if (constfolding(fs, op + LUA_OPUNM, e, &ef))
      642 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:constfolding (2x)
        .          .          .          .                   break;
        .          .          .          .                 codeunexpval(fs, cast(OpCode, op + OP_UNM), e, line);
        .          .          .          .                 break;
        .          .          .          .               case OPR_LEN:
       20 ( 0.00%) .          .          .                 codeunexpval(fs, cast(OpCode, op + OP_UNM), e, line);
    3,902 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codeunexpval (4x)
        .          .          .          .                 break;
       48 ( 0.00%) .          .          .               case OPR_NOT: codenot(fs, e); break;
    9,581 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codenot (12x)
        .          .          .          .               default: luai_unreachable();
        .          .          .          .             }
      108 ( 0.00%) .          .          .           }
        .          .          .          .           
    2,110 ( 0.01%) .          .          .           void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
      422 ( 0.00%) .          .          .             luaK_dischargevars(fs, v);
   33,280 ( 0.15%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_dischargevars (211x)
    1,477 ( 0.01%) .          .          .             switch (op) {
        .          .          .          .               case OPR_AND: {
       36 ( 0.00%) .          .          .                 luaK_goiftrue(fs, v);  
    5,353 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_goiftrue (12x)
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case OPR_OR: {
       33 ( 0.00%) .          .          .                 luaK_goiffalse(fs, v);  
   12,144 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_goiffalse (11x)
       11 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case OPR_CONCAT: {
       69 ( 0.00%) .          .          .                 luaK_exp2nextreg(fs, v);  
   23,029 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2nextreg (23x)
       23 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case OPR_ADD: case OPR_SUB:
        .          .          .          .               case OPR_MUL: case OPR_DIV: case OPR_IDIV:
        .          .          .          .               case OPR_MOD: case OPR_POW:
        .          .          .          .               case OPR_BAND: case OPR_BOR: case OPR_BXOR:
        .          .          .          .               case OPR_SHL: case OPR_SHR: {
      285 ( 0.00%) .          .          .                 if (!tonumeral(v, NULL))
    2,141 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:tonumeral (57x)
      164 ( 0.00%) .          .          .                   luaK_exp2anyreg(fs, v);
    4,319 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (41x)
        .          .          .          .                 
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case OPR_EQ: case OPR_NE: {
      470 ( 0.00%) .          .          .                 if (!tonumeral(v, NULL))
    3,478 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:tonumeral (94x)
      376 ( 0.00%) .          .          .                   luaK_exp2RK(fs, v);
   17,493 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2RK (94x)
        .          .          .          .                 
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case OPR_LT: case OPR_LE:
        .          .          .          .               case OPR_GT: case OPR_GE: {
        .          .          .          .                 int dummy, dummy2;
       84 ( 0.00%) .          .          .                 if (!isSCnumber(v, &dummy, &dummy2))
      476 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:isSCnumber (14x)
       42 ( 0.00%) .          .          .                   luaK_exp2anyreg(fs, v);
    1,073 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (14x)
        .          .          .          .                 
       14 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: luai_unreachable();
        .          .          .          .             }
    1,688 ( 0.01%) .          .          .           }
        .          .          .          .           
      253 ( 0.00%) .          .          .           static void codeconcat (FuncState *fs, expdesc *e1, expdesc *e2, int line) {
       46 ( 0.00%) .          .          .             Instruction *ie2 = previousinstruction(fs);
    1,150 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:previousinstruction (23x)
      207 ( 0.00%) .          .          .             if (GET_OPCODE(*ie2) == OP_CONCAT) {  
      145 ( 0.00%) .          .          .               int n = GETARG_B(*ie2);  
       95 ( 0.00%) .          .          .               lua_assert(e1->u.info + 1 == GETARG_A(*ie2));
       15 ( 0.00%) .          .          .               freeexp(fs, e2);
      840 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeexp (5x)
       95 ( 0.00%) .          .          .               SETARG_A(*ie2, e1->u.info);  
       80 ( 0.00%) .          .          .               SETARG_B(*ie2, n + 1);  
        .          .          .          .             }
        .          .          .          .             else {  
      252 ( 0.00%) .          .          .               luaK_codeABC(fs, OP_CONCAT, e1->u.info, 2, 0);  
    7,550 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (18x)
       54 ( 0.00%) .          .          .               freeexp(fs, e2);
    3,024 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeexp (18x)
       54 ( 0.00%) .          .          .               luaK_fixline(fs, line);
    4,824 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_fixline (18x)
        .          .          .          .             }
      202 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaK_posfix (FuncState *fs, BinOpr opr,
    2,110 ( 0.01%) .          .          .                             expdesc *e1, expdesc *e2, int line) {
      422 ( 0.00%) .          .          .             luaK_dischargevars(fs, e2);
   15,079 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_dischargevars (211x)
      821 ( 0.00%) .          .          .             if (foldbinop(opr) && constfolding(fs, opr + LUA_OPADD, e1, e2))
    8,570 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:constfolding (57x)
        .          .          .          .               return;  
    1,414 ( 0.01%) .          .          .             switch (opr) {
        .          .          .          .               case OPR_AND: {
      108 ( 0.00%) .          .          .                 lua_assert(e1->t == NO_JUMP);  
      228 ( 0.00%) .          .          .                 luaK_concat(fs, &e2->f, e1->f);
      348 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_concat (12x)
      144 ( 0.00%) .          .          .                 *e1 = *e2;
       12 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case OPR_OR: {
       99 ( 0.00%) .          .          .                 lua_assert(e1->f == NO_JUMP);  
      176 ( 0.00%) .          .          .                 luaK_concat(fs, &e2->t, e1->t);
      319 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_concat (11x)
      132 ( 0.00%) .          .          .                 *e1 = *e2;
       11 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case OPR_CONCAT: {  
       69 ( 0.00%) .          .          .                 luaK_exp2nextreg(fs, e2);
   24,505 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2nextreg (23x)
      115 ( 0.00%) .          .          .                 codeconcat(fs, e1, e2, line);
   18,886 ( 0.09%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codeconcat (23x)
       23 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case OPR_ADD: case OPR_MUL: {
      204 ( 0.00%) .          .          .                 codecommutative(fs, opr, e1, e2, line);
   81,398 ( 0.38%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codecommutative (34x)
       34 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case OPR_SUB: {
       81 ( 0.00%) .          .          .                 if (finishbinexpneg(fs, e1, e2, OP_ADDI, line, TM_SUB))
    2,207 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:finishbinexpneg (9x)
        .          .          .          .                   break; 
        .          .          .          .                 
        .          .          .          .           			goto lb_ft1;
        .          .          .          .               }  
        .          .          .          .               case OPR_DIV: case OPR_IDIV: case OPR_MOD: case OPR_POW:
        .          .          .          .           		lb_ft1:	{
       91 ( 0.00%) .          .          .                 codearith(fs, opr, e1, e2, 0, line);
   35,438 ( 0.16%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codearith (13x)
       13 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case OPR_BAND: case OPR_BOR: case OPR_BXOR: {
        .          .          .          .                 codebitwise(fs, opr, e1, e2, line);
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case OPR_SHL: {
        .          .          .          .                 if (isSCint(e1)) {
        .          .          .          .                   swapexps(e1, e2);
-- line 4506 ----------------------------------------
-- line 4516 ----------------------------------------
        .          .          .          .               case OPR_SHR: {
        .          .          .          .                 if (isSCint(e2))
        .          .          .          .                   codebini(fs, OP_SHRI, e1, e2, 0, line, TM_SHR);  
        .          .          .          .                 else  
        .          .          .          .                   codebinexpval(fs, OP_SHR, e1, e2, line);
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case OPR_EQ: case OPR_NE: {
      470 ( 0.00%) .          .          .                 codeeq(fs, opr, e1, e2);
  168,474 ( 0.78%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codeeq (94x)
       94 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case OPR_LT: case OPR_LE: {
        8 ( 0.00%) .          .          .                 OpCode op = cast(OpCode, (opr - OPR_EQ) + OP_EQ);
       32 ( 0.00%) .          .          .                 codeorder(fs, op, e1, e2);
   15,396 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codeorder (8x)
        8 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case OPR_GT: case OPR_GE: {
        .          .          .          .                 
        6 ( 0.00%) .          .          .                 OpCode op = cast(OpCode, (opr - OPR_NE) + OP_EQ);
       18 ( 0.00%) .          .          .                 swapexps(e1, e2);
      222 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:swapexps (6x)
       30 ( 0.00%) .          .          .                 codeorder(fs, op, e1, e2);
    9,534 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codeorder (6x)
        6 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: luai_unreachable();
        .          .          .          .             }
    1,266 ( 0.01%) .          .          .           }
        .          .          .          .           
    3,395 ( 0.02%) .          .          .           void luaK_fixline (FuncState *fs, int line) {
      679 ( 0.00%) .          .          .             removelastlineinfo(fs);
   62,498 ( 0.29%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:removelastlineinfo (679x)
    5,432 ( 0.03%) .          .          .             savelineinfo(fs, fs->f, line);
  107,726 ( 0.50%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:savelineinfo (679x)
    2,716 ( 0.01%) .          .          .           }
        .          .          .          .           
    1,350 ( 0.01%) .          .          .           void luaK_settablesize (FuncState *fs, int pc, int ra, int asize, int hsize) {
    2,700 ( 0.01%) .          .          .             Instruction *inst = &fs->f->code[pc];
      495 ( 0.00%) .          .          .             int rb = (hsize != 0) ? luaO_ceillog2(hsize) + 1 : 0;  
    1,440 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaO_ceillog2 (45x)
      540 ( 0.00%) .          .          .             int extra = asize / (MAXARG_C + 1);  
      810 ( 0.00%) .          .          .             int rc = asize % (MAXARG_C + 1);  
      270 ( 0.00%) .          .          .             int k = (extra > 0);  
    2,025 ( 0.01%) .          .          .             *inst = CREATE_ABCk(OP_NEWTABLE, ra, rb, rc, k);
    1,485 ( 0.01%) .          .          .             *(inst + 1) = CREATE_Ax(OP_EXTRAARG, extra);
      810 ( 0.00%) .          .          .           }
        .          .          .          .           
       96 ( 0.00%) .          .          .           void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {
      192 ( 0.00%) .          .          .             lua_assert(tostore != 0 && tostore <= LFIELDS_PER_FLUSH);
       48 ( 0.00%) .          .          .             if (tostore == LUA_MULTRET)
        8 ( 0.00%) .          .          .               tostore = 0;
       48 ( 0.00%) .          .          .             if (nelems <= MAXARG_C)
      120 ( 0.00%) .          .          .               luaK_codeABC(fs, OP_SETLIST, base, tostore, nelems);
    9,316 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (24x)
        .          .          .          .             else {
        .          .          .          .               int extra = nelems / (MAXARG_C + 1);
        .          .          .          .               nelems %= (MAXARG_C + 1);
        .          .          .          .               luaK_codeABCk(fs, OP_SETLIST, base, tostore, nelems, 1);
        .          .          .          .               codeextraarg(fs, extra);
        .          .          .          .             }
      216 ( 0.00%) .          .          .             fs->freereg = base + 1;  
       96 ( 0.00%) .          .          .           }
        .          .          .          .           
    1,113 ( 0.01%) .          .          .           static int finaltarget (Instruction *code, int i) {
        .          .          .          .             int count;
    1,590 ( 0.01%) .          .          .             for (count = 0; count < 100; count++) {  
    3,498 ( 0.02%) .          .          .               Instruction pc = code[i];
    1,272 ( 0.01%) .          .          .               if (GET_OPCODE(pc) != OP_JMP)
        .          .          .          .                 break;
        .          .          .          .                else
    4,452 ( 0.02%) .          .          .                  i += GETARG_sJ(pc) + 1;
        .          .          .          .             }
        .          .          .          .             return i;
    1,113 ( 0.01%) .          .          .           }
        .          .          .          .           
      456 ( 0.00%) .          .          .           void luaK_finish (FuncState *fs) {
        .          .          .          .             int i;
      285 ( 0.00%) .          .          .             Proto *p = fs->f;
   42,630 ( 0.20%) .          .          .             for (i = 0; i < fs->pc; i++) {
   48,465 ( 0.22%) .          .          .               Instruction *pc = &p->code[i];
  272,347 ( 1.26%) .          .          .               lua_assert(i == 0 || isOT(*(pc - 1)) == isIT(*pc));
   41,595 ( 0.19%) .          .          .               switch (GET_OPCODE(*pc)) {
        .          .          .          .                 case OP_RETURN0: case OP_RETURN1: {
    1,092 ( 0.01%) .          .          .                   if (!(fs->needclose || p->is_vararg))
        .          .          .          .                     break;  
        .          .          .          .                   
       99 ( 0.00%) .          .          .                   SET_OPCODE(*pc, OP_RETURN);
        .          .          .          .           				goto ft_2;
        .          .          .          .                 }  
        .          .          .          .           			case OP_RETURN: case OP_TAILCALL: 
        .          .          .          .           			ft_2: {
      135 ( 0.00%) .          .          .                   if (fs->needclose)
       88 ( 0.00%) .          .          .                     SETARG_k(*pc, 1);  
       90 ( 0.00%) .          .          .                   if (p->is_vararg)
       88 ( 0.00%) .          .          .                     SETARG_C(*pc, p->numparams + 1);  
        .          .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case OP_JMP: {
    1,272 ( 0.01%) .          .          .                   int target = finaltarget(p->code, i);
   13,038 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:finaltarget (159x)
      477 ( 0.00%) .          .          .                   fixjump(fs, i, target);
   11,289 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:fixjump (159x)
        .          .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 default: break;
        .          .          .          .               }
        .          .          .          .             }
      456 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           // root include lctype.c
        .          .          .          .           
        .          .          .          .           // root include ldebug.c
        .          .          .          .           
        .          .          .          .           //included "stdarg.h" 
        .          .          .          .           //included "stddef.h" 
        .          .          .          .           //included "string.h" 
-- line 4623 ----------------------------------------
-- line 4627 ----------------------------------------
        .          .          .          .           
        .          .          .          .           //included "lfunc.h" 
        .          .          .          .           
        .          .          .          .           #define noLuaClosure(f)		((f) == NULL || (f)->c.tt == LUA_VCCL)
        .          .          .          .           
        .          .          .          .           static const char *funcnamefromcall (lua_State *L, CallInfo *ci,
        .          .          .          .                                                              const char **name);
        .          .          .          .           
    2,670 ( 0.01%) .          .          .           static int currentpc (CallInfo *ci) {
    4,005 ( 0.02%) .          .          .             lua_assert(isLua(ci));
   31,150 ( 0.14%) .          .          .             return pcRel(ci->u.l.savedpc, ci_func(ci)->p);
    3,115 ( 0.01%) .          .          .           }
        .          .          .          .           
    2,730 ( 0.01%) .          .          .           static int getbaseline (const Proto *f, int pc, int *basepc) {
    4,844 ( 0.02%) .          .          .             if (f->sizeabslineinfo == 0 || pc < f->abslineinfo[0].pc) {
    1,568 ( 0.01%) .          .          .               *basepc = -1;  
    1,792 ( 0.01%) .          .          .               return f->linedefined;
        .          .          .          .             }
        .          .          .          .             else {
      196 ( 0.00%) .          .          .               int i = cast_uint(pc) / MAXIWTHABS - 1;  
        .          .          .          .               
    1,176 ( 0.01%) .          .          .               lua_assert(i < 0 ||
        .          .          .          .                         (i < f->sizeabslineinfo && f->abslineinfo[i].pc <= pc));
    1,372 ( 0.01%) .          .          .               while (i + 1 < f->sizeabslineinfo && pc >= f->abslineinfo[i + 1].pc)
        .          .          .          .                 i++;  
    1,078 ( 0.00%) .          .          .               *basepc = f->abslineinfo[i].pc;
      931 ( 0.00%) .          .          .               return f->abslineinfo[i].line;
        .          .          .          .             }
    2,184 ( 0.01%) .          .          .           }
        .          .          .          .           
    3,276 ( 0.02%) .          .          .           int luaG_getfuncline (const Proto *f, int pc) {
    2,457 ( 0.01%) .          .          .             if (f->lineinfo == NULL)  
        .          .          .          .               return -1;
        .          .          .          .             else {
        .          .          .          .               int basepc;
    1,365 ( 0.01%) .          .          .               int baseline = getbaseline(f, pc, &basepc);
   17,871 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getbaseline (273x)
   68,992 ( 0.32%) .          .          .               while (basepc++ < pc) {  
  162,248 ( 0.75%) .          .          .                 lua_assert(f->lineinfo[basepc] != ABSLINEINFO);
  133,616 ( 0.62%) .          .          .                 baseline += f->lineinfo[basepc];  
        .          .          .          .               }
        .          .          .          .               return baseline;
        .          .          .          .             }
    3,276 ( 0.02%) .          .          .           }
        .          .          .          .           
    1,638 ( 0.01%) .          .          .           static int getcurrentline (CallInfo *ci) {
   15,288 ( 0.07%) .          .          .             return luaG_getfuncline(ci_func(ci)->p, currentpc(ci));
  393,101 ( 1.81%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaG_getfuncline (273x)
   25,116 ( 0.12%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:currentpc (273x)
    1,638 ( 0.01%) .          .          .           }
        .          .          .          .           
        2 ( 0.00%) .          .          .           static void settraps (CallInfo *ci) {
       11 ( 0.00%) .          .          .             for (; ci != NULL; ci = ci->previous)
        9 ( 0.00%) .          .          .               if (isLua(ci))
        .          .          .          .                 ci->u.l.trap = 1;
        2 ( 0.00%) .          .          .           }
        .          .          .          .           
        9 ( 0.00%) .          .          .           LUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
        6 ( 0.00%) .          .          .             if (func == NULL || mask == 0) {  
        .          .          .          .               mask = 0;
        .          .          .          .               func = NULL;
        .          .          .          .             }
        8 ( 0.00%) .          .          .             L->hook = func;
        8 ( 0.00%) .          .          .             L->basehookcount = count;
       12 ( 0.00%) .          .          .             resethookcount(L);
        9 ( 0.00%) .          .          .             L->hookmask = cast_byte(mask);
        2 ( 0.00%) .          .          .             if (mask)
        6 ( 0.00%) .          .          .               settraps(L->ci);  
       24 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:settraps (1x)
        7 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API lua_Hook lua_gethook (lua_State *L) {
        .          .          .          .             return L->hook;
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API int lua_gethookmask (lua_State *L) {
        .          .          .          .             return L->hookmask;
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API int lua_gethookcount (lua_State *L) {
        .          .          .          .             return L->basehookcount;
        .          .          .          .           }
        .          .          .          .           
       80 ( 0.00%) .          .          .           LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
        .          .          .          .             int status;
        .          .          .          .             CallInfo *ci;
       20 ( 0.00%) .          .          .             if (level < 0) return 0;  
        .          .          .          .             lua_lock(L);
      551 ( 0.00%) .          .          .             for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)
       84 ( 0.00%) .          .          .               level--;
      120 ( 0.00%) .          .          .             if (level == 0 && ci != &L->base_ci) {  
        8 ( 0.00%) .          .          .               status = 1;
       72 ( 0.00%) .          .          .               ar->i_ci = ci;
        .          .          .          .             }
        4 ( 0.00%) .          .          .             else status = 0;  
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return status;
       60 ( 0.00%) .          .          .           }
        .          .          .          .           
      570 ( 0.00%) .          .          .           static const char *upvalname (const Proto *p, int uv) {
    3,192 ( 0.01%) .          .          .             TString *s = check_exp(uv < p->sizeupvalues, p->upvalues[uv].name);
      228 ( 0.00%) .          .          .             if (s == NULL) return "?";
      798 ( 0.00%) .          .          .             else return getstr(s);
      456 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static const char *findvararg (CallInfo *ci, int n, StkId *pos) {
        .          .          .          .             if (clLvalue(s2v(ci->func))->p->is_vararg) {
        .          .          .          .               int nextra = ci->u.l.nextraargs;
        .          .          .          .               if (n >= -nextra) {  
        .          .          .          .                 *pos = ci->func - nextra - (n + 1);
        .          .          .          .                 return "(vararg)";  
        .          .          .          .               }
-- line 4734 ----------------------------------------
-- line 4788 ----------------------------------------
        .          .          .          .             if (name) {
        .          .          .          .               setobjs2s(L, pos, L->top - 1);
        .          .          .          .               L->top--;  
        .          .          .          .             }
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return name;
        .          .          .          .           }
        .          .          .          .           
    1,360 ( 0.01%) .          .          .           static void funcinfo (lua_Debug *ar, Closure *cl) {
    3,155 ( 0.01%) .          .          .             if (noLuaClosure(cl)) {
      603 ( 0.00%) .          .          .               ar->source = "=[C]";
      536 ( 0.00%) .          .          .               ar->srclen = LL("=[C]");
      536 ( 0.00%) .          .          .               ar->linedefined = -1;
      536 ( 0.00%) .          .          .               ar->lastlinedefined = -1;
      402 ( 0.00%) .          .          .               ar->what = "C";
        .          .          .          .             }
        .          .          .          .             else {
    2,184 ( 0.01%) .          .          .               const Proto *p = cl->l.p;
    2,730 ( 0.01%) .          .          .               if (p->source) {
    5,460 ( 0.03%) .          .          .                 ar->source = getstr(p->source);
    9,555 ( 0.04%) .          .          .                 ar->srclen = tsslen(p->source);
        .          .          .          .               }
        .          .          .          .               else {
        .          .          .          .                 ar->source = "=?";
        .          .          .          .                 ar->srclen = LL("=?");
        .          .          .          .               }
    3,549 ( 0.02%) .          .          .               ar->linedefined = p->linedefined;
    3,549 ( 0.02%) .          .          .               ar->lastlinedefined = p->lastlinedefined;
    3,671 ( 0.02%) .          .          .               ar->what = (ar->linedefined == 0) ? "main" : "Lua";
        .          .          .          .             }
    6,800 ( 0.03%) .          .          .             luaO_chunkid(ar->short_src, ar->source, ar->srclen);
   15,640 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaO_chunkid (340x)
    1,360 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static int nextline (const Proto *p, int currentline, int pc) {
        .          .          .          .             if (p->lineinfo[pc] != ABSLINEINFO)
        .          .          .          .               return currentline + p->lineinfo[pc];
        .          .          .          .             else
        .          .          .          .               return luaG_getfuncline(p, pc);
        .          .          .          .           }
        .          .          .          .           
-- line 4827 ----------------------------------------
-- line 4848 ----------------------------------------
        .          .          .          .               }
        .          .          .          .               for (; i < p->sizelineinfo; i++) {  
        .          .          .          .                 currentline = nextline(p, currentline, i);  
        .          .          .          .                 luaH_setint(L, t, currentline, &v);  
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .           }
        .          .          .          .           
    2,034 ( 0.01%) .          .          .           static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {
        .          .          .          .             
    3,390 ( 0.02%) .          .          .             if (ci != NULL && !(ci->callstatus & CIST_TAIL))
    2,712 ( 0.01%) .          .          .               return funcnamefromcall(L, ci->previous, name);
1,004,764 ( 4.64%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:funcnamefromcall (339x)
        .          .          .          .             else return NULL;  
    1,356 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
    4,116 ( 0.02%) .          .          .                                  Closure *f, CallInfo *ci) {
      343 ( 0.00%) .          .          .             int status = 1;
   11,283 ( 0.05%) .          .          .             for (; *what; what++) {
    8,200 ( 0.04%) .          .          .               switch (*what) {
        .          .          .          .                 case 'S': {
    1,020 ( 0.00%) .          .          .                   funcinfo(ar, f);
   61,626 ( 0.28%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:funcinfo (340x)
      340 ( 0.00%) .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case 'l': {
    7,260 ( 0.03%) .          .          .                   ar->currentline = (ci && isLua(ci)) ? getcurrentline(ci) : -1;
  436,781 ( 2.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getcurrentline (273x)
      339 ( 0.00%) .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case 'u': {
        .          .          .          .                   ar->nups = (f == NULL) ? 0 : f->c.nupvalues;
        .          .          .          .                   if (noLuaClosure(f)) {
        .          .          .          .                     ar->isvararg = 1;
        .          .          .          .                     ar->nparams = 0;
        .          .          .          .                   }
        .          .          .          .                   else {
        .          .          .          .                     ar->isvararg = f->l.p->is_vararg;
        .          .          .          .                     ar->nparams = f->l.p->numparams;
        .          .          .          .                   }
        .          .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case 't': {
       54 ( 0.00%) .          .          .                   ar->istailcall = (ci) ? ci->callstatus & CIST_TAIL : 0;
        3 ( 0.00%) .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case 'n': {
    6,780 ( 0.03%) .          .          .                   ar->namewhat = getfuncname(L, ci, &ar->name);
1,014,256 ( 4.68%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getfuncname (339x)
    2,034 ( 0.01%) .          .          .                   if (ar->namewhat == NULL) {
    1,002 ( 0.00%) .          .          .                     ar->namewhat = "";  
    1,002 ( 0.00%) .          .          .                     ar->name = NULL;
        .          .          .          .                   }
        .          .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case 'r': {
        .          .          .          .                   if (ci == NULL || !(ci->callstatus & CIST_TRAN))
        .          .          .          .                     ar->ftransfer = ar->ntransfer = 0;
        .          .          .          .                   else {
        .          .          .          .                     ar->ftransfer = ci->u2.transferinfo.ftransfer;
-- line 4904 ----------------------------------------
-- line 4908 ----------------------------------------
        .          .          .          .                 }
        .          .          .          .                 case 'L':
        .          .          .          .                 case 'f':  
        .          .          .          .                   break;
        .          .          .          .                 default: status = 0;  
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .             return status;
    3,087 ( 0.01%) .          .          .           }
        .          .          .          .           
    3,430 ( 0.02%) .          .          .           LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
        .          .          .          .             int status;
        .          .          .          .             Closure *cl;
        .          .          .          .             CallInfo *ci;
        .          .          .          .             TValue *func;
        .          .          .          .             lua_lock(L);
    1,372 ( 0.01%) .          .          .             if (*what == '>') {
        .          .          .          .               ci = NULL;
        .          .          .          .               func = s2v(L->top - 1);
        .          .          .          .               api_check(L, ttisfunction(func), "function expected");
        .          .          .          .               what++;  
        .          .          .          .               L->top--;  
        .          .          .          .             }
        .          .          .          .             else {
    2,744 ( 0.01%) .          .          .               ci = ar->i_ci;
    3,773 ( 0.02%) .          .          .               func = s2v(ci->func);
    3,773 ( 0.02%) .          .          .               lua_assert(ttisfunction(func));
        .          .          .          .             }
   13,864 ( 0.06%) .          .          .             cl = ttisclosure(func) ? clvalue(func) : NULL;
    2,401 ( 0.01%) .          .          .             status = auxgetinfo(L, what, ar, cl, ci);
1,559,526 ( 7.20%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:auxgetinfo (343x)
    2,748 ( 0.01%) .          .          .             if (strchr(what, 'f')) {
    8,261 ( 0.04%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strchr-sse2.S:__strchr_sse2 (343x)
      712 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
      324 ( 0.00%) .          .          .               setobj2s(L, L->top, func);
      140 ( 0.00%) .          .          .               api_incr_top(L);
        .          .          .          .             }
    2,744 ( 0.01%) .          .          .             if (strchr(what, 'L'))
    8,261 ( 0.04%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strchr-sse2.S:__strchr_sse2 (343x)
        .          .          .          .               collectvalidlines(L, cl);
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return status;
    3,087 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static const char *getobjname (const Proto *p, int lastpc, int reg,
        .          .          .          .                                          const char **name);
        .          .          .          .           
      312 ( 0.00%) .          .          .           static void kname (const Proto *p, int c, const char **name) {
      728 ( 0.00%) .          .          .             TValue *kvalue = &p->k[c];
    2,756 ( 0.01%) .          .          .             *name = (ttisstring(kvalue)) ? svalue(kvalue) : "?";
      208 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void rname (const Proto *p, int pc, int c, const char **name) {
        .          .          .          .             const char *what = getobjname(p, pc, c, name); 
        .          .          .          .             if (!(what && *what == 'c'))  
        .          .          .          .               *name = "?";
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           static void rkname (const Proto *p, int pc, Instruction i, const char **name) {
        .          .          .          .             int c = GETARG_C(i);  
        .          .          .          .             if (GETARG_k(i))  
        .          .          .          .               kname(p, c, name);
        .          .          .          .             else  
        .          .          .          .               rname(p, pc, c, name);
        .          .          .          .           }
        .          .          .          .           
    1,712 ( 0.01%) .          .          .           static int filterpc (int pc, int jmptarget) {
    3,424 ( 0.02%) .          .          .             if (pc < jmptarget)  
      424 ( 0.00%) .          .          .               return -1;  
        .          .          .          .             else return pc;  
    1,712 ( 0.01%) .          .          .           }
        .          .          .          .           
    1,870 ( 0.01%) .          .          .           static int findsetreg (const Proto *p, int lastpc, int reg) {
        .          .          .          .             int pc;
      187 ( 0.00%) .          .          .             int setreg = -1;  
      187 ( 0.00%) .          .          .             int jmptarget = 0;  
    7,293 ( 0.03%) .          .          .             if (testMMMode(GET_OPCODE(p->code[lastpc])))
        .          .          .          .               lastpc--;  
   79,192 ( 0.37%) .          .          .             for (pc = 0; pc < lastpc; pc++) {
  196,110 ( 0.90%) .          .          .               Instruction i = p->code[pc];
   26,148 ( 0.12%) .          .          .               OpCode op = GET_OPCODE(i);
   65,370 ( 0.30%) .          .          .               int a = GETARG_A(i);
        .          .          .          .               int change;  
   92,748 ( 0.43%) .          .          .               switch (op) {
        .          .          .          .                 case OP_LOADNIL: {  
    1,672 ( 0.01%) .          .          .                   int b = GETARG_B(i);
      968 ( 0.00%) .          .          .                   change = (a <= reg && reg <= a + b);
        .          .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case OP_TFORCALL: {  
        .          .          .          .                   change = (reg >= a + 2);
        .          .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case OP_CALL:
        .          .          .          .                 case OP_TAILCALL: {  
    4,580 ( 0.02%) .          .          .                   change = (reg >= a);
    1,145 ( 0.01%) .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case OP_JMP: {  
   17,756 ( 0.08%) .          .          .                   int b = GETARG_sJ(i);
    3,860 ( 0.02%) .          .          .                   int dest = pc + 1 + b;
        .          .          .          .                   
    4,632 ( 0.02%) .          .          .                   if (dest <= lastpc && dest > jmptarget)
    1,484 ( 0.01%) .          .          .                     jmptarget = dest;  
        .          .          .          .                   change = 0;
        .          .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 default:  
  211,229 ( 0.97%) .          .          .                   change = (testAMode(op) && reg == a);
        .          .          .          .                   break;
        .          .          .          .               }
    2,290 ( 0.01%) .          .          .               if (change)
    6,848 ( 0.03%) .          .          .                 setreg = filterpc(pc, jmptarget);
    7,272 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:filterpc (1,712x)
        .          .          .          .             }
        .          .          .          .             return setreg;
    1,683 ( 0.01%) .          .          .           }
        .          .          .          .           
      676 ( 0.00%) .          .          .           static const char *gxf (const Proto *p, int pc, Instruction i, int isup) {
    1,144 ( 0.01%) .          .          .             int t = GETARG_B(i);  
        .          .          .          .             const char *name;  
      104 ( 0.00%) .          .          .             if (isup)  
      148 ( 0.00%) .          .          .               name = upvalname(p, t);
    1,012 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:upvalname (22x)
        .          .          .          .             else
       75 ( 0.00%) .          .          .               getobjname(p, pc, t, &name);
   70,626 ( 0.33%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getobjname'2 (15x)
      483 ( 0.00%) .          .          .             return (name && strcmp(name, LUA_ENV) == 0) ? "global" : "field";
    1,533 ( 0.01%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strcmp-sse4_2.S:__strcmp_sse42 (37x)
      520 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static const char *getobjname (const Proto *p, int lastpc, int reg,
    2,695 ( 0.01%) .          .          .                                          const char **name) {
        .          .          .          .             int pc;
    3,185 ( 0.01%) .          .          .             *name = luaF_getlocalname(p, reg + 1, lastpc);
  102,213 ( 0.47%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_getlocalname (172x)
    1,470 ( 0.01%) .          .          .             if (*name)  
       58 ( 0.00%) .          .          .               return "local";
        .          .          .          .             
      935 ( 0.00%) .          .          .             pc = findsetreg(p, lastpc, reg);
  675,087 ( 3.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:findsetreg (172x)
      374 ( 0.00%) .          .          .             if (pc != -1) {  
    3,927 ( 0.02%) .          .          .               Instruction i = p->code[pc];
      374 ( 0.00%) .          .          .               OpCode op = GET_OPCODE(i);
    1,309 ( 0.01%) .          .          .               switch (op) {
        .          .          .          .                 case OP_MOVE: {
    1,218 ( 0.01%) .          .          .                   int b = GETARG_B(i);  
      232 ( 0.00%) .          .          .                   if (b < GETARG_A(i))
      348 ( 0.00%) .          .          .                     return getobjname(p, pc, b, name);  
   77,520 ( 0.36%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getobjname'2 (58x)
        .          .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case OP_GETTABUP: {
      740 ( 0.00%) .          .          .                   int k = GETARG_C(i);  
      111 ( 0.00%) .          .          .                   kname(p, k, name);
    1,694 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:kname (22x)
      259 ( 0.00%) .          .          .                   return gxf(p, pc, i, 1);
    3,322 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:gxf (22x)
        .          .          .          .                 }
        .          .          .          .                 case OP_GETTABLE: {
        .          .          .          .                   int k = GETARG_C(i);  
        .          .          .          .                   rname(p, pc, k, name);
        .          .          .          .                   return gxf(p, pc, i, 0);
        .          .          .          .                 }
        .          .          .          .                 case OP_GETI: {
        .          .          .          .                   *name = "integer index";
        .          .          .          .                   return "field";
        .          .          .          .                 }
        .          .          .          .                 case OP_GETFIELD: {
      300 ( 0.00%) .          .          .                   int k = GETARG_C(i);  
       45 ( 0.00%) .          .          .                   kname(p, k, name);
    1,155 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:kname (15x)
      105 ( 0.00%) .          .          .                   return gxf(p, pc, i, 0);
   72,099 ( 0.33%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:gxf (15x)
        .          .          .          .                 }
        .          .          .          .                 case OP_GETUPVAL: {
    2,156 ( 0.01%) .          .          .                   *name = upvalname(p, GETARG_B(i));
    3,542 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:upvalname (77x)
      154 ( 0.00%) .          .          .                   return "upvalue";
        .          .          .          .                 }
        .          .          .          .                 case OP_LOADK:
        .          .          .          .                 case OP_LOADKX: {
        .          .          .          .                   int b = (op == OP_LOADK) ? GETARG_Bx(i)
        .          .          .          .                                            : GETARG_Ax(p->code[pc + 1]);
        .          .          .          .                   if (ttisstring(&p->k[b])) {
        .          .          .          .                     *name = svalue(&p->k[b]);
        .          .          .          .                     return "constant";
-- line 5078 ----------------------------------------
-- line 5082 ----------------------------------------
        .          .          .          .                 case OP_SELF: {
        .          .          .          .                   rkname(p, pc, i, name);
        .          .          .          .                   return "method";
        .          .          .          .                 }
        .          .          .          .                 default: break;  
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .             return NULL;  
    2,205 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static const char *funcnamefromcode (lua_State *L, const Proto *p,
    1,892 ( 0.01%) .          .          .                                                int pc, const char **name) {
        .          .          .          .             TMS tm = (TMS)0;  
    3,268 ( 0.02%) .          .          .             Instruction i = p->code[pc];  
    2,064 ( 0.01%) .          .          .             switch (GET_OPCODE(i)) {
        .          .          .          .               case OP_CALL:
        .          .          .          .               case OP_TAILCALL:
    1,204 ( 0.01%) .          .          .                 return getobjname(p, pc, GETARG_A(i), name);  
  954,922 ( 4.41%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getobjname (172x)
        .          .          .          .               case OP_TFORCALL: {  
        .          .          .          .                 *name = "for iterator";
        .          .          .          .                  return "for iterator";
        .          .          .          .               }
        .          .          .          .               
        .          .          .          .               case OP_SELF: case OP_GETTABUP: case OP_GETTABLE:
        .          .          .          .               case OP_GETI: case OP_GETFIELD:
        .          .          .          .                 tm = TM_INDEX;
-- line 5107 ----------------------------------------
-- line 5122 ----------------------------------------
        .          .          .          .               case OP_LT: case OP_LTI: case OP_GTI: tm = TM_LT; break;
        .          .          .          .               case OP_LE: case OP_LEI: case OP_GEI: tm = TM_LE; break;
        .          .          .          .               case OP_CLOSE: case OP_RETURN: tm = TM_CLOSE; break;
        .          .          .          .               default:
        .          .          .          .                 return NULL;  
        .          .          .          .             }
        .          .          .          .             *name = getstr(G(L)->tmname[tm]) + 2;
        .          .          .          .             return "metamethod";
    1,376 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static const char *funcnamefromcall (lua_State *L, CallInfo *ci,
    3,390 ( 0.02%) .          .          .                                                              const char **name) {
    3,390 ( 0.02%) .          .          .             if (ci->callstatus & CIST_HOOKED) {  
        .          .          .          .               *name = "?";
        .          .          .          .               return "hook";
        .          .          .          .             }
    2,034 ( 0.01%) .          .          .             else if (ci->callstatus & CIST_FIN) {  
        .          .          .          .               *name = "__gc";
        .          .          .          .               return "metamethod";  
        .          .          .          .             }
    2,034 ( 0.01%) .          .          .             else if (isLua(ci))
   10,320 ( 0.05%) .          .          .               return funcnamefromcode(L, ci_func(ci)->p, currentpc(ci), name);
  964,726 ( 4.45%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:funcnamefromcode (172x)
   15,824 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:currentpc (172x)
        .          .          .          .             else
      334 ( 0.00%) .          .          .               return NULL;
    2,712 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static int isinstack (CallInfo *ci, const TValue *o) {
        .          .          .          .             StkId pos;
        .          .          .          .             for (pos = ci->func + 1; pos < ci->top; pos++) {
        .          .          .          .               if (o == s2v(pos))
        .          .          .          .                 return 1;
        .          .          .          .             }
        .          .          .          .             return 0;  
-- line 5154 ----------------------------------------
-- line 5245 ----------------------------------------
        .          .          .          .             if (src)
        .          .          .          .               luaO_chunkid(buff, getstr(src), tsslen(src));
        .          .          .          .             else {  
        .          .          .          .               buff[0] = '?'; buff[1] = '\0';
        .          .          .          .             }
        .          .          .          .             return luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
        .          .          .          .           }
        .          .          .          .           
        8 ( 0.00%) .          .          .           l_noret luaG_errormsg (lua_State *L) {
       10 ( 0.00%) .          .          .             if (L->errfunc != 0) {  
       14 ( 0.00%) .          .          .               StkId errfunc = restorestack(L, L->errfunc);
       11 ( 0.00%) .          .          .               lua_assert(ttisfunction(s2v(errfunc)));
      118 ( 0.00%) .          .          .               setobjs2s(L, L->top, L->top - 1);  
       56 ( 0.00%) .          .          .               setobjs2s(L, L->top - 1, errfunc);  
       14 ( 0.00%) .          .          .               L->top++;  
       11 ( 0.00%) .          .          .               luaD_callnoyield(L, L->top - 2, 1);  
   89,226 ( 0.41%) 31 ( 5.81%) 578,926 ( 0.11%) 556,494 ( 0.11%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_callnoyield'2 (1x)
        .          .          .          .             }
        3 ( 0.00%) .          .          .             luaD_throw(L, LUA_ERRRUN);
      821 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_throw (1x)
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {
        .          .          .          .             CallInfo *ci = L->ci;
        .          .          .          .             const char *msg;
        .          .          .          .             va_list argp;
        .          .          .          .             luaC_checkGC(L);  
        .          .          .          .             va_start(argp, fmt);
-- line 5270 ----------------------------------------
-- line 5289 ----------------------------------------
        .          .          .          .                 if (pc == newpc)
        .          .          .          .                   return (delta != 0);  
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .             
        .          .          .          .             return (luaG_getfuncline(p, oldpc) != luaG_getfuncline(p, newpc));
        .          .          .          .           }
        .          .          .          .           
    2,250 ( 0.01%) .          .          .           int luaG_traceexec (lua_State *L, const Instruction *pc) {
    2,000 ( 0.01%) .          .          .             CallInfo *ci = L->ci;
    2,000 ( 0.01%) .          .          .             lu_byte mask = L->hookmask;
   13,000 ( 0.06%) .          .          .             const Proto *p = ci_func(ci)->p;
        .          .          .          .             int counthook;
      750 ( 0.00%) .          .          .             if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  
        .          .          .          .               ci->u.l.trap = 0;  
        .          .          .          .               return 0;  
        .          .          .          .             }
    1,000 ( 0.00%) .          .          .             pc++;  
    2,000 ( 0.01%) .          .          .             ci->u.l.savedpc = pc;  
    5,750 ( 0.03%) .          .          .             counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));
        .          .          .          .             if (counthook)
    2,500 ( 0.01%) .          .          .               resethookcount(L);  
        .          .          .          .             else if (!(mask & LUA_MASKLINE))
        .          .          .          .               return 1;  
    2,500 ( 0.01%) .          .          .             if (ci->callstatus & CIST_HOOKYIELD) {  
        .          .          .          .               ci->callstatus &= ~CIST_HOOKYIELD;  
        .          .          .          .               return 1;  
        .          .          .          .             }
   11,300 ( 0.05%) .          .          .             if (!isIT(*(ci->u.l.savedpc - 1)))  
    2,440 ( 0.01%) .          .          .               L->top = ci->top;  
      500 ( 0.00%) .          .          .             if (counthook)
    1,750 ( 0.01%) .          .          .               luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  
1,629,305 ( 7.52%) 250 (46.82%) 4,222,232 ( 0.80%) 4,021,124 ( 0.82%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_hook (250x)
      500 ( 0.00%) .          .          .             if (mask & LUA_MASKLINE) {
        .          .          .          .               
        .          .          .          .               int oldpc = (L->oldpc < p->sizecode) ? L->oldpc : 0;
        .          .          .          .               int npci = pcRel(pc, p);
        .          .          .          .               if (npci <= oldpc ||  
        .          .          .          .                   changedline(p, oldpc, npci)) {  
        .          .          .          .                 int newline = luaG_getfuncline(p, npci);
        .          .          .          .                 luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  
        .          .          .          .               }
        .          .          .          .               L->oldpc = npci;  
        .          .          .          .             }
    1,500 ( 0.01%) .          .          .             if (L->status == LUA_YIELD) {  
        .          .          .          .               if (counthook)
        .          .          .          .                 L->hookcount = 1;  
        .          .          .          .               ci->u.l.savedpc--;  
        .          .          .          .               ci->callstatus |= CIST_HOOKYIELD;  
        .          .          .          .               luaD_throw(L, LUA_YIELD);
        .          .          .          .             }
      500 ( 0.00%) .          .          .             return 1;  
    2,250 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           // root include ldo.c
        .          .          .          .           
        .          .          .          .           #include <setjmp.h>
        .          .          .          .           //included "stdlib.h" 
        .          .          .          .           //included "string.h" 
        .          .          .          .           
        .          .          .          .           //included "lundump.h" 
-- line 5348 ----------------------------------------
-- line 5374 ----------------------------------------
        .          .          .          .           #endif							
        .          .          .          .           
        .          .          .          .           struct lua_longjmp {
        .          .          .          .             struct lua_longjmp *previous;
        .          .          .          .             luai_jmpbuf b;
        .          .          .          .             volatile int status;  
        .          .          .          .           };
        .          .          .          .           
        7 ( 0.00%) .          .          .           void luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop) {
        6 ( 0.00%) .          .          .             switch (errcode) {
        .          .          .          .               case LUA_ERRMEM: {  
        .          .          .          .                 setsvalue2s(L, oldtop, G(L)->memerrmsg); 
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case LUA_ERRERR: {
        .          .          .          .                 setsvalue2s(L, oldtop, luaS_newliteral(L, "error in error handling"));
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case LUA_OK: {  
        .          .          .          .                 setnilvalue(s2v(oldtop));  
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: {
        2 ( 0.00%) .          .          .                 lua_assert(errorstatus(errcode));  
      120 ( 0.00%) .          .          .                 setobjs2s(L, oldtop, L->top - 1);  
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .             }
       12 ( 0.00%) .          .          .             L->top = oldtop + 1;
        6 ( 0.00%) .          .          .           }
        .          .          .          .           
        9 ( 0.00%) .          .          .           l_noret luaD_throw (lua_State *L, int errcode) {
       10 ( 0.00%) .          .          .             if (L->errorJmp) {  
       12 ( 0.00%) .          .          .               L->errorJmp->status = errcode;  
       20 ( 0.00%) .          .          .               LUAI_THROW(L, L->errorJmp);  
      703 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
       67 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/setjmp/../setjmp/longjmp.c:longjmp (1x)
        .          .          .          .             }
        .          .          .          .             else {  
        .          .          .          .               global_State *g = G(L);
        .          .          .          .               errcode = luaE_resetthread(L, errcode);  
        .          .          .          .               if (g->mainthread->errorJmp) {  
        .          .          .          .                 setobjs2s(L, g->mainthread->top++, L->top - 1);  
        .          .          .          .                 luaD_throw(g->mainthread, errcode);  
        .          .          .          .               }
-- line 5416 ----------------------------------------
-- line 5419 ----------------------------------------
        .          .          .          .                   lua_unlock(L);
        .          .          .          .                   g->panic(L);  
        .          .          .          .                 }
        .          .          .          .                 abort();
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .           }
        .          .          .          .           
       56 ( 0.00%) .          .          .           int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
       77 ( 0.00%) .          .          .             l_uint32 oldnCcalls = L->nCcalls;
        .          .          .          .             struct lua_longjmp lj;
        7 ( 0.00%) .          .          .             lj.status = LUA_OK;
       49 ( 0.00%) .          .          .             lj.previous = L->errorJmp;  
       49 ( 0.00%) .          .          .             L->errorJmp = &lj;
       69 ( 0.00%) .          .          .             LUAI_TRY(L, &lj,
14,072,164 (64.93%) 441 (82.58%) 7,762,098 ( 1.47%) 7,394,886 ( 1.51%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:f_call (2x)
3,780,822 (17.44%) 3 ( 0.56%) 65,107 ( 0.01%) 61,470 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:f_parser (1x)
   67,189 ( 0.31%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:f_luaopen (1x)
    2,715 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:closepaux (2x)
      760 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
      204 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/setjmp/../sysdeps/x86_64/bsd-_setjmp.S:_setjmp (6x)
        .          .          .          .               (*f)(L, ud);
        .          .          .          .             );
       56 ( 0.00%) .          .          .             L->errorJmp = lj.previous;  
       49 ( 0.00%) .          .          .             L->nCcalls = oldnCcalls;
        7 ( 0.00%) .          .          .             return lj.status;
       42 ( 0.00%) .          .          .           }
        .          .          .          .           
       16 ( 0.00%) .          .          .           static void correctstack (lua_State *L, StkId oldstack, StkId newstack) {
        .          .          .          .             CallInfo *ci;
        .          .          .          .             UpVal *up;
       38 ( 0.00%) .          .          .             L->top = (L->top - oldstack) + newstack;
       38 ( 0.00%) .          .          .             L->tbclist = (L->tbclist - oldstack) + newstack;
       16 ( 0.00%) .          .          .             for (up = L->openupval; up != NULL; up = up->u.open.next)
        .          .          .          .               up->v = s2v((uplevel(up) - oldstack) + newstack);
       40 ( 0.00%) .          .          .             for (ci = L->ci; ci != NULL; ci = ci->previous) {
       60 ( 0.00%) .          .          .               ci->top = (ci->top - oldstack) + newstack;
       54 ( 0.00%) .          .          .               ci->func = (ci->func - oldstack) + newstack;
       30 ( 0.00%) .          .          .               if (isLua(ci))
        6 ( 0.00%) .          .          .                 ci->u.l.trap = 1;  
        .          .          .          .             }
       12 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #define ERRORSTACKSIZE	(LUAI_MAXSTACK + 200)
        .          .          .          .           
       20 ( 0.00%) .          .          .           int luaD_reallocstack (lua_State *L, int newsize, int raiseerror) {
       36 ( 0.00%) .          .          .             int oldsize = stacksize(L);
        .          .          .          .             int i;
       20 ( 0.00%) .          .          .             StkId newstack = luaM_reallocvector(L, NULL, 0,
      790 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_realloc_ (2x)
        .          .          .          .                                                 newsize + EXTRA_STACK, StackValue);
       12 ( 0.00%) .          .          .             lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);
        4 ( 0.00%) .          .          .             if (l_unlikely(newstack == NULL)) {  
        .          .          .          .               if (raiseerror)
        .          .          .          .                 luaM_error(L);
        .          .          .          .               else return 0;  
        .          .          .          .             }
        .          .          .          .             
       14 ( 0.00%) .          .          .             i = ((oldsize <= newsize) ? oldsize : newsize) + EXTRA_STACK;
       34 ( 0.00%) .          .          .             memcpy(newstack, L->stack, i * sizeof(StackValue));
      328 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:memcpy@GLIBC_2.2.5 (2x)
      372 ( 0.00%) .          .          .             for (; i < newsize + EXTRA_STACK; i++)
      560 ( 0.00%) .          .          .               setnilvalue(s2v(newstack + i)); 
       16 ( 0.00%) .          .          .             correctstack(L, L->stack, newstack);
      310 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:correctstack (2x)
       26 ( 0.00%) .          .          .             luaM_freearray(L, L->stack, oldsize + EXTRA_STACK);
      359 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (2x)
       10 ( 0.00%) .          .          .             L->stack = newstack;
       32 ( 0.00%) .          .          .             L->stack_last = L->stack + newsize;
        2 ( 0.00%) .          .          .             return 1;
       16 ( 0.00%) .          .          .           }
        .          .          .          .           
       10 ( 0.00%) .          .          .           int luaD_growstack (lua_State *L, int n, int raiseerror) {
       18 ( 0.00%) .          .          .             int size = stacksize(L);
        2 ( 0.00%) .          .          .             if (l_unlikely(size > LUAI_MAXSTACK)) {
        .          .          .          .               
        .          .          .          .               lua_assert(stacksize(L) == ERRORSTACKSIZE);
        .          .          .          .               if (raiseerror)
        .          .          .          .                 luaD_throw(L, LUA_ERRERR);  
        .          .          .          .               return 0;  
        .          .          .          .             }
        .          .          .          .             else {
        3 ( 0.00%) .          .          .               int newsize = 2 * size;  
       15 ( 0.00%) .          .          .               int needed = cast_int(L->top - L->stack) + n;
        2 ( 0.00%) .          .          .               if (newsize > LUAI_MAXSTACK)  
        .          .          .          .                 newsize = LUAI_MAXSTACK;
        3 ( 0.00%) .          .          .               if (newsize < needed)  
        .          .          .          .                 newsize = needed;
        2 ( 0.00%) .          .          .               if (l_likely(newsize <= LUAI_MAXSTACK))
        3 ( 0.00%) .          .          .                 return luaD_reallocstack(L, newsize, raiseerror);
    2,053 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_reallocstack (1x)
        .          .          .          .               else {  
        .          .          .          .                 
        .          .          .          .                 luaD_reallocstack(L, ERRORSTACKSIZE, raiseerror);
        .          .          .          .                 if (raiseerror)
        .          .          .          .                   luaG_runerror(L, "stack overflow");
        .          .          .          .                 return 0;
        .          .          .          .               }
        .          .          .          .             }
        8 ( 0.00%) .          .          .           }
        .          .          .          .           
       36 ( 0.00%) .          .          .           static int stackinuse (lua_State *L) {
        .          .          .          .             CallInfo *ci;
        .          .          .          .             int res;
       48 ( 0.00%) .          .          .             StkId lim = L->top;
      231 ( 0.00%) .          .          .             for (ci = L->ci; ci != NULL; ci = ci->previous) {
      186 ( 0.00%) .          .          .               if (lim < ci->top) lim = ci->top;
        .          .          .          .             }
       54 ( 0.00%) .          .          .             lua_assert(lim <= L->stack_last);
       78 ( 0.00%) .          .          .             res = cast_int(lim - L->stack) + 1;  
       12 ( 0.00%) .          .          .             if (res < LUA_MINSTACK)
        .          .          .          .               res = LUA_MINSTACK;  
        .          .          .          .             return res;
       36 ( 0.00%) .          .          .           }
        .          .          .          .           
       48 ( 0.00%) .          .          .           void luaD_shrinkstack (lua_State *L) {
       12 ( 0.00%) .          .          .             int inuse = stackinuse(L);
      681 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:stackinuse (6x)
       18 ( 0.00%) .          .          .             int nsize = inuse * 2;  
       18 ( 0.00%) .          .          .             int max = inuse * 3;  
       12 ( 0.00%) .          .          .             if (max > LUAI_MAXSTACK) {
        .          .          .          .               max = LUAI_MAXSTACK;  
        .          .          .          .               if (nsize > LUAI_MAXSTACK)
        .          .          .          .                 nsize = LUAI_MAXSTACK;
        .          .          .          .             }
        .          .          .          .             
      126 ( 0.00%) .          .          .             if (inuse <= LUAI_MAXSTACK && stacksize(L) > max)
        5 ( 0.00%) .          .          .               luaD_reallocstack(L, nsize, 0);  
      908 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_reallocstack (1x)
        .          .          .          .             else  
        .          .          .          .               condmovestack(L,{},{});  
       12 ( 0.00%) .          .          .             luaE_shrinkCI(L);  
    1,202 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaE_shrinkCI (6x)
       48 ( 0.00%) .          .          .           }
        .          .          .          .           
       16 ( 0.00%) .          .          .           void luaD_inctop (lua_State *L) {
       60 ( 0.00%) .          .          .             luaD_checkstack(L, 1);
       56 ( 0.00%) .          .          .             L->top++;
       16 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaD_hook (lua_State *L, int event, int line,
    5,025 ( 0.02%) .          .          .                                         int ftransfer, int ntransfer) {
    2,680 ( 0.01%) .          .          .             lua_Hook hook = L->hook;
    2,680 ( 0.01%) .          .          .             if (hook && L->allowhook) {  
      542 ( 0.00%) .          .          .               int mask = CIST_HOOKED;
    1,675 ( 0.01%) .          .          .               CallInfo *ci = L->ci;
    3,685 ( 0.02%) .          .          .               ptrdiff_t top = savestack(L, L->top);  
    4,355 ( 0.02%) .          .          .               ptrdiff_t ci_top = savestack(L, ci->top);  
        .          .          .          .               lua_Debug ar;
      670 ( 0.00%) .          .          .               ar.event = event;
      670 ( 0.00%) .          .          .               ar.currentline = line;
      335 ( 0.00%) .          .          .               ar.i_ci = ci;
      670 ( 0.00%) .          .          .               if (ntransfer != 0) {
       64 ( 0.00%) .          .          .                 mask |= CIST_TRAN;  
      576 ( 0.00%) .          .          .                 ci->u2.transferinfo.ftransfer = ftransfer;
      576 ( 0.00%) .          .          .                 ci->u2.transferinfo.ntransfer = ntransfer;
        .          .          .          .               }
    6,525 ( 0.03%) .          .          .               if (isLua(ci) && L->top < ci->top)
      234 ( 0.00%) .          .          .                 L->top = ci->top;  
    4,025 ( 0.02%) .          .          .               luaD_checkstack(L, LUA_MINSTACK);  
    2,119 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_growstack (1x)
    5,695 ( 0.03%) .          .          .               if (ci->top < L->top + LUA_MINSTACK)
    2,583 ( 0.01%) .          .          .                 ci->top = L->top + LUA_MINSTACK;
    1,675 ( 0.01%) .          .          .               L->allowhook = 0;  
    4,355 ( 0.02%) .          .          .               ci->callstatus |= mask;
        .          .          .          .               lua_unlock(L);
    1,005 ( 0.00%) .          .          .               (*hook)(L, &ar);
2,087,748 ( 9.63%) 335 (62.73%) 6,043,395 ( 1.15%) 5,750,088 ( 1.17%)  => /home/utoecat/Github/protected_github/onlylua/test.c:myHook (335x)
        .          .          .          .               lua_lock(L);
    2,010 ( 0.01%) .          .          .               lua_assert(!L->allowhook);
    1,675 ( 0.01%) .          .          .               L->allowhook = 1;
    5,360 ( 0.02%) .          .          .               ci->top = restorestack(L, ci_top);
    5,360 ( 0.02%) .          .          .               L->top = restorestack(L, top);
    4,020 ( 0.02%) .          .          .               ci->callstatus &= ~mask;
        .          .          .          .             }
    3,685 ( 0.02%) .          .          .           }
        .          .          .          .           
       77 ( 0.00%) .          .          .           void luaD_hookcall (lua_State *L, CallInfo *ci) {
       88 ( 0.00%) .          .          .             L->oldpc = 0;  
      110 ( 0.00%) .          .          .             if (L->hookmask & LUA_MASKCALL) {  
       88 ( 0.00%) .          .          .               int event = (ci->callstatus & CIST_TAIL) ? LUA_HOOKTAILCALL
       22 ( 0.00%) .          .          .                                                        : LUA_HOOKCALL;
      572 ( 0.00%) .          .          .               Proto *p = ci_func(ci)->p;
      154 ( 0.00%) .          .          .               ci->u.l.savedpc++;  
      143 ( 0.00%) .          .          .               luaD_hook(L, event, -1, 1, p->numparams);
   97,677 ( 0.45%) 11 ( 2.06%) 194,798 ( 0.04%) 185,637 ( 0.04%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_hook (11x)
      154 ( 0.00%) .          .          .               ci->u.l.savedpc--;  
        .          .          .          .             }
       66 ( 0.00%) .          .          .           }
        .          .          .          .           
      410 ( 0.00%) .          .          .           static void rethook (lua_State *L, CallInfo *ci, int nres) {
      410 ( 0.00%) .          .          .             if (L->hookmask & LUA_MASKRET) {  
      615 ( 0.00%) .          .          .               StkId firstres = L->top - nres;  
       82 ( 0.00%) .          .          .               int delta = 0;  
        .          .          .          .               int ftransfer;
      369 ( 0.00%) .          .          .               if (isLua(ci)) {
      468 ( 0.00%) .          .          .                 Proto *p = ci_func(ci)->p;
       81 ( 0.00%) .          .          .                 if (p->is_vararg)
        .          .          .          .                   delta = ci->u.l.nextraargs + p->numparams + 1;
        .          .          .          .               }
      697 ( 0.00%) .          .          .               ci->func += delta;  
      287 ( 0.00%) .          .          .               ftransfer = cast(unsigned short, firstres - ci->func);
      205 ( 0.00%) .          .          .               luaD_hook(L, LUA_HOOKRET, -1, ftransfer, nres);  
  253,227 ( 1.17%) 41 ( 7.68%) 965,107 ( 0.18%) 912,010 ( 0.19%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_hook (41x)
      697 ( 0.00%) .          .          .               ci->func -= delta;
        .          .          .          .             }
      697 ( 0.00%) .          .          .             if (isLua(ci = ci->previous))
    2,475 ( 0.01%) .          .          .               L->oldpc = pcRel(ci->u.l.savedpc, ci_func(ci)->p);  
      328 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           StkId luaD_tryfuncTM (lua_State *L, StkId func) {
        .          .          .          .             const TValue *tm;
        .          .          .          .             StkId p;
        .          .          .          .             checkstackGCp(L, 1, func);  
        .          .          .          .             tm = luaT_gettmbyobj(L, s2v(func), TM_CALL);  
        .          .          .          .             if (l_unlikely(ttisnil(tm)))
        .          .          .          .               luaG_callerror(L, s2v(func));  
        .          .          .          .             for (p = L->top; p > func; p--)  
        .          .          .          .               setobjs2s(L, p, p-1);
        .          .          .          .             L->top++;  
        .          .          .          .             setobj2s(L, func, tm);  
        .          .          .          .             return func;
        .          .          .          .           }
        .          .          .          .           
      451 ( 0.00%) .          .          .           l_sinline void moveresults (lua_State *L, StkId res, int nres, int wanted) {
        .          .          .          .             StkId firstresult;
        .          .          .          .             int i;
      176 ( 0.00%) .          .          .             switch (wanted) {  
        .          .          .          .               case 0:  
      121 ( 0.00%) .          .          .                 L->top = res;
       11 ( 0.00%) .          .          .                 return;
        .          .          .          .               case 1:  
       42 ( 0.00%) .          .          .                 if (nres == 0)   
       16 ( 0.00%) .          .          .                   setnilvalue(s2v(res));  
        .          .          .          .                 else  
    1,924 ( 0.01%) .          .          .                   setobjs2s(L, res, L->top - nres);  
      315 ( 0.00%) .          .          .                 L->top = res + 1;
       21 ( 0.00%) .          .          .                 return;
        .          .          .          .               case LUA_MULTRET:
        .          .          .          .                 wanted = nres;  
        .          .          .          .                 break;
        .          .          .          .               default:  
        2 ( 0.00%) .          .          .                 if (hastocloseCfunc(wanted)) {  
        .          .          .          .                   ptrdiff_t savedres = savestack(L, res);
        .          .          .          .                   L->ci->callstatus |= CIST_CLSRET;  
        .          .          .          .                   L->ci->u2.nres = nres;
        .          .          .          .                   luaF_close(L, res, CLOSEKTOP, 1);
        .          .          .          .                   L->ci->callstatus &= ~CIST_CLSRET;
        .          .          .          .                   if (L->hookmask)  
        .          .          .          .                     rethook(L, L->ci, nres);
        .          .          .          .                   res = restorestack(L, savedres);  
        .          .          .          .                   wanted = decodeNresults(wanted);
        .          .          .          .                   if (wanted == LUA_MULTRET)
        .          .          .          .                     wanted = nres;  
        .          .          .          .                 }
        .          .          .          .                 break;
        .          .          .          .             }
        .          .          .          .             
      189 ( 0.00%) .          .          .             firstresult = L->top - nres;  
       36 ( 0.00%) .          .          .             if (nres > wanted)  
        .          .          .          .               nres = wanted;  
       96 ( 0.00%) .          .          .             for (i = 0; i < nres; i++)  
    1,049 ( 0.00%) .          .          .               setobjs2s(L, res + i, firstresult + i);
       18 ( 0.00%) .          .          .             for (; i < wanted; i++)  
        .          .          .          .               setnilvalue(s2v(res + i));
      126 ( 0.00%) .          .          .             L->top = res + wanted;  
      328 ( 0.00%) .          .          .           }
        .          .          .          .           
      328 ( 0.00%) .          .          .           void luaD_poscall (lua_State *L, CallInfo *ci, int nres) {
      328 ( 0.00%) .          .          .             int wanted = ci->nresults;
      656 ( 0.00%) .          .          .             if (l_unlikely(L->hookmask && !hastocloseCfunc(wanted)))
      205 ( 0.00%) .          .          .               rethook(L, ci, nres);
  261,048 ( 1.20%) 41 ( 7.68%) 965,107 ( 0.18%) 912,010 ( 0.19%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:rethook (41x)
        .          .          .          .             
      369 ( 0.00%) .          .          .             moveresults(L, ci->func, nres, wanted);
    4,921 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:moveresults (41x)
        .          .          .          .             
      369 ( 0.00%) .          .          .             lua_assert(!(ci->callstatus &
        .          .          .          .                   (CIST_HOOKED | CIST_YPCALL | CIST_FIN | CIST_TRAN | CIST_CLSRET)));
      410 ( 0.00%) .          .          .             L->ci = ci->previous;  
      246 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #define next_ci(L)  (L->ci->next ? L->ci->next : luaE_extendCI(L))
        .          .          .          .           
        .          .          .          .           l_sinline CallInfo *prepCallInfo (lua_State *L, StkId func, int nret,
      528 ( 0.00%) .          .          .                                                           int mask, StkId top) {
    1,512 ( 0.01%) .          .          .             CallInfo *ci = L->ci = next_ci(L);  
    2,453 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaE_extendCI (7x)
      264 ( 0.00%) .          .          .             ci->func = func;
      396 ( 0.00%) .          .          .             ci->nresults = nret;
      396 ( 0.00%) .          .          .             ci->callstatus = mask;
      308 ( 0.00%) .          .          .             ci->top = top;
        .          .          .          .             return ci;
      396 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           l_sinline int precallC (lua_State *L, StkId func, int nresults,
      363 ( 0.00%) .          .          .                                                       lua_CFunction f) {
        .          .          .          .             int n;  
        .          .          .          .             CallInfo *ci;
      495 ( 0.00%) .          .          .             checkstackGCp(L, LUA_MINSTACK, func);  
      495 ( 0.00%) .          .          .             L->ci = ci = prepCallInfo(L, func, nresults, CIST_C,
    3,954 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:prepCallInfo (26x)
      165 ( 0.00%) .          .          .                                          L->top + LUA_MINSTACK);
      462 ( 0.00%) .          .          .             lua_assert(ci->top <= L->stack_last);
      330 ( 0.00%) .          .          .             if (l_unlikely(L->hookmask & LUA_MASKCALL)) {
      330 ( 0.00%) .          .          .               int narg = cast_int(L->top - func) - 1;
      231 ( 0.00%) .          .          .               luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);
  167,032 ( 0.77%) 26 ( 4.87%) 443,442 ( 0.08%) 424,712 ( 0.09%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_hook (26x)
        .          .          .          .             }
        .          .          .          .             lua_unlock(L);
       98 ( 0.00%) .          .          .             n = (*f)(L);  
10,987,299 (50.70%) 9 ( 1.69%) 182,774 ( 0.03%) 173,505 ( 0.04%)  => /home/utoecat/Github/protected_github/onlylua/test.c:luaB_loadfile (1x)
  444,309 ( 2.05%) 13 ( 2.43%) 386,380 ( 0.07%) 363,695 ( 0.07%)  => /home/utoecat/Github/protected_github/onlylua/test.c:protected (1x)
  107,908 ( 0.50%) 31 ( 5.81%) 578,926 ( 0.11%) 556,494 ( 0.11%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:str_dump (1x)
  100,576 ( 0.46%) 51 ( 9.55%) 765,836 ( 0.15%) 734,577 ( 0.15%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:str_format (5x)
   25,682 ( 0.12%) 13 ( 2.43%) 218,676 ( 0.04%) 209,062 ( 0.04%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaB_print (7x)
    4,174 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaB_rawget (5x)
    2,892 ( 0.01%) 1 ( 0.19%) 5,839 ( 0.00%) 4,458 ( 0.00%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:math_randomseed (1x)
      926 ( 0.00%) 2 ( 0.37%) 9,787 ( 0.00%) 8,782 ( 0.00%)  => /home/utoecat/Github/protected_github/onlylua/test.c:osclock (2x)
      862 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaB_collectgarbage (1x)
      306 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaB_assert (2x)
        .          .          .          .             lua_lock(L);
      608 ( 0.00%) .          .          .             api_checknelems(L, n);
      128 ( 0.00%) .          .          .             luaD_poscall(L, ci, n);
  167,768 ( 0.77%) 25 ( 4.68%) 586,514 ( 0.11%) 556,999 ( 0.11%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_poscall (25x)
        .          .          .          .             return n;
      288 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           int luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func,
       24 ( 0.00%) .          .          .                                               int narg1, int delta) {
        .          .          .          .            retry:
       26 ( 0.00%) .          .          .             switch (ttypetag(s2v(func))) {
        .          .          .          .               case LUA_VCCL:  
        .          .          .          .                 return precallC(L, func, LUA_MULTRET, clCvalue(s2v(func))->f);
        .          .          .          .               case LUA_VLCF:  
       34 ( 0.00%) .          .          .                 return precallC(L, func, LUA_MULTRET, fvalue(s2v(func)));
   46,026 ( 0.21%) 22 ( 4.12%) 315,442 ( 0.06%) 306,378 ( 0.06%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:precallC (2x)
        .          .          .          .               case LUA_VLCL: {  
        .          .          .          .                 Proto *p = clLvalue(s2v(func))->p;
        .          .          .          .                 int fsize = p->maxstacksize;  
        .          .          .          .                 int nfixparams = p->numparams;
        .          .          .          .                 int i;
        .          .          .          .                 checkstackGCp(L, fsize - delta, func);
        .          .          .          .                 ci->func -= delta;  
        .          .          .          .                 for (i = 0; i < narg1; i++)  
-- line 5728 ----------------------------------------
-- line 5739 ----------------------------------------
        .          .          .          .               }
        .          .          .          .               default: {  
        .          .          .          .                 func = luaD_tryfuncTM(L, func);  
        .          .          .          .                 
        .          .          .          .                 narg1++;
        .          .          .          .                 goto retry;  
        .          .          .          .               }
        .          .          .          .             }
       16 ( 0.00%) .          .          .           }
        .          .          .          .           
      420 ( 0.00%) .          .          .           CallInfo *luaD_precall (lua_State *L, StkId func, int nresults) {
        .          .          .          .            retry:
      592 ( 0.00%) .          .          .             switch (ttypetag(s2v(func))) {
        .          .          .          .               case LUA_VCCL:  
       43 ( 0.00%) .          .          .                 precallC(L, func, nresults, clCvalue(s2v(func))->f);
   33,045 ( 0.15%) 3 ( 0.56%) 57,651 ( 0.01%) 54,218 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:precallC (1x)
        2 ( 0.00%) .          .          .                 return NULL;
        .          .          .          .               case LUA_VLCF:  
      510 ( 0.00%) .          .          .                 precallC(L, func, nresults, fvalue(s2v(func)));
11,937,756 (55.08%) 146 (27.34%) 2,805,081 ( 0.53%) 2,671,688 ( 0.55%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:precallC (23x)
       29 ( 0.00%) .          .          .                 return NULL;
        .          .          .          .               case LUA_VLCL: {  
        .          .          .          .                 CallInfo *ci;
      429 ( 0.00%) .          .          .                 Proto *p = clLvalue(s2v(func))->p;
      154 ( 0.00%) .          .          .                 int narg = cast_int(L->top - func) - 1;  
       88 ( 0.00%) .          .          .                 int nfixparams = p->numparams;
      110 ( 0.00%) .          .          .                 int fsize = p->maxstacksize;  
      220 ( 0.00%) .          .          .                 checkstackGCp(L, fsize, func);
      198 ( 0.00%) .          .          .                 L->ci = ci = prepCallInfo(L, func, nresults, 0, func + 1 + fsize);
    1,322 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:prepCallInfo (11x)
      187 ( 0.00%) .          .          .                 ci->u.l.savedpc = p->code;  
       39 ( 0.00%) .          .          .                 for (; narg < nfixparams; narg++)
       19 ( 0.00%) .          .          .                   setnilvalue(s2v(L->top++));  
      132 ( 0.00%) .          .          .                 lua_assert(ci->top <= L->stack_last);
        .          .          .          .                 return ci;
        .          .          .          .               }
        .          .          .          .               default: {  
        .          .          .          .                 func = luaD_tryfuncTM(L, func);  
        .          .          .          .                 
        .          .          .          .                 goto retry;  
        .          .          .          .               }
        .          .          .          .             }
      369 ( 0.00%) .          .          .           }
        .          .          .          .           
       81 ( 0.00%) .          .          .           l_sinline void ccall (lua_State *L, StkId func, int nResults, int inc) {
        .          .          .          .             CallInfo *ci;
      126 ( 0.00%) .          .          .             L->nCcalls += inc;
       54 ( 0.00%) .          .          .             if (l_unlikely(getCcalls(L) >= LUAI_MAXCCALLS))
        .          .          .          .               luaE_checkcstack(L);
       63 ( 0.00%) .          .          .             if ((ci = luaD_precall(L, func, nResults)) != NULL) {  
  451,237 ( 2.08%) 15 ( 2.81%) 449,541 ( 0.09%) 423,427 ( 0.09%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_precall (2x)
        7 ( 0.00%) .          .          .               ci->callstatus = CIST_FRESH;  
        3 ( 0.00%) .          .          .               luaV_execute(L, ci);  
13,620,784 (62.85%) 426 (79.78%) 7,312,557 ( 1.39%) 6,971,459 ( 1.42%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_execute (1x)
        .          .          .          .             }
       88 ( 0.00%) .          .          .             L->nCcalls -= inc;
       48 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaD_call (lua_State *L, StkId func, int nResults) {
        .          .          .          .             ccall(L, func, nResults, 1);
        .          .          .          .           }
        .          .          .          .           
        9 ( 0.00%) .          .          .           void luaD_callnoyield (lua_State *L, StkId func, int nResults) {
       18 ( 0.00%) .          .          .             ccall(L, func, nResults, nyci);
14,072,120 (64.93%) 441 (82.58%) 7,762,098 ( 1.47%) 7,394,886 ( 1.51%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:ccall (2x)
       16 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static int finishpcallk (lua_State *L,  CallInfo *ci) {
        .          .          .          .             int status = getcistrecst(ci);  
        .          .          .          .             if (l_likely(status == LUA_OK))  
        .          .          .          .               status = LUA_YIELD;  
        .          .          .          .             else {  
        .          .          .          .               StkId func = restorestack(L, ci->u2.funcidx);
        .          .          .          .               L->allowhook = getoah(ci->callstatus);  
-- line 5806 ----------------------------------------
-- line 5972 ----------------------------------------
        .          .          .          .             return 0;  
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           struct CloseP {
        .          .          .          .             StkId level;
        .          .          .          .             int status;
        .          .          .          .           };
        .          .          .          .           
       10 ( 0.00%) .          .          .           static void closepaux (lua_State *L, void *ud) {
        .          .          .          .             struct CloseP *pcl = cast(struct CloseP *, ud);
       24 ( 0.00%) .          .          .             luaF_close(L, pcl->level, pcl->status, 0);
    2,673 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_close (2x)
        8 ( 0.00%) .          .          .           }
        .          .          .          .           
       26 ( 0.00%) .          .          .           int luaD_closeprotected (lua_State *L, ptrdiff_t level, int status) {
       16 ( 0.00%) .          .          .             CallInfo *old_ci = L->ci;
       10 ( 0.00%) .          .          .             lu_byte old_allowhooks = L->allowhook;
        .          .          .          .             for (;;) {  
        .          .          .          .               struct CloseP pcl;
       32 ( 0.00%) .          .          .               pcl.level = restorestack(L, level); pcl.status = status;
       10 ( 0.00%) .          .          .               status = luaD_rawrunprotected(L, &closepaux, &pcl);
    2,913 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_rawrunprotected (2x)
        4 ( 0.00%) .          .          .               if (l_likely(status == LUA_OK))  
        2 ( 0.00%) .          .          .                 return pcl.status;
        .          .          .          .               else {  
        .          .          .          .                 L->ci = old_ci;
        .          .          .          .                 L->allowhook = old_allowhooks;
        .          .          .          .               }
        .          .          .          .             }
       22 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           int luaD_pcall (lua_State *L, Pfunc func, void *u,
       48 ( 0.00%) .          .          .                           ptrdiff_t old_top, ptrdiff_t ef) {
        .          .          .          .             int status;
       32 ( 0.00%) .          .          .             CallInfo *old_ci = L->ci;
       20 ( 0.00%) .          .          .             lu_byte old_allowhooks = L->allowhook;
       32 ( 0.00%) .          .          .             ptrdiff_t old_errfunc = L->errfunc;
       20 ( 0.00%) .          .          .             L->errfunc = ef;
       20 ( 0.00%) .          .          .             status = luaD_rawrunprotected(L, func, u);
17,853,285 (82.37%) 444 (83.15%) 7,827,205 ( 1.48%) 7,456,356 ( 1.52%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_rawrunprotected (3x)
        8 ( 0.00%) .          .          .             if (l_unlikely(status != LUA_OK)) {  
        5 ( 0.00%) .          .          .               L->ci = old_ci;
        5 ( 0.00%) .          .          .               L->allowhook = old_allowhooks;
        5 ( 0.00%) .          .          .               status = luaD_closeprotected(L, old_top, status);
    2,784 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_closeprotected (1x)
       16 ( 0.00%) .          .          .               luaD_seterrorobj(L, status, restorestack(L, old_top));
      153 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_seterrorobj (1x)
        3 ( 0.00%) .          .          .               luaD_shrinkstack(L);   
    1,480 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_shrinkstack (1x)
        .          .          .          .             }
       20 ( 0.00%) .          .          .             L->errfunc = old_errfunc;
        .          .          .          .             return status;
       36 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           struct SParser {  
        .          .          .          .             ZIO *z;
        .          .          .          .             Mbuffer buff;  
        .          .          .          .             Dyndata dyd;  
        .          .          .          .             const char *mode;
        .          .          .          .             const char *name;
        .          .          .          .           };
        .          .          .          .           
        6 ( 0.00%) .          .          .           static void checkmode (lua_State *L, const char *mode, const char *x) {
       12 ( 0.00%) .          .          .             if (mode && strchr(mode, x[0]) == NULL) {
       24 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strchr-sse2.S:__strchr_sse2 (1x)
        .          .          .          .               luaO_pushfstring(L,
        .          .          .          .                  "attempt to load a %s chunk (mode is '%s')", x, mode);
        1 ( 0.00%) .          .          .               luaD_throw(L, LUA_ERRSYNTAX);
        .          .          .          .             }
        4 ( 0.00%) .          .          .           }
        .          .          .          .           
       14 ( 0.00%) .          .          .           static void f_parser (lua_State *L, void *ud) {
        .          .          .          .             LClosure *cl;
        .          .          .          .             struct SParser *p = cast(struct SParser *, ud);
       52 ( 0.00%) .          .          .             int c = zgetc(p->z);  
      218 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaZ_fill (2x)
        4 ( 0.00%) .          .          .             if (c == LUA_SIGNATURE[0]) {
        .          .          .          .               checkmode(L, p->mode, "binary");
        .          .          .          .               cl = luaU_undump(L, p->z, p->name);
        .          .          .          .             }
        .          .          .          .             else {
       22 ( 0.00%) .          .          .               checkmode(L, p->mode, "text");
       47 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checkmode (2x)
       30 ( 0.00%) .          .          .               cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);
14,760,588 (68.11%) 8 ( 1.50%) 156,491 ( 0.03%) 146,870 ( 0.03%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaY_parser (2x)
        .          .          .          .             }
       54 ( 0.00%) .          .          .             lua_assert(cl->nupvalues == cl->p->sizeupvalues);
        6 ( 0.00%) .          .          .             luaF_initupvals(L, cl);
    1,100 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_initupvals (2x)
       12 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           int luaD_protectedparser (lua_State *L, ZIO *z, const char *name,
       26 ( 0.00%) .          .          .                                                   const char *mode) {
        .          .          .          .             struct SParser p;
        .          .          .          .             int status;
       28 ( 0.00%) .          .          .             incnny(L);  
        6 ( 0.00%) .          .          .             p.z = z; p.name = name; p.mode = mode;
        4 ( 0.00%) .          .          .             p.dyd.actvar.arr = NULL; p.dyd.actvar.size = 0;
        4 ( 0.00%) .          .          .             p.dyd.gt.arr = NULL; p.dyd.gt.size = 0;
        4 ( 0.00%) .          .          .             p.dyd.label.arr = NULL; p.dyd.label.size = 0;
        4 ( 0.00%) .          .          .             luaZ_initbuffer(L, &p.buff);
       44 ( 0.00%) .          .          .             status = luaD_pcall(L, f_parser, &p, savestack(L, L->top), L->errfunc);
10,981,483 (50.67%) 5 ( 0.94%) 91,384 ( 0.02%) 85,400 ( 0.02%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_pcall'2 (1x)
3,780,980 (17.45%) 3 ( 0.56%) 65,107 ( 0.01%) 61,470 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_pcall (1x)
       14 ( 0.00%) .          .          .             luaZ_freebuffer(L, &p.buff);
      430 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_saferealloc_ (2x)
       12 ( 0.00%) .          .          .             luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);
      391 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (2x)
       12 ( 0.00%) .          .          .             luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);
      146 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (2x)
       12 ( 0.00%) .          .          .             luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);
      316 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (2x)
       22 ( 0.00%) .          .          .             decnny(L);
        .          .          .          .             return status;
       22 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           // root include ldump.c
        .          .          .          .           
        .          .          .          .           //included "stddef.h" 
        .          .          .          .           
        .          .          .          .           typedef struct {
        .          .          .          .             lua_State *L;
        .          .          .          .             lua_Writer writer;
-- line 6077 ----------------------------------------
-- line 6251 ----------------------------------------
        .          .          .          .             dumpFunction(&D, f, NULL);
        .          .          .          .             return D.status;
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           // root include lfunc.c
        .          .          .          .           
        .          .          .          .           //included "stddef.h" 
        .          .          .          .           
       14 ( 0.00%) .          .          .           CClosure *luaF_newCclosure (lua_State *L, int nupvals) {
       20 ( 0.00%) .          .          .             GCObject *o = luaC_newobj(L, LUA_VCCL, sizeCclosure(nupvals));
      694 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_newobj (2x)
       26 ( 0.00%) .          .          .             CClosure *c = gco2ccl(o);
       16 ( 0.00%) .          .          .             c->nupvalues = cast_byte(nupvals);
        .          .          .          .             return c;
       14 ( 0.00%) .          .          .           }
        .          .          .          .           
      140 ( 0.00%) .          .          .           LClosure *luaF_newLclosure (lua_State *L, int nupvals) {
      200 ( 0.00%) .          .          .             GCObject *o = luaC_newobj(L, LUA_VLCL, sizeLclosure(nupvals));
    6,910 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_newobj (20x)
      260 ( 0.00%) .          .          .             LClosure *c = gco2lcl(o);
      160 ( 0.00%) .          .          .             c->p = NULL;
      120 ( 0.00%) .          .          .             c->nupvalues = cast_byte(nupvals);
      576 ( 0.00%) .          .          .             while (nupvals--) c->upvals[nupvals] = NULL;
        .          .          .          .             return c;
      140 ( 0.00%) .          .          .           }
        .          .          .          .           
       14 ( 0.00%) .          .          .           void luaF_initupvals (lua_State *L, LClosure *cl) {
        .          .          .          .             int i;
       52 ( 0.00%) .          .          .             for (i = 0; i < cl->nupvalues; i++) {
       10 ( 0.00%) .          .          .               GCObject *o = luaC_newobj(L, LUA_VUPVAL, sizeof(UpVal));
      898 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_newobj (2x)
       26 ( 0.00%) .          .          .               UpVal *uv = gco2upv(o);
       26 ( 0.00%) .          .          .               uv->v = &uv->u.value;  
       24 ( 0.00%) .          .          .               setnilvalue(uv->v);
       26 ( 0.00%) .          .          .               cl->upvals[i] = uv;
       12 ( 0.00%) .          .          .               luaC_objbarrier(L, cl, uv);
        .          .          .          .             }
       12 ( 0.00%) .          .          .           }
        .          .          .          .           
      143 ( 0.00%) .          .          .           static UpVal *newupval (lua_State *L, int tbc, StkId level, UpVal **prev) {
       52 ( 0.00%) .          .          .             GCObject *o = luaC_newobj(L, LUA_VUPVAL, sizeof(UpVal));
    4,484 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_newobj (13x)
      169 ( 0.00%) .          .          .             UpVal *uv = gco2upv(o);
       65 ( 0.00%) .          .          .             UpVal *next = *prev;
      156 ( 0.00%) .          .          .             uv->v = s2v(level);  
       65 ( 0.00%) .          .          .             uv->tbc = tbc;
      117 ( 0.00%) .          .          .             uv->u.open.next = next;  
      104 ( 0.00%) .          .          .             uv->u.open.previous = prev;
       26 ( 0.00%) .          .          .             if (next)
      144 ( 0.00%) .          .          .               next->u.open.previous = &uv->u.open.next;
       65 ( 0.00%) .          .          .             *prev = uv;
      117 ( 0.00%) .          .          .             if (!isintwups(L)) {  
       18 ( 0.00%) .          .          .               L->twups = G(L)->twups;  
        9 ( 0.00%) .          .          .               G(L)->twups = L;
        .          .          .          .             }
        1 ( 0.00%) .          .          .             return uv;
      117 ( 0.00%) .          .          .           }
        .          .          .          .           
      144 ( 0.00%) .          .          .           UpVal *luaF_findupval (lua_State *L, StkId level) {
      128 ( 0.00%) .          .          .             UpVal **pp = &L->openupval;
        .          .          .          .             UpVal *p;
      150 ( 0.00%) .          .          .             lua_assert(isintwups(L) || L->openupval == NULL);
    1,402 ( 0.01%) .          .          .             while ((p = *pp) != NULL && uplevel(p) >= level) {  
      638 ( 0.00%) .          .          .               lua_assert(!isdead(G(L), p));
      493 ( 0.00%) .          .          .               if (uplevel(p) == level)  
        .          .          .          .                 return p;  
      156 ( 0.00%) .          .          .               pp = &p->u.open.next;
        .          .          .          .             }
        .          .          .          .             
       78 ( 0.00%) .          .          .             return newupval(L, 0, level, pp);
    5,852 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:newupval (13x)
      144 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void callclosemethod (lua_State *L, TValue *obj, TValue *err, int yy) {
        .          .          .          .             StkId top = L->top;
        .          .          .          .             const TValue *tm = luaT_gettmbyobj(L, obj, TM_CLOSE);
        .          .          .          .             setobj2s(L, top, tm);  
        .          .          .          .             setobj2s(L, top + 1, obj);  
        .          .          .          .             setobj2s(L, top + 2, err);  
        .          .          .          .             L->top = top + 3;  
-- line 6325 ----------------------------------------
-- line 6361 ----------------------------------------
        .          .          .          .             while (cast_uint(level - L->tbclist) > MAXDELTA) {
        .          .          .          .               L->tbclist += MAXDELTA;  
        .          .          .          .               L->tbclist->tbclist.delta = 0;
        .          .          .          .             }
        .          .          .          .             level->tbclist.delta = cast(unsigned short, level - L->tbclist);
        .          .          .          .             L->tbclist = level;
        .          .          .          .           }
        .          .          .          .           
       52 ( 0.00%) .          .          .           void luaF_unlinkupval (UpVal *uv) {
      234 ( 0.00%) .          .          .             lua_assert(upisopen(uv));
      234 ( 0.00%) .          .          .             *uv->u.open.previous = uv->u.open.next;
       91 ( 0.00%) .          .          .             if (uv->u.open.next)
      204 ( 0.00%) .          .          .               uv->u.open.next->u.open.previous = uv->u.open.previous;
       52 ( 0.00%) .          .          .           }
        .          .          .          .           
       27 ( 0.00%) .          .          .           void luaF_closeupval (lua_State *L, StkId level) {
        .          .          .          .             UpVal *uv;
        .          .          .          .             StkId upl;  
      485 ( 0.00%) .          .          .             while ((uv = L->openupval) != NULL && (upl = uplevel(uv)) >= level) {
       52 ( 0.00%) .          .          .               TValue *slot = &uv->u.value;  
      234 ( 0.00%) .          .          .               lua_assert(uplevel(uv) < L->top);
       26 ( 0.00%) .          .          .               luaF_unlinkupval(uv);  
      867 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_unlinkupval (13x)
      951 ( 0.00%) .          .          .               setobj(L, slot, uv->v);  
       65 ( 0.00%) .          .          .               uv->v = slot;  
       91 ( 0.00%) .          .          .               if (!iswhite(uv)) {  
        .          .          .          .                 nw2black(uv);  
        .          .          .          .                 luaC_barrier(L, uv, slot);
        .          .          .          .               }
        .          .          .          .             }
       24 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void poptbclist (lua_State *L) {
        .          .          .          .             StkId tbc = L->tbclist;
        .          .          .          .             lua_assert(tbc->tbclist.delta > 0);  
        .          .          .          .             tbc -= tbc->tbclist.delta;
        .          .          .          .             while (tbc > L->stack && tbc->tbclist.delta == 0)
        .          .          .          .               tbc -= MAXDELTA;  
        .          .          .          .             L->tbclist = tbc;
        .          .          .          .           }
        .          .          .          .           
       33 ( 0.00%) .          .          .           void luaF_close (lua_State *L, StkId level, int status, int yy) {
       27 ( 0.00%) .          .          .             ptrdiff_t levelrel = savestack(L, level);
        9 ( 0.00%) .          .          .             luaF_closeupval(L, level);  
    2,822 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_closeupval (3x)
       33 ( 0.00%) .          .          .             while (L->tbclist >= level) {  
        .          .          .          .               StkId tbc = L->tbclist;  
        .          .          .          .               poptbclist(L);  
        .          .          .          .               prepcallclosemth(L, tbc, status, yy);  
        .          .          .          .               level = restorestack(L, levelrel);
        .          .          .          .             }
       24 ( 0.00%) .          .          .           }
        .          .          .          .           
       57 ( 0.00%) .          .          .           Proto *luaF_newproto (lua_State *L) {
      228 ( 0.00%) .          .          .             GCObject *o = luaC_newobj(L, LUA_VPROTO, sizeof(Proto));
   17,302 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_newobj (57x)
      741 ( 0.00%) .          .          .             Proto *f = gco2p(o);
      456 ( 0.00%) .          .          .             f->k = NULL;
      285 ( 0.00%) .          .          .             f->sizek = 0;
      456 ( 0.00%) .          .          .             f->p = NULL;
      285 ( 0.00%) .          .          .             f->sizep = 0;
      285 ( 0.00%) .          .          .             f->code = NULL;
      285 ( 0.00%) .          .          .             f->sizecode = 0;
      456 ( 0.00%) .          .          .             f->lineinfo = NULL;
      285 ( 0.00%) .          .          .             f->sizelineinfo = 0;
      456 ( 0.00%) .          .          .             f->abslineinfo = NULL;
      285 ( 0.00%) .          .          .             f->sizeabslineinfo = 0;
      285 ( 0.00%) .          .          .             f->upvalues = NULL;
      285 ( 0.00%) .          .          .             f->sizeupvalues = 0;
      285 ( 0.00%) .          .          .             f->numparams = 0;
      285 ( 0.00%) .          .          .             f->is_vararg = 0;
      285 ( 0.00%) .          .          .             f->maxstacksize = 0;
      456 ( 0.00%) .          .          .             f->locvars = NULL;
      285 ( 0.00%) .          .          .             f->sizelocvars = 0;
      285 ( 0.00%) .          .          .             f->linedefined = 0;
      285 ( 0.00%) .          .          .             f->lastlinedefined = 0;
      456 ( 0.00%) .          .          .             f->source = NULL;
        .          .          .          .             return f;
      171 ( 0.00%) .          .          .           }
        .          .          .          .           
      285 ( 0.00%) .          .          .           void luaF_freeproto (lua_State *L, Proto *f) {
    1,140 ( 0.01%) .          .          .             luaM_freearray(L, f->code, f->sizecode);
   10,626 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (57x)
      969 ( 0.00%) .          .          .             luaM_freearray(L, f->p, f->sizep);
    5,169 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (57x)
      798 ( 0.00%) .          .          .             luaM_freearray(L, f->k, f->sizek);
    8,077 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (57x)
      912 ( 0.00%) .          .          .             luaM_freearray(L, f->lineinfo, f->sizelineinfo);
   10,254 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (57x)
      969 ( 0.00%) .          .          .             luaM_freearray(L, f->abslineinfo, f->sizeabslineinfo);
    4,400 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (57x)
      969 ( 0.00%) .          .          .             luaM_freearray(L, f->locvars, f->sizelocvars);
   22,158 ( 0.10%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (57x)
      798 ( 0.00%) .          .          .             luaM_freearray(L, f->upvalues, f->sizeupvalues);
    8,910 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (57x)
      228 ( 0.00%) .          .          .             luaM_free(L, f);
   11,776 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (57x)
      228 ( 0.00%) .          .          .           }
        .          .          .          .           
    2,450 ( 0.01%) .          .          .           const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
        .          .          .          .             int i;
  107,734 ( 0.50%) .          .          .             for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {
   49,914 ( 0.23%) .          .          .               if (pc < f->locvars[i].endpc) {  
   14,910 ( 0.07%) .          .          .                 local_number--;
    4,970 ( 0.02%) .          .          .                 if (local_number == 0)
    1,334 ( 0.01%) .          .          .                   return getstr(f->locvars[i].varname);
        .          .          .          .               }
        .          .          .          .             }
      320 ( 0.00%) .          .          .             return NULL;  
    1,960 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           // root include lgc.c
        .          .          .          .           
        .          .          .          .           #include <stdio.h>
        .          .          .          .           //included "string.h" 
        .          .          .          .           
        .          .          .          .           #define GCSWEEPMAX	100
        .          .          .          .           
-- line 6467 ----------------------------------------
-- line 6498 ----------------------------------------
        .          .          .          .           #define markobjectN(g,t)	{ if (t) markobject(g,t); }
        .          .          .          .           
        .          .          .          .           static void reallymarkobject (global_State *g, GCObject *o);
        .          .          .          .           static lu_mem atomic (lua_State *L);
        .          .          .          .           static void entersweep (lua_State *L);
        .          .          .          .           
        .          .          .          .           #define gnodelast(h)	gnode(h, cast_sizet(sizenode(h)))
        .          .          .          .           
    1,588 ( 0.01%) .          .          .           static GCObject **getgclist (GCObject *o) {
    6,352 ( 0.03%) .          .          .             switch (o->tt) {
    1,980 ( 0.01%) .          .          .               case LUA_VTABLE: return &gco2t(o)->gclist;
    1,406 ( 0.01%) .          .          .               case LUA_VLCL: return &gco2lcl(o)->gclist;
      228 ( 0.00%) .          .          .               case LUA_VCCL: return &gco2ccl(o)->gclist;
      285 ( 0.00%) .          .          .               case LUA_VTHREAD: return &gco2th(o)->gclist;
    3,534 ( 0.02%) .          .          .               case LUA_VPROTO: return &gco2p(o)->gclist;
        .          .          .          .               case LUA_VUSERDATA: {
        .          .          .          .                 Udata *u = gco2u(o);
        .          .          .          .                 lua_assert(u->nuvalue > 0);
        .          .          .          .                 return &u->gclist;
        .          .          .          .               }
        .          .          .          .               default: luai_unreachable(); return 0;
        .          .          .          .             }
    1,588 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #define linkgclist(o,p)	linkgclist_(obj2gco(o), &(o)->gclist, &(p))
        .          .          .          .           
    1,608 ( 0.01%) .          .          .           static void linkgclist_ (GCObject *o, GCObject **pnext, GCObject **list) {
    1,809 ( 0.01%) .          .          .             lua_assert(!isgray(o));  
    2,010 ( 0.01%) .          .          .             *pnext = *list;
    1,005 ( 0.00%) .          .          .             *list = o;
    2,211 ( 0.01%) .          .          .             set2gray(o);  
    1,206 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #define linkobjgclist(o,p) linkgclist_(obj2gco(o), getgclist(o), &(p))
        .          .          .          .           
      478 ( 0.00%) .          .          .           static void clearkey (Node *n) {
    2,151 ( 0.01%) .          .          .             lua_assert(isempty(gval(n)));
    2,151 ( 0.01%) .          .          .             if (keyiscollectable(n))
        .          .          .          .               setdeadkey(n);  
      478 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static int iscleared (global_State *g, const GCObject *o) {
        .          .          .          .             if (o == NULL) return 0;  
        .          .          .          .             else if (novariant(o->tt) == LUA_TSTRING) {
        .          .          .          .               markobject(g, o);  
        .          .          .          .               return 0;
        .          .          .          .             }
        .          .          .          .             else return iswhite(o);
-- line 6545 ----------------------------------------
-- line 6569 ----------------------------------------
        .          .          .          .             if (getage(o) == G_TOUCHED2)  
        .          .          .          .               set2gray(o);  
        .          .          .          .             else  
        .          .          .          .               linkobjgclist(o, g->grayagain);
        .          .          .          .             if (isold(o))  
        .          .          .          .               setage(o, G_TOUCHED1);  
        .          .          .          .           }
        .          .          .          .           
      343 ( 0.00%) .          .          .           void luaC_fix (lua_State *L, GCObject *o) {
      392 ( 0.00%) .          .          .             global_State *g = G(L);
      441 ( 0.00%) .          .          .             lua_assert(g->allgc == o);  
      735 ( 0.00%) .          .          .             set2gray(o);  
      539 ( 0.00%) .          .          .             setage(o, G_OLD);  
      490 ( 0.00%) .          .          .             g->allgc = o->next;  
      637 ( 0.00%) .          .          .             o->next = g->fixedgc;  
      245 ( 0.00%) .          .          .             g->fixedgc = o;
      294 ( 0.00%) .          .          .           }
        .          .          .          .           
    4,136 ( 0.02%) .          .          .           GCObject *luaC_newobj (lua_State *L, int tt, size_t sz) {
    4,136 ( 0.02%) .          .          .             global_State *g = G(L);
    3,102 ( 0.01%) .          .          .             GCObject *o = cast(GCObject *, luaM_newobject(L, novariant(tt), sz));
  139,682 ( 0.64%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_malloc_ (517x)
    8,789 ( 0.04%) .          .          .             o->marked = luaC_white(g);
    2,585 ( 0.01%) .          .          .             o->tt = tt;
    6,721 ( 0.03%) .          .          .             o->next = g->allgc;
    2,585 ( 0.01%) .          .          .             g->allgc = o;
        .          .          .          .             return o;
    3,619 ( 0.02%) .          .          .           }
        .          .          .          .           
    9,333 ( 0.04%) .          .          .           static void reallymarkobject (global_State *g, GCObject *o) {
   16,592 ( 0.08%) .          .          .             switch (o->tt) {
        .          .          .          .               case LUA_VSHRSTR:
        .          .          .          .               case LUA_VLNGSTR: {
   12,135 ( 0.06%) .          .          .                 set2black(o);  
      809 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case LUA_VUPVAL: {
      280 ( 0.00%) .          .          .                 UpVal *uv = gco2upv(o);
      504 ( 0.00%) .          .          .                 if (upisopen(uv))
      264 ( 0.00%) .          .          .                   set2gray(uv);  
        .          .          .          .                 else
       52 ( 0.00%) .          .          .                   set2black(uv);  
    2,472 ( 0.01%) .          .          .                 markvalue(g, uv->v);  
      894 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject'2 (6x)
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case LUA_VUSERDATA: {
       40 ( 0.00%) .          .          .                 Udata *u = gco2u(o);
       36 ( 0.00%) .          .          .                 if (u->nuvalue == 0) {  
       40 ( 0.00%) .          .          .                   markobjectN(g, u->metatable);  
       48 ( 0.00%) .          .          .                   set2black(u);  
        4 ( 0.00%) .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 
        .          .          .          .           			goto ft_udata;
        .          .          .          .               }  
        .          .          .          .               case LUA_VLCL: case LUA_VCCL: case LUA_VTABLE:
        .          .          .          .           		case LUA_VTHREAD: case LUA_VPROTO: 
        .          .          .          .           		ft_udata: {
    4,900 ( 0.02%) .          .          .                 linkobjgclist(o, g->gray);  
    9,310 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:linkgclist_ (190x)
    8,121 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getgclist (190x)
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: luai_unreachable(); break;
        .          .          .          .             }
    8,296 ( 0.04%) .          .          .           }
        .          .          .          .           
       60 ( 0.00%) .          .          .           static void markmt (global_State *g) {
        .          .          .          .             int i;
      580 ( 0.00%) .          .          .             for (i=0; i < LUA_NUMTAGS; i++)
    1,928 ( 0.01%) .          .          .               markobjectN(g, g->mt[i]);
      596 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject (4x)
       60 ( 0.00%) .          .          .           }
        .          .          .          .           
       40 ( 0.00%) .          .          .           static lu_mem markbeingfnz (global_State *g) {
        .          .          .          .             GCObject *o;
       10 ( 0.00%) .          .          .             lu_mem count = 0;
      110 ( 0.00%) .          .          .             for (o = g->tobefnz; o != NULL; o = o->next) {
        .          .          .          .               count++;
        .          .          .          .               markobject(g, o);
        .          .          .          .             }
        .          .          .          .             return count;
       50 ( 0.00%) .          .          .           }
        .          .          .          .           
       40 ( 0.00%) .          .          .           static int remarkupvals (global_State *g) {
        .          .          .          .             lua_State *thread;
       45 ( 0.00%) .          .          .             lua_State **p = &g->twups;
        5 ( 0.00%) .          .          .             int work = 0;  
       75 ( 0.00%) .          .          .             while ((thread = *p) != NULL) {
        8 ( 0.00%) .          .          .               work++;
       38 ( 0.00%) .          .          .               if (!iswhite(thread) && thread->openupval != NULL)
       18 ( 0.00%) .          .          .                 p = &thread->twups;  
        .          .          .          .               else {  
        .          .          .          .                 UpVal *uv;
        .          .          .          .                 lua_assert(!isold(thread) || thread->openupval == NULL);
        .          .          .          .                 *p = thread->twups;  
        .          .          .          .                 thread->twups = thread;  
        .          .          .          .                 for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {
        .          .          .          .                   lua_assert(getage(uv) <= getage(thread));
        .          .          .          .                   work++;
-- line 6664 ----------------------------------------
-- line 6665 ----------------------------------------
        .          .          .          .                   if (!iswhite(uv)) {  
        .          .          .          .                     lua_assert(upisopen(uv) && isgray(uv));
        .          .          .          .                     markvalue(g, uv->v);  
        .          .          .          .                   }
        .          .          .          .                 }
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .             return work;
       45 ( 0.00%) .          .          .           }
        .          .          .          .           
       10 ( 0.00%) .          .          .           static void cleargraylists (global_State *g) {
       85 ( 0.00%) .          .          .             g->gray = g->grayagain = NULL;
      145 ( 0.00%) .          .          .             g->weak = g->allweak = g->ephemeron = NULL;
       10 ( 0.00%) .          .          .           }
        .          .          .          .           
       30 ( 0.00%) .          .          .           static void restartcollection (global_State *g) {
        5 ( 0.00%) .          .          .             cleargraylists(g);
      250 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:cleargraylists (5x)
      190 ( 0.00%) .          .          .             markobject(g, g->mainthread);
      750 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject (5x)
      565 ( 0.00%) .          .          .             markvalue(g, &g->l_registry);
      745 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject (5x)
       10 ( 0.00%) .          .          .             markmt(g);
    1,984 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:markmt (5x)
       10 ( 0.00%) .          .          .             markbeingfnz(g);  
      105 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:markbeingfnz (5x)
       30 ( 0.00%) .          .          .           }
        .          .          .          .           
      385 ( 0.00%) .          .          .           static void genlink (global_State *g, GCObject *o) {
      550 ( 0.00%) .          .          .             lua_assert(isblack(o));
      440 ( 0.00%) .          .          .             if (getage(o) == G_TOUCHED1) {  
        .          .          .          .               linkobjgclist(o, g->grayagain);  
        .          .          .          .             }  
      330 ( 0.00%) .          .          .             else if (getage(o) == G_TOUCHED2)
        .          .          .          .               changeage(o, G_TOUCHED2, G_OLD);  
      330 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void traverseweakvalue (global_State *g, Table *h) {
        .          .          .          .             Node *n, *limit = gnodelast(h);
        .          .          .          .             
        .          .          .          .             int hasclears = (h->alimit > 0);
        .          .          .          .             for (n = gnode(h, 0); n < limit; n++) {  
        .          .          .          .               if (isempty(gval(n)))  
        .          .          .          .                 clearkey(n);  
-- line 6703 ----------------------------------------
-- line 6750 ----------------------------------------
        .          .          .          .               linkgclist(h, g->ephemeron);  
        .          .          .          .             else if (hasclears)  
        .          .          .          .               linkgclist(h, g->allweak);  
        .          .          .          .             else
        .          .          .          .               genlink(g, obj2gco(h));  
        .          .          .          .             return marked;
        .          .          .          .           }
        .          .          .          .           
      495 ( 0.00%) .          .          .           static void traversestrongtable (global_State *g, Table *h) {
    2,035 ( 0.01%) .          .          .             Node *n, *limit = gnodelast(h);
        .          .          .          .             unsigned int i;
      165 ( 0.00%) .          .          .             unsigned int asize = luaH_realasize(h);
    1,650 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_realasize (55x)
      331 ( 0.00%) .          .          .             for (i = 0; i < asize; i++)  
    2,084 ( 0.01%) .          .          .               markvalue(g, &h->array[i]);
      745 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject (5x)
    7,460 ( 0.03%) .          .          .             for (n = gnode(h, 0); n < limit; n++) {  
    9,950 ( 0.05%) .          .          .               if (isempty(gval(n)))  
      478 ( 0.00%) .          .          .                 clearkey(n);  
    5,258 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:clearkey (239x)
        .          .          .          .               else {
    8,316 ( 0.04%) .          .          .                 lua_assert(!keyisnil(n));
   23,607 ( 0.11%) .          .          .                 markkey(g, n);
   27,881 ( 0.13%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject (569x)
   32,676 ( 0.15%) .          .          .                 markvalue(g, gval(n));
    8,713 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject (63x)
        .          .          .          .               }
        .          .          .          .             }
      715 ( 0.00%) .          .          .             genlink(g, obj2gco(h));
    2,035 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:genlink (55x)
      440 ( 0.00%) .          .          .           }
        .          .          .          .           
      385 ( 0.00%) .          .          .           static lu_mem traversetable (global_State *g, Table *h) {
        .          .          .          .             const char *weakkey, *weakvalue;
      550 ( 0.00%) .          .          .             const TValue *mode = gfasttm(g, h->metatable, TM_MODE);
      385 ( 0.00%) .          .          .             markobjectN(g, h->metatable);
      110 ( 0.00%) .          .          .             if (mode && ttisstring(mode) &&  
        .          .          .          .                 (cast_void(weakkey = strchr(svalue(mode), 'k')),
        .          .          .          .                  cast_void(weakvalue = strchr(svalue(mode), 'v')),
        .          .          .          .                  (weakkey || weakvalue))) {  
        .          .          .          .               if (!weakkey)  
        .          .          .          .                 traverseweakvalue(g, h);
        .          .          .          .               else if (!weakvalue)  
        .          .          .          .                 traverseephemeron(g, h, 0);
        .          .          .          .               else  
        .          .          .          .                 linkgclist(h, g->allweak);  
        .          .          .          .             }
        .          .          .          .             else  
      165 ( 0.00%) .          .          .               traversestrongtable(g, h);
  135,034 ( 0.62%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:traversestrongtable (55x)
    1,490 ( 0.01%) .          .          .             return 1 + h->alimit + 2 * allocsizenode(h);
      330 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static int traverseudata (global_State *g, Udata *u) {
        .          .          .          .             int i;
        .          .          .          .             markobjectN(g, u->metatable);  
        .          .          .          .             for (i = 0; i < u->nuvalue; i++)
        .          .          .          .               markvalue(g, &u->uv[i].uv);
        .          .          .          .             genlink(g, obj2gco(u));
        .          .          .          .             return 1 + u->nuvalue;
        .          .          .          .           }
        .          .          .          .           
    1,023 ( 0.00%) .          .          .           static int traverseproto (global_State *g, Proto *f) {
        .          .          .          .             int i;
    2,181 ( 0.01%) .          .          .             markobjectN(g, f->source);
       98 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject (2x)
    9,396 ( 0.04%) .          .          .             for (i = 0; i < f->sizek; i++)  
  135,075 ( 0.62%) .          .          .               markvalue(g, &f->k[i]);
    7,693 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject (157x)
    2,333 ( 0.01%) .          .          .             for (i = 0; i < f->sizeupvalues; i++)  
    5,980 ( 0.03%) .          .          .               markobjectN(g, f->upvalues[i].name);
      784 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject (16x)
    1,981 ( 0.01%) .          .          .             for (i = 0; i < f->sizep; i++)  
    6,096 ( 0.03%) .          .          .               markobjectN(g, f->p[i]);
    8,400 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject (56x)
    9,918 ( 0.05%) .          .          .             for (i = 0; i < f->sizelocvars; i++)  
   27,066 ( 0.12%) .          .          .               markobjectN(g, f->locvars[i].varname);
    2,499 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject (51x)
    2,883 ( 0.01%) .          .          .             return 1 + f->sizek + f->sizeupvalues + f->sizep + f->sizelocvars;
      837 ( 0.00%) .          .          .           }
        .          .          .          .           
       54 ( 0.00%) .          .          .           static int traverseCclosure (global_State *g, CClosure *cl) {
        .          .          .          .             int i;
      156 ( 0.00%) .          .          .             for (i = 0; i < cl->nupvalues; i++)  
    1,086 ( 0.01%) .          .          .               markvalue(g, &cl->upvalue[i]);
      225 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject (3x)
       42 ( 0.00%) .          .          .             return 1 + cl->nupvalues;
       54 ( 0.00%) .          .          .           }
        .          .          .          .           
      333 ( 0.00%) .          .          .           static int traverseLclosure (global_State *g, LClosure *cl) {
        .          .          .          .             int i;
    1,628 ( 0.01%) .          .          .             markobjectN(g, cl->p);  
    5,550 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject (37x)
      754 ( 0.00%) .          .          .             for (i = 0; i < cl->nupvalues; i++) {  
      585 ( 0.00%) .          .          .               UpVal *uv = cl->upvals[i];
      556 ( 0.00%) .          .          .               markobjectN(g, uv);  
    2,936 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject (10x)
        .          .          .          .             }
      259 ( 0.00%) .          .          .             return 1 + cl->nupvalues;
      259 ( 0.00%) .          .          .           }
        .          .          .          .           
       90 ( 0.00%) .          .          .           static int traversethread (global_State *g, lua_State *th) {
        .          .          .          .             UpVal *uv;
       80 ( 0.00%) .          .          .             StkId o = th->stack;
      150 ( 0.00%) .          .          .             if (isold(th) || g->gcstate == GCSpropagate)
      150 ( 0.00%) .          .          .               linkgclist(th, g->grayagain);  
      245 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:linkgclist_ (5x)
       20 ( 0.00%) .          .          .             if (o == NULL)
        .          .          .          .               return 1;  
      153 ( 0.00%) .          .          .             lua_assert(g->gcstate == GCSatomic ||
        .          .          .          .                        th->openupval == NULL || isintwups(th));
    2,100 ( 0.01%) .          .          .             for (; o < th->top; o++)  
   13,384 ( 0.06%) .          .          .               markvalue(g, s2v(o));
    3,713 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject (30x)
      638 ( 0.00%) .          .          .             for (uv = th->openupval; uv != NULL; uv = uv->u.open.next)
      702 ( 0.00%) .          .          .               markobject(g, uv);  
    2,454 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reallymarkobject (18x)
       60 ( 0.00%) .          .          .             if (g->gcstate == GCSatomic) {  
    3,100 ( 0.01%) .          .          .               for (; o < th->stack_last + EXTRA_STACK; o++)
    1,827 ( 0.01%) .          .          .                 setnilvalue(s2v(o));  
        .          .          .          .               
       63 ( 0.00%) .          .          .               if (!isintwups(th) && th->openupval != NULL) {
        .          .          .          .                 th->twups = g->twups;  
        .          .          .          .                 g->twups = th;
        .          .          .          .               }
        .          .          .          .             }
       45 ( 0.00%) .          .          .             else if (!g->gcemergency)
       15 ( 0.00%) .          .          .               luaD_shrinkstack(th); 
    1,610 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_shrinkstack (5x)
      160 ( 0.00%) .          .          .             return 1 + stacksize(th);
       80 ( 0.00%) .          .          .           }
        .          .          .          .           
      804 ( 0.00%) .          .          .           static lu_mem propagatemark (global_State *g) {
    1,608 ( 0.01%) .          .          .             GCObject *o = g->gray;
    4,020 ( 0.02%) .          .          .             nw2black(o);
    2,613 ( 0.01%) .          .          .             g->gray = *getgclist(o);  
    8,588 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getgclist (201x)
    2,613 ( 0.01%) .          .          .             switch (o->tt) {
      715 ( 0.00%) .          .          .               case LUA_VTABLE: return traversetable(g, gco2t(o));
  138,449 ( 0.64%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:traversetable (55x)
        .          .          .          .               case LUA_VUSERDATA: return traverseudata(g, gco2u(o));
      555 ( 0.00%) .          .          .               case LUA_VLCL: return traverseLclosure(g, gco2lcl(o));
   12,860 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:traverseLclosure (37x)
       90 ( 0.00%) .          .          .               case LUA_VCCL: return traverseCclosure(g, gco2ccl(o));
    1,617 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:traverseCclosure (6x)
    1,395 ( 0.01%) .          .          .               case LUA_VPROTO: return traverseproto(g, gco2p(o));
  224,243 ( 1.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:traverseproto (93x)
      150 ( 0.00%) .          .          .               case LUA_VTHREAD: return traversethread(g, gco2th(o));
   30,839 ( 0.14%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:traversethread (10x)
        .          .          .          .               default: luai_unreachable(); return 0;
        .          .          .          .             }
      804 ( 0.00%) .          .          .           }
        .          .          .          .           
       80 ( 0.00%) .          .          .           static lu_mem propagateall (global_State *g) {
       20 ( 0.00%) .          .          .             lu_mem tot = 0;
      245 ( 0.00%) .          .          .             while (g->gray)
       15 ( 0.00%) .          .          .               tot += propagatemark(g);
   14,037 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:propagatemark (5x)
        .          .          .          .             return tot;
      100 ( 0.00%) .          .          .           }
        .          .          .          .           
       80 ( 0.00%) .          .          .           static void convergeephemerons (global_State *g) {
        .          .          .          .             int changed;
       20 ( 0.00%) .          .          .             int dir = 0;
        .          .          .          .             do {
        .          .          .          .               GCObject *w;
       80 ( 0.00%) .          .          .               GCObject *next = g->ephemeron;  
       50 ( 0.00%) .          .          .               g->ephemeron = NULL;  
       10 ( 0.00%) .          .          .               changed = 0;
       30 ( 0.00%) .          .          .               while ((w = next) != NULL) {  
        .          .          .          .                 Table *h = gco2t(w);
        .          .          .          .                 next = h->gclist;  
        .          .          .          .                 nw2black(h);  
        .          .          .          .                 if (traverseephemeron(g, h, dir)) {  
        .          .          .          .                   propagateall(g);  
        .          .          .          .                   changed = 1;  
        .          .          .          .                 }
        .          .          .          .               }
       10 ( 0.00%) .          .          .               dir = !dir;  
       20 ( 0.00%) .          .          .             } while (changed);  
       80 ( 0.00%) .          .          .           }
        .          .          .          .           
       70 ( 0.00%) .          .          .           static void clearbykeys (global_State *g, GCObject *l) {
       30 ( 0.00%) .          .          .             for (; l; l = gco2t(l)->gclist) {
        .          .          .          .               Table *h = gco2t(l);
        .          .          .          .               Node *limit = gnodelast(h);
        .          .          .          .               Node *n;
        .          .          .          .               for (n = gnode(h, 0); n < limit; n++) {
        .          .          .          .                 if (iscleared(g, gckeyN(n)))  
        .          .          .          .                   setempty(gval(n));  
        .          .          .          .                 if (isempty(gval(n)))  
        .          .          .          .                   clearkey(n);  
        .          .          .          .               }
        .          .          .          .             }
       60 ( 0.00%) .          .          .           }
        .          .          .          .           
      200 ( 0.00%) .          .          .           static void clearbyvalues (global_State *g, GCObject *l, GCObject *f) {
       80 ( 0.00%) .          .          .             for (; l != f; l = gco2t(l)->gclist) {
        .          .          .          .               Table *h = gco2t(l);
        .          .          .          .               Node *n, *limit = gnodelast(h);
        .          .          .          .               unsigned int i;
        .          .          .          .               unsigned int asize = luaH_realasize(h);
        .          .          .          .               for (i = 0; i < asize; i++) {
        .          .          .          .                 TValue *o = &h->array[i];
        .          .          .          .                 if (iscleared(g, gcvalueN(o)))  
        .          .          .          .                   setempty(o);  
-- line 6929 ----------------------------------------
-- line 6930 ----------------------------------------
        .          .          .          .               }
        .          .          .          .               for (n = gnode(h, 0); n < limit; n++) {
        .          .          .          .                 if (iscleared(g, gcvalueN(gval(n))))  
        .          .          .          .                   setempty(gval(n));  
        .          .          .          .                 if (isempty(gval(n)))  
        .          .          .          .                   clearkey(n);  
        .          .          .          .               }
        .          .          .          .             }
      160 ( 0.00%) .          .          .           }
        .          .          .          .           
       75 ( 0.00%) .          .          .           static void freeupval (lua_State *L, UpVal *uv) {
      270 ( 0.00%) .          .          .             if (upisopen(uv))
        .          .          .          .               luaF_unlinkupval(uv);
       60 ( 0.00%) .          .          .             luaM_free(L, uv);
    2,664 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (15x)
       60 ( 0.00%) .          .          .           }
        .          .          .          .           
    2,585 ( 0.01%) .          .          .           static void freeobj (lua_State *L, GCObject *o) {
    8,272 ( 0.04%) .          .          .             switch (o->tt) {
        .          .          .          .               case LUA_VPROTO:
      741 ( 0.00%) .          .          .                 luaF_freeproto(L, gco2p(o));
   88,666 ( 0.41%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_freeproto (57x)
        .          .          .          .                 break;
        .          .          .          .               case LUA_VUPVAL:
      195 ( 0.00%) .          .          .                 freeupval(L, gco2upv(o));
    3,129 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeupval (15x)
       15 ( 0.00%) .          .          .                 break;
        .          .          .          .               case LUA_VLCL: {
      200 ( 0.00%) .          .          .                 LClosure *cl = gco2lcl(o);
      320 ( 0.00%) .          .          .                 luaM_freemem(L, cl, sizeLclosure(cl->nupvalues));
    3,515 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (20x)
       20 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case LUA_VCCL: {
       20 ( 0.00%) .          .          .                 CClosure *cl = gco2ccl(o);
       32 ( 0.00%) .          .          .                 luaM_freemem(L, cl, sizeCclosure(cl->nupvalues));
      358 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (2x)
        2 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case LUA_VTABLE:
      234 ( 0.00%) .          .          .                 luaH_free(L, gco2t(o));
    9,566 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_free (18x)
       18 ( 0.00%) .          .          .                 break;
        .          .          .          .               case LUA_VTHREAD:
        .          .          .          .                 luaE_freethread(L, gco2th(o));
        .          .          .          .                 break;
        .          .          .          .               case LUA_VUSERDATA: {
       10 ( 0.00%) .          .          .                 Udata *u = gco2u(o);
       24 ( 0.00%) .          .          .                 luaM_freemem(L, o, sizeudata(u->nuvalue, u->len));
      179 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (1x)
        1 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case LUA_VSHRSTR: {
    4,301 ( 0.02%) .          .          .                 TString *ts = gco2ts(o);
    1,173 ( 0.01%) .          .          .                 luaS_remove(L, ts);  
   46,595 ( 0.21%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_remove (391x)
    6,256 ( 0.03%) .          .          .                 luaM_freemem(L, ts, sizelstring(ts->shrlen));
   70,222 ( 0.32%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (391x)
      391 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case LUA_VLNGSTR: {
      143 ( 0.00%) .          .          .                 TString *ts = gco2ts(o);
      156 ( 0.00%) .          .          .                 luaM_freemem(L, ts, sizelstring(ts->u.lnglen));
    2,096 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (13x)
       13 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: luai_unreachable();
        .          .          .          .             }
    2,068 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static GCObject **sweeplist (lua_State *L, GCObject **p, int countin,
      308 ( 0.00%) .          .          .                                        int *countout) {
      224 ( 0.00%) .          .          .             global_State *g = G(L);
      280 ( 0.00%) .          .          .             int ow = otherwhite(g);
        .          .          .          .             int i;
      168 ( 0.00%) .          .          .             int white = luaC_white(g);  
   15,006 ( 0.07%) .          .          .             for (i = 0; *p != NULL && i < countin; i++) {
    5,250 ( 0.02%) .          .          .               GCObject *curr = *p;
    8,400 ( 0.04%) .          .          .               int marked = curr->marked;
    2,100 ( 0.01%) .          .          .               if (isdeadm(ow, marked)) {  
      169 ( 0.00%) .          .          .                 *p = curr->next;  
       52 ( 0.00%) .          .          .                 freeobj(L, curr);  
    4,935 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeobj (13x)
        .          .          .          .               }
        .          .          .          .               else {  
    8,296 ( 0.04%) .          .          .                 curr->marked = cast_byte((marked & ~maskgcbits) | white);
    5,185 ( 0.02%) .          .          .                 p = &curr->next;  
        .          .          .          .               }
        .          .          .          .             }
       84 ( 0.00%) .          .          .             if (countout)
      115 ( 0.00%) .          .          .               *countout = i;  
      254 ( 0.00%) .          .          .             return (*p == NULL) ? NULL : p;
      252 ( 0.00%) .          .          .           }
        .          .          .          .           
       25 ( 0.00%) .          .          .           static GCObject **sweeptolive (lua_State *L, GCObject **p) {
        .          .          .          .             GCObject **old = p;
        .          .          .          .             do {
       25 ( 0.00%) .          .          .               p = sweeplist(L, p, 1, NULL);
      545 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:sweeplist (5x)
       10 ( 0.00%) .          .          .             } while (p == old);
        .          .          .          .             return p;
       20 ( 0.00%) .          .          .           }
        .          .          .          .           
       35 ( 0.00%) .          .          .           static void checkSizes (lua_State *L, global_State *g) {
       45 ( 0.00%) .          .          .             if (!g->gcemergency) {
       75 ( 0.00%) .          .          .               if (g->strt.nuse < g->strt.size / 4) {  
        .          .          .          .                 l_mem olddebt = g->GCdebt;
        .          .          .          .                 luaS_resize(L, g->strt.size / 2);
        .          .          .          .                 g->GCestimate += g->GCdebt - olddebt;  
        .          .          .          .               }
        .          .          .          .             }
       30 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static GCObject *udata2finalize (global_State *g) {
        .          .          .          .             GCObject *o = g->tobefnz;  
        .          .          .          .             lua_assert(tofinalize(o));
        .          .          .          .             g->tobefnz = o->next;  
        .          .          .          .             o->next = g->allgc;  
        .          .          .          .             g->allgc = o;
        .          .          .          .             resetbit(o->marked, FINALIZEDBIT);  
-- line 7037 ----------------------------------------
-- line 7077 ----------------------------------------
        .          .          .          .           static int runafewfinalizers (lua_State *L, int n) {
        .          .          .          .             global_State *g = G(L);
        .          .          .          .             int i;
        .          .          .          .             for (i = 0; i < n && g->tobefnz; i++)
        .          .          .          .               GCTM(L);  
        .          .          .          .             return i;
        .          .          .          .           }
        .          .          .          .           
        4 ( 0.00%) .          .          .           static void callallpendingfinalizers (lua_State *L) {
        8 ( 0.00%) .          .          .             global_State *g = G(L);
       10 ( 0.00%) .          .          .             while (g->tobefnz)
        .          .          .          .               GCTM(L);
        4 ( 0.00%) .          .          .           }
        .          .          .          .           
       24 ( 0.00%) .          .          .           static GCObject **findlast (GCObject **p) {
       54 ( 0.00%) .          .          .             while (*p != NULL)
        .          .          .          .               p = &(*p)->next;
        .          .          .          .             return p;
       30 ( 0.00%) .          .          .           }
        .          .          .          .           
       54 ( 0.00%) .          .          .           static void separatetobefnz (global_State *g, int all) {
        .          .          .          .             GCObject *curr;
       48 ( 0.00%) .          .          .             GCObject **p = &g->finobj;
       60 ( 0.00%) .          .          .             GCObject **lastnext = findlast(&g->tobefnz);
      108 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:findlast (6x)
       96 ( 0.00%) .          .          .             while ((curr = *p) != g->finobjold1) {  
        .          .          .          .               lua_assert(tofinalize(curr));
        .          .          .          .               if (!(iswhite(curr) || all))  
        .          .          .          .                 p = &curr->next;  
        .          .          .          .               else {
        .          .          .          .                 if (curr == g->finobjsur)  
        .          .          .          .                   g->finobjsur = curr->next;  
        .          .          .          .                 *p = curr->next;  
        .          .          .          .                 curr->next = *lastnext;  
        .          .          .          .                 *lastnext = curr;
        .          .          .          .                 lastnext = &curr->next;
        .          .          .          .               }
        .          .          .          .             }
       48 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void checkpointer (GCObject **p, GCObject *o) {
        .          .          .          .             if (o == *p)
        .          .          .          .               *p = o->next;
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           static void correctpointers (global_State *g, GCObject *o) {
        .          .          .          .             checkpointer(&g->survival, o);
-- line 7122 ----------------------------------------
-- line 7345 ----------------------------------------
        .          .          .          .             whitelist(g, g->finobj);
        .          .          .          .             whitelist(g, g->tobefnz);
        .          .          .          .             g->finobjrold = g->finobjold1 = g->finobjsur = NULL;
        .          .          .          .             g->gcstate = GCSpause;
        .          .          .          .             g->gckind = KGC_INC;
        .          .          .          .             g->lastatomic = 0;
        .          .          .          .           }
        .          .          .          .           
        5 ( 0.00%) .          .          .           void luaC_changemode (lua_State *L, int newmode) {
        8 ( 0.00%) .          .          .             global_State *g = G(L);
       10 ( 0.00%) .          .          .             if (newmode != g->gckind) {
        .          .          .          .               if (newmode == KGC_GEN)  
        .          .          .          .                 entergen(L, g);
        .          .          .          .               else
        .          .          .          .                 enterinc(g);  
        .          .          .          .             }
        5 ( 0.00%) .          .          .             g->lastatomic = 0;
        4 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static lu_mem fullgen (lua_State *L, global_State *g) {
        .          .          .          .             enterinc(g);
        .          .          .          .             return entergen(L, g);
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           static void setminordebt (global_State *g) {
        .          .          .          .             luaE_setdebt(g, -(cast(l_mem, (gettotalbytes(g) / 100)) * g->genminormul));
-- line 7370 ----------------------------------------
-- line 7411 ----------------------------------------
        .          .          .          .                 youngcollection(L, g);
        .          .          .          .                 setminordebt(g);
        .          .          .          .                 g->GCestimate = majorbase;  
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .             lua_assert(isdecGCmodegen(g));
        .          .          .          .           }
        .          .          .          .           
       30 ( 0.00%) .          .          .           static void setpause (global_State *g) {
        .          .          .          .             l_mem threshold, debt;
       50 ( 0.00%) .          .          .             int pause = getgcparam(g->gcpause);
       60 ( 0.00%) .          .          .             l_mem estimate = g->GCestimate / PAUSEADJ;  
       10 ( 0.00%) .          .          .             lua_assert(estimate > 0);
       20 ( 0.00%) .          .          .             threshold = (pause < MAX_LMEM / estimate)  
        .          .          .          .                       ? estimate * pause  
       25 ( 0.00%) .          .          .                       : MAX_LMEM;  
       80 ( 0.00%) .          .          .             debt = gettotalbytes(g) - threshold;
       10 ( 0.00%) .          .          .             if (debt > 0) debt = 0;
       10 ( 0.00%) .          .          .             luaE_setdebt(g, debt);
      295 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaE_setdebt (5x)
       30 ( 0.00%) .          .          .           }
        .          .          .          .           
       20 ( 0.00%) .          .          .           static void entersweep (lua_State *L) {
       40 ( 0.00%) .          .          .             global_State *g = G(L);
       40 ( 0.00%) .          .          .             g->gcstate = GCSswpallgc;
       45 ( 0.00%) .          .          .             lua_assert(g->sweepgc == NULL);
       65 ( 0.00%) .          .          .             g->sweepgc = sweeptolive(L, &g->allgc);
      625 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:sweeptolive (5x)
       20 ( 0.00%) .          .          .           }
        .          .          .          .           
       16 ( 0.00%) .          .          .           static void deletelist (lua_State *L, GCObject *p, GCObject *limit) {
    1,014 ( 0.00%) .          .          .             while (p != limit) {
    3,024 ( 0.01%) .          .          .               GCObject *next = p->next;
    1,512 ( 0.01%) .          .          .               freeobj(L, p);
  246,581 ( 1.14%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freeobj (504x)
      504 ( 0.00%) .          .          .               p = next;
        .          .          .          .             }
       12 ( 0.00%) .          .          .           }
        .          .          .          .           
        4 ( 0.00%) .          .          .           void luaC_freeallobjects (lua_State *L) {
        8 ( 0.00%) .          .          .             global_State *g = G(L);
        8 ( 0.00%) .          .          .             g->gcstp = GCSTPCLS;  
        3 ( 0.00%) .          .          .             luaC_changemode(L, KGC_INC);
       32 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_changemode (1x)
        3 ( 0.00%) .          .          .             separatetobefnz(g, 1);  
       69 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:separatetobefnz (1x)
        9 ( 0.00%) .          .          .             lua_assert(g->finobj == NULL);
        2 ( 0.00%) .          .          .             callallpendingfinalizers(L);
       26 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:callallpendingfinalizers (1x)
       33 ( 0.00%) .          .          .             deletelist(L, g->allgc, obj2gco(g->mainthread));
  234,859 ( 1.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:deletelist (1x)
        6 ( 0.00%) .          .          .             lua_assert(g->finobj == NULL);  
        8 ( 0.00%) .          .          .             deletelist(L, g->fixedgc, NULL);  
   17,804 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:deletelist (1x)
        6 ( 0.00%) .          .          .             lua_assert(g->strt.nuse == 0);
        4 ( 0.00%) .          .          .           }
        .          .          .          .           
       40 ( 0.00%) .          .          .           static lu_mem atomic (lua_State *L) {
       40 ( 0.00%) .          .          .             global_State *g = G(L);
        .          .          .          .             lu_mem work = 0;
        .          .          .          .             GCObject *origweak, *origall;
       40 ( 0.00%) .          .          .             GCObject *grayagain = g->grayagain;  
       25 ( 0.00%) .          .          .             g->grayagain = NULL;
       75 ( 0.00%) .          .          .             lua_assert(g->ephemeron == NULL && g->weak == NULL);
       85 ( 0.00%) .          .          .             lua_assert(!iswhite(g->mainthread));
       25 ( 0.00%) .          .          .             g->gcstate = GCSatomic;
       30 ( 0.00%) .          .          .             markobject(g, L);  
        .          .          .          .             
      505 ( 0.00%) .          .          .             markvalue(g, &g->l_registry);
       10 ( 0.00%) .          .          .             markmt(g);  
    1,240 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:markmt (5x)
       15 ( 0.00%) .          .          .             work += propagateall(g);  
      100 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:propagateall (5x)
        .          .          .          .             
       20 ( 0.00%) .          .          .             work += remarkupvals(g);
      274 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:remarkupvals (5x)
       15 ( 0.00%) .          .          .             work += propagateall(g);  
      100 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:propagateall (5x)
       25 ( 0.00%) .          .          .             g->gray = grayagain;
       15 ( 0.00%) .          .          .             work += propagateall(g);  
   14,197 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:propagateall (5x)
       10 ( 0.00%) .          .          .             convergeephemerons(g);
      190 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:convergeephemerons (5x)
        .          .          .          .             
        .          .          .          .             
       40 ( 0.00%) .          .          .             clearbyvalues(g, g->weak, NULL);
      110 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:clearbyvalues (5x)
       40 ( 0.00%) .          .          .             clearbyvalues(g, g->allweak, NULL);
      110 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:clearbyvalues (5x)
       50 ( 0.00%) .          .          .             origweak = g->weak; origall = g->allweak;
       15 ( 0.00%) .          .          .             separatetobefnz(g, 0);  
      345 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:separatetobefnz (5x)
       15 ( 0.00%) .          .          .             work += markbeingfnz(g);  
      105 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:markbeingfnz (5x)
       15 ( 0.00%) .          .          .             work += propagateall(g);  
      100 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:propagateall (5x)
       10 ( 0.00%) .          .          .             convergeephemerons(g);
      190 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:convergeephemerons (5x)
        .          .          .          .             
        .          .          .          .             
       35 ( 0.00%) .          .          .             clearbykeys(g, g->ephemeron);  
       80 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:clearbykeys (5x)
       35 ( 0.00%) .          .          .             clearbykeys(g, g->allweak);  
       80 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:clearbykeys (5x)
        .          .          .          .             
       40 ( 0.00%) .          .          .             clearbyvalues(g, g->weak, origweak);
      110 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:clearbyvalues (5x)
       40 ( 0.00%) .          .          .             clearbyvalues(g, g->allweak, origall);
      110 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:clearbyvalues (5x)
       10 ( 0.00%) .          .          .             luaS_clearcache(g);
   22,421 ( 0.10%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_clearcache (5x)
       55 ( 0.00%) .          .          .             g->currentwhite = cast_byte(otherwhite(g));  
       30 ( 0.00%) .          .          .             lua_assert(g->gray == NULL);
        .          .          .          .             return work;  
       45 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static int sweepstep (lua_State *L, global_State *g,
      494 ( 0.00%) .          .          .                                 int nextstate, GCObject **nextlist) {
      380 ( 0.00%) .          .          .             if (g->sweepgc) {
      115 ( 0.00%) .          .          .               l_mem olddebt = g->GCdebt;
        .          .          .          .               int count;
      345 ( 0.00%) .          .          .               g->sweepgc = sweeplist(L, g->sweepgc, GCSWEEPMAX, &count);
   50,533 ( 0.23%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:sweeplist (23x)
      437 ( 0.00%) .          .          .               g->GCestimate += g->GCdebt - olddebt;  
       23 ( 0.00%) .          .          .               return count;
        .          .          .          .             }
        .          .          .          .             else {  
       75 ( 0.00%) .          .          .               g->gcstate = nextstate;
       75 ( 0.00%) .          .          .               g->sweepgc = nextlist;
       30 ( 0.00%) .          .          .               return 0;  
        .          .          .          .             }
      380 ( 0.00%) .          .          .           }
        .          .          .          .           
    1,554 ( 0.01%) .          .          .           static lu_mem singlestep (lua_State *L) {
    2,072 ( 0.01%) .          .          .             global_State *g = G(L);
        .          .          .          .             lu_mem work;
    2,331 ( 0.01%) .          .          .             lua_assert(!g->gcstopem);  
    1,295 ( 0.01%) .          .          .             g->gcstopem = 1;  
    3,108 ( 0.01%) .          .          .             switch (g->gcstate) {
        .          .          .          .               case GCSpause: {
       10 ( 0.00%) .          .          .                 restartcollection(g);
    4,674 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:restartcollection (5x)
       25 ( 0.00%) .          .          .                 g->gcstate = GCSpropagate;
        5 ( 0.00%) .          .          .                 work = 1;
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case GCSpropagate: {
    1,809 ( 0.01%) .          .          .                 if (g->gray == NULL) {  
       25 ( 0.00%) .          .          .                   g->gcstate = GCSenteratomic;  
       10 ( 0.00%) .          .          .                   work = 0;
        .          .          .          .                 }
        .          .          .          .                 else
      784 ( 0.00%) .          .          .                   work = propagatemark(g);  
  417,926 ( 1.93%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:propagatemark (196x)
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case GCSenteratomic: {
       15 ( 0.00%) .          .          .                 work = atomic(L);  
   41,312 ( 0.19%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:atomic (5x)
       10 ( 0.00%) .          .          .                 entersweep(L);
      855 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:entersweep (5x)
       90 ( 0.00%) .          .          .                 g->GCestimate = gettotalbytes(g);  ;
        5 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case GCSswpallgc: {  
      234 ( 0.00%) .          .          .                 work = sweepstep(L, g, GCSswpfinobj, &g->finobj);
   50,987 ( 0.24%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:sweepstep (18x)
       18 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case GCSswpfinobj: {  
      130 ( 0.00%) .          .          .                 work = sweepstep(L, g, GCSswptobefnz, &g->tobefnz);
      950 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:sweepstep (10x)
       10 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case GCSswptobefnz: {  
       60 ( 0.00%) .          .          .                 work = sweepstep(L, g, GCSswpend, NULL);
      950 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:sweepstep (10x)
       10 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case GCSswpend: {  
       15 ( 0.00%) .          .          .                 checkSizes(L, g);
      185 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checkSizes (5x)
       25 ( 0.00%) .          .          .                 g->gcstate = GCScallfin;
        5 ( 0.00%) .          .          .                 work = 0;
        5 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case GCScallfin: {  
       45 ( 0.00%) .          .          .                 if (g->tobefnz && !g->gcemergency) {
        .          .          .          .                   g->gcstopem = 0;  
        .          .          .          .                   work = runafewfinalizers(L, GCFINMAX) * GCFINALIZECOST;
        .          .          .          .                 }
        .          .          .          .                 else {  
       25 ( 0.00%) .          .          .                   g->gcstate = GCSpause;  
       10 ( 0.00%) .          .          .                   work = 0;
        .          .          .          .                 }
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: luai_unreachable(); return 0;
        .          .          .          .             }
    1,295 ( 0.01%) .          .          .             g->gcstopem = 0;
        .          .          .          .             return work;
    1,813 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaC_runtilstate (lua_State *L, int statesmask) {
        .          .          .          .             global_State *g = G(L);
        .          .          .          .             while (!testbit(statesmask, g->gcstate))
        .          .          .          .               singlestep(L);
        .          .          .          .           }
        .          .          .          .           
       45 ( 0.00%) .          .          .           static void incstep (lua_State *L, global_State *g) {
       60 ( 0.00%) .          .          .             int stepmul = (getgcparam(g->gcstepmul) | 1);  
       45 ( 0.00%) .          .          .             l_mem debt = (g->GCdebt / WORK2MEM) * stepmul;
       40 ( 0.00%) .          .          .             l_mem stepsize = (g->gcstepsize <= log2maxs(l_mem))
       85 ( 0.00%) .          .          .                            ? ((cast(l_mem, 1) << g->gcstepsize) / WORK2MEM) * stepmul
       20 ( 0.00%) .          .          .                            : MAX_LMEM;  
        .          .          .          .             do {  
      518 ( 0.00%) .          .          .               lu_mem work = singlestep(L);  
  534,687 ( 2.47%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:singlestep (259x)
      518 ( 0.00%) .          .          .               debt -= work;
    2,849 ( 0.01%) .          .          .             } while (debt > -stepsize && g->gcstate != GCSpause);
       30 ( 0.00%) .          .          .             if (g->gcstate == GCSpause)
       15 ( 0.00%) .          .          .               setpause(g);  
      620 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:setpause (5x)
        .          .          .          .             else {
        .          .          .          .               debt = (debt / stepmul) * WORK2MEM;  
        .          .          .          .               luaE_setdebt(g, debt);
        .          .          .          .             }
       40 ( 0.00%) .          .          .           }
        .          .          .          .           
       20 ( 0.00%) .          .          .           void luaC_step (lua_State *L) {
       40 ( 0.00%) .          .          .             global_State *g = G(L);
       45 ( 0.00%) .          .          .             lua_assert(!g->gcemergency);
       30 ( 0.00%) .          .          .             if (gcrunning(g)) {  
       60 ( 0.00%) .          .          .               if(isdecGCmodegen(g))
        .          .          .          .                 genstep(L, g);
        .          .          .          .               else
       15 ( 0.00%) .          .          .                 incstep(L, g);
  539,572 ( 2.49%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:incstep (5x)
        .          .          .          .             }
       25 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void fullinc (lua_State *L, global_State *g) {
        .          .          .          .             if (keepinvariant(g))  
        .          .          .          .               entersweep(L); 
        .          .          .          .             
        .          .          .          .             luaC_runtilstate(L, bitmask(GCSpause));
        .          .          .          .             luaC_runtilstate(L, bitmask(GCScallfin));  
        .          .          .          .             
-- line 7621 ----------------------------------------
-- line 7748 ----------------------------------------
        .          .          .          .               "<<", ">>", "::", "<eof>",
        .          .          .          .               "<number>", "<integer>", "<name>", "<string>"
        .          .          .          .           };
        .          .          .          .           
        .          .          .          .           #define save_and_next(ls) (save(ls, ls->current), next(ls))
        .          .          .          .           
        .          .          .          .           static l_noret lexerror (LexState *ls, const char *msg, int token);
        .          .          .          .           
  119,205 ( 0.55%) .          .          .           static void save (LexState *ls, int c) {
  105,960 ( 0.49%) .          .          .             Mbuffer *b = ls->buff;
  251,655 ( 1.16%) .          .          .             if (luaZ_bufflen(b) + 1 > luaZ_sizebuffer(b)) {
        .          .          .          .               size_t newsize;
       35 ( 0.00%) .          .          .               if (luaZ_sizebuffer(b) >= MAX_SIZE/2)
        .          .          .          .                 lexerror(ls, "lexical element too long", 0);
       25 ( 0.00%) .          .          .               newsize = luaZ_sizebuffer(b) * 2;
      145 ( 0.00%) .          .          .               luaZ_resizebuffer(ls->L, b, newsize);
    2,444 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_saferealloc_ (5x)
        .          .          .          .             }
  317,880 ( 1.47%) .          .          .             b->buffer[luaZ_bufflen(b)++] = cast_char(c);
  105,960 ( 0.49%) .          .          .           }
        .          .          .          .           
        6 ( 0.00%) .          .          .           void luaX_init (lua_State *L) {
        .          .          .          .             int i;
        4 ( 0.00%) .          .          .             TString *e = luaS_newliteral(L, LUA_ENV);  
      712 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_newlstr (1x)
       16 ( 0.00%) .          .          .             luaC_fix(L, obj2gco(e));  
       84 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_fix (1x)
      136 ( 0.00%) .          .          .             for (i=0; i<NUM_RESERVED; i++) {
      528 ( 0.00%) .          .          .               TString *ts = luaS_new(L, luaX_tokens[i]);
   20,312 ( 0.09%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_new (22x)
      352 ( 0.00%) .          .          .               luaC_fix(L, obj2gco(ts));  
    1,848 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_fix (22x)
      198 ( 0.00%) .          .          .               ts->extra = cast_byte(i+1);  
        .          .          .          .             }
        6 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           const char *luaX_token2str (LexState *ls, int token) {
        .          .          .          .             if (token < FIRST_RESERVED) {  
        .          .          .          .               if (lisprint(token))
        .          .          .          .                 return luaO_pushfstring(ls->L, "'%c'", token);
        .          .          .          .               else  
        .          .          .          .                 return luaO_pushfstring(ls->L, "'<\\%d>'", token);
        .          .          .          .             }
-- line 7785 ----------------------------------------
-- line 7809 ----------------------------------------
        .          .          .          .               luaO_pushfstring(ls->L, "%s near %s", msg, txtToken(ls, token));
        .          .          .          .             luaD_throw(ls->L, LUA_ERRSYNTAX);
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           l_noret luaX_syntaxerror (LexState *ls, const char *msg) {
        .          .          .          .             lexerror(ls, msg, ls->t.token);
        .          .          .          .           }
        .          .          .          .           
   26,430 ( 0.12%) .          .          .           TString *luaX_newstring (LexState *ls, const char *str, size_t l) {
   21,144 ( 0.10%) .          .          .             lua_State *L = ls->L;
   13,215 ( 0.06%) .          .          .             TString *ts = luaS_newlstr(L, str, l);  
  949,418 ( 4.38%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_newlstr (2,643x)
   29,073 ( 0.13%) .          .          .             const TValue *o = luaH_getstr(ls->h, ts);
  638,301 ( 2.95%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_getstr (2,643x)
   23,787 ( 0.11%) .          .          .             if (!ttisnil(o))  
   61,479 ( 0.28%) .          .          .               ts = keystrval(nodefromval(o));  
        .          .          .          .             else {  
    7,686 ( 0.04%) .          .          .               TValue *stv = s2v(L->top++);  
   38,796 ( 0.18%) .          .          .               setsvalue(L, stv, ts);  
    3,660 ( 0.02%) .          .          .               luaH_finishset(L, ls->h, stv, o, stv);  
  980,844 ( 4.53%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_finishset (366x)
        .          .          .          .               
    6,231 ( 0.03%) .          .          .               luaC_checkGC(L);
  493,294 ( 2.28%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_step (3x)
    5,124 ( 0.02%) .          .          .               L->top--;  
        .          .          .          .             }
      366 ( 0.00%) .          .          .             return ts;
   23,787 ( 0.11%) .          .          .           }
        .          .          .          .           
    6,072 ( 0.03%) .          .          .           static void inclinenumber (LexState *ls) {
    5,060 ( 0.02%) .          .          .             int old = ls->current;
   10,120 ( 0.05%) .          .          .             lua_assert(currIsNewline(ls));
   51,578 ( 0.24%) .          .          .             next(ls);  
      158 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaZ_fill (2x)
   11,146 ( 0.05%) .          .          .             if (currIsNewline(ls) && ls->current != old)
        .          .          .          .               next(ls);  
   19,228 ( 0.09%) .          .          .             if (++ls->linenumber >= MAX_INT)
        .          .          .          .               lexerror(ls, "chunk has too many lines", 0);
    6,072 ( 0.03%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source,
       20 ( 0.00%) .          .          .                               int firstchar) {
       16 ( 0.00%) .          .          .             ls->t.token = 0;
       16 ( 0.00%) .          .          .             ls->L = L;
       10 ( 0.00%) .          .          .             ls->current = firstchar;
       10 ( 0.00%) .          .          .             ls->lookahead.token = TK_EOS;  
       16 ( 0.00%) .          .          .             ls->z = z;
       10 ( 0.00%) .          .          .             ls->fs = NULL;
       10 ( 0.00%) .          .          .             ls->linenumber = 1;
       10 ( 0.00%) .          .          .             ls->lastline = 1;
       16 ( 0.00%) .          .          .             ls->source = source;
       26 ( 0.00%) .          .          .             ls->envn = luaS_newliteral(L, LUA_ENV);  
      578 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_newlstr (2x)
      110 ( 0.00%) .          .          .             luaZ_resizebuffer(ls->L, ls->buff, LUA_MINBUFFER);  
      614 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_saferealloc_ (2x)
       12 ( 0.00%) .          .          .           }
        .          .          .          .           
    4,816 ( 0.02%) .          .          .           static int check_next1 (LexState *ls, int c) {
    4,128 ( 0.02%) .          .          .             if (ls->current == c) {
    6,477 ( 0.03%) .          .          .               next(ls);
      254 ( 0.00%) .          .          .               return 1;
        .          .          .          .             }
      561 ( 0.00%) .          .          .             else return 0;
    4,128 ( 0.02%) .          .          .           }
        .          .          .          .           
    2,961 ( 0.01%) .          .          .           static int check_next2 (LexState *ls, const char *set) {
    2,538 ( 0.01%) .          .          .             lua_assert(set[2] == '\0');
    8,028 ( 0.04%) .          .          .             if (ls->current == set[0] || ls->current == set[1]) {
       58 ( 0.00%) .          .          .               save_and_next(ls);
       68 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (1x)
        2 ( 0.00%) .          .          .               return 1;
        .          .          .          .             }
      422 ( 0.00%) .          .          .             else return 0;
    2,538 ( 0.01%) .          .          .           }
        .          .          .          .           
    2,772 ( 0.01%) .          .          .           static int read_numeral (LexState *ls, SemInfo *seminfo) {
        .          .          .          .             TValue obj;
      690 ( 0.00%) .          .          .             const char *expo = "Ee";
    1,155 ( 0.01%) .          .          .             int first = ls->current;
    6,930 ( 0.03%) .          .          .             lua_assert(lisdigit(ls->current));
   13,398 ( 0.06%) .          .          .             save_and_next(ls);
   15,708 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (231x)
      587 ( 0.00%) .          .          .             if (first == '0' && check_next2(ls, "xX"))  
    1,093 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_next2 (25x)
        3 ( 0.00%) .          .          .               expo = "Pp";
        .          .          .          .             for (;;) {
    1,990 ( 0.01%) .          .          .               if (check_next2(ls, expo))  
   15,522 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_next2 (398x)
        .          .          .          .                 check_next2(ls, "-+");  
   13,730 ( 0.06%) .          .          .               else if (lisxdigit(ls->current) || ls->current == '.')  
    9,185 ( 0.04%) .          .          .                 save_and_next(ls);
   11,356 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (167x)
        .          .          .          .               else break;
        .          .          .          .             }
    3,927 ( 0.02%) .          .          .             if (lislalpha(ls->current))  
        .          .          .          .               save_and_next(ls);  
      693 ( 0.00%) .          .          .             save(ls, '\0');
   15,708 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (231x)
    3,927 ( 0.02%) .          .          .             if (luaO_str2num(luaZ_buffer(ls->buff), &obj) == 0)  
   62,261 ( 0.29%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaO_str2num (231x)
        .          .          .          .               lexerror(ls, "malformed number", TK_FLT);
      693 ( 0.00%) .          .          .             if (ttisinteger(&obj)) {
    1,840 ( 0.01%) .          .          .               seminfo->i = ivalue(&obj);
      460 ( 0.00%) .          .          .               return TK_INT;
        .          .          .          .             }
        .          .          .          .             else {
        2 ( 0.00%) .          .          .               lua_assert(ttisfloat(&obj));
        8 ( 0.00%) .          .          .               seminfo->r = fltvalue(&obj);
        1 ( 0.00%) .          .          .               return TK_FLT;
        .          .          .          .             }
    2,541 ( 0.01%) .          .          .           }
        .          .          .          .           
      808 ( 0.00%) .          .          .           static size_t skip_sep (LexState *ls) {
      101 ( 0.00%) .          .          .             size_t count = 0;
      505 ( 0.00%) .          .          .             int s = ls->current;
      606 ( 0.00%) .          .          .             lua_assert(s == '[' || s == ']');
    5,858 ( 0.03%) .          .          .             save_and_next(ls);
    6,868 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (101x)
      822 ( 0.00%) .          .          .             while (ls->current == '=') {
      110 ( 0.00%) .          .          .               save_and_next(ls);
      136 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (2x)
        2 ( 0.00%) .          .          .               count++;
        .          .          .          .             }
      404 ( 0.00%) .          .          .             return (ls->current == s) ? count + 2
      404 ( 0.00%) .          .          .                    : (count == 0) ? 1
       93 ( 0.00%) .          .          .                    : 0;
      808 ( 0.00%) .          .          .           }
        .          .          .          .           
       30 ( 0.00%) .          .          .           static void read_long_string (LexState *ls, SemInfo *seminfo, size_t sep) {
       27 ( 0.00%) .          .          .             int line = ls->linenumber;  
      174 ( 0.00%) .          .          .             save_and_next(ls);  
      204 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (3x)
       30 ( 0.00%) .          .          .             if (currIsNewline(ls))  
        9 ( 0.00%) .          .          .               inclinenumber(ls);  
      321 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:inclinenumber (3x)
        .          .          .          .             for (;;) {
   14,866 ( 0.07%) .          .          .               switch (ls->current) {
        .          .          .          .                 case EOZ: {  
        .          .          .          .                   const char *what = (seminfo ? "string" : "comment");
        .          .          .          .                   const char *msg = luaO_pushfstring(ls->L,
        .          .          .          .                                "unfinished long %s (starting at line %d)", what, line);
        .          .          .          .                   lexerror(ls, msg, TK_EOS);
        .          .          .          .                   break;  
        .          .          .          .                 }
        .          .          .          .                 case ']': {
       28 ( 0.00%) .          .          .                   if (skip_sep(ls) == sep) {
    1,323 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:skip_sep (7x)
      165 ( 0.00%) .          .          .                     save_and_next(ls);  
      204 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (3x)
        .          .          .          .                     goto endloop;
        .          .          .          .                   }
        .          .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case '\n': case '\r': {
       99 ( 0.00%) .          .          .                   save(ls, '\n');
    2,244 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (33x)
       66 ( 0.00%) .          .          .                   inclinenumber(ls);
    3,537 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:inclinenumber (33x)
      491 ( 0.00%) .          .          .                   if (!seminfo) luaZ_resetbuffer(ls->buff);  
        .          .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 default: {
   11,112 ( 0.05%) .          .          .                   if (seminfo) save_and_next(ls);
   11,106 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (147x)
   63,357 ( 0.29%) .          .          .                   else next(ls);
        .          .          .          .                 }
        .          .          .          .               }
        .          .          .          .             } endloop:
        6 ( 0.00%) .          .          .             if (seminfo)
       26 ( 0.00%) .          .          .               seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + sep,
    5,380 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_newstring (1x)
       16 ( 0.00%) .          .          .                                                luaZ_bufflen(ls->buff) - 2 * sep);
       24 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void esccheck (LexState *ls, int c, const char *msg) {
        .          .          .          .             if (!c) {
        .          .          .          .               if (ls->current != EOZ)
        .          .          .          .                 save_and_next(ls);  
        .          .          .          .               lexerror(ls, msg, TK_STRING);
        .          .          .          .             }
        .          .          .          .           }
-- line 7965 ----------------------------------------
-- line 8008 ----------------------------------------
        .          .          .          .               r = 10*r + ls->current - '0';
        .          .          .          .               save_and_next(ls);
        .          .          .          .             }
        .          .          .          .             esccheck(ls, r <= UCHAR_MAX, "decimal escape too large");
        .          .          .          .             luaZ_buffremove(ls->buff, i);  
        .          .          .          .             return r;
        .          .          .          .           }
        .          .          .          .           
    2,400 ( 0.01%) .          .          .           static void read_string (LexState *ls, int del, SemInfo *seminfo) {
   13,920 ( 0.06%) .          .          .             save_and_next(ls);  
   16,320 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (240x)
   17,061 ( 0.08%) .          .          .             while (ls->current != del) {
   18,461 ( 0.09%) .          .          .               switch (ls->current) {
        .          .          .          .                 case EOZ:
        .          .          .          .                   lexerror(ls, "unfinished string", TK_EOS);
        .          .          .          .                   break;  
        .          .          .          .                 case '\n':
        .          .          .          .                 case '\r':
        .          .          .          .                   lexerror(ls, "unfinished string", TK_STRING);
        .          .          .          .                   break;  
        .          .          .          .                 case '\\': {  
        .          .          .          .                   int c;  
    1,210 ( 0.01%) .          .          .                   save_and_next(ls);  
    1,496 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (22x)
      264 ( 0.00%) .          .          .                   switch (ls->current) {
        .          .          .          .                     case 'a': c = '\a'; goto read_save;
        .          .          .          .                     case 'b': c = '\b'; goto read_save;
        .          .          .          .                     case 'f': c = '\f'; goto read_save;
       38 ( 0.00%) .          .          .                     case 'n': c = '\n'; goto read_save;
        .          .          .          .                     case 'r': c = '\r'; goto read_save;
        6 ( 0.00%) .          .          .                     case 't': c = '\t'; goto read_save;
        .          .          .          .                     case 'v': c = '\v'; goto read_save;
        .          .          .          .                     case 'x': c = readhexaesc(ls); goto read_save;
        .          .          .          .                     case 'u': utf8esc(ls);  goto no_save;
        .          .          .          .                     case '\n': case '\r':
        .          .          .          .                       inclinenumber(ls); c = '\n'; goto only_save;
        .          .          .          .                     case '\\': case '\"': case '\'':
        .          .          .          .                       c = ls->current; goto read_save;
        .          .          .          .                     case EOZ: goto no_save;  
-- line 8044 ----------------------------------------
-- line 8053 ----------------------------------------
        .          .          .          .                     }
        .          .          .          .                     default: {
        .          .          .          .                       esccheck(ls, lisdigit(ls->current), "invalid escape sequence");
        .          .          .          .                       c = readdecesc(ls);  
        .          .          .          .                       goto only_save;
        .          .          .          .                     }
        .          .          .          .                   }
        .          .          .          .                  read_save:
    1,056 ( 0.00%) .          .          .                    next(ls);
        .          .          .          .                    
        .          .          .          .                  only_save:
      484 ( 0.00%) .          .          .                    luaZ_buffremove(ls->buff, 1);  
       88 ( 0.00%) .          .          .                    save(ls, c);
    1,496 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (22x)
        .          .          .          .                    
        .          .          .          .                  no_save: break;
        .          .          .          .                 }
        .          .          .          .                 default:
  117,755 ( 0.54%) .          .          .                   save_and_next(ls);
  147,127 ( 0.68%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (2,141x)
        .          .          .          .               }
        .          .          .          .             }
   13,200 ( 0.06%) .          .          .             save_and_next(ls);  
   16,320 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (240x)
    6,240 ( 0.03%) .          .          .             seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + 1,
  606,891 ( 2.80%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_newstring (240x)
    3,600 ( 0.02%) .          .          .                                              luaZ_bufflen(ls->buff) - 2);
    1,920 ( 0.01%) .          .          .           }
        .          .          .          .           
   47,466 ( 0.22%) .          .          .           static int llex (LexState *ls, SemInfo *seminfo) {
   84,384 ( 0.39%) .          .          .             luaZ_resetbuffer(ls->buff);
        .          .          .          .             for (;;) {
  171,542 ( 0.79%) .          .          .               switch (ls->current) {
        .          .          .          .                 case '\n': case '\r': {  
    1,952 ( 0.01%) .          .          .                   inclinenumber(ls);
  105,576 ( 0.49%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:inclinenumber (976x)
      976 ( 0.00%) .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case ' ': case '\f': case '\t': case '\v': {  
  166,639 ( 0.77%) .          .          .                   next(ls);
    1,280 ( 0.01%) 2 ( 0.37%) 39,203 ( 0.01%) 36,396 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaZ_fill (1x)
    3,472 ( 0.02%) .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case '-': {  
    7,214 ( 0.03%) .          .          .                   next(ls);
    3,965 ( 0.02%) 4 ( 0.75%) 66,125 ( 0.01%) 62,772 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaZ_fill (2x)
      906 ( 0.00%) .          .          .                   if (ls->current != '-') return '-';
        .          .          .          .                   
    6,720 ( 0.03%) .          .          .                   next(ls);
      840 ( 0.00%) .          .          .                   if (ls->current == '[') {  
        6 ( 0.00%) .          .          .                     size_t sep = skip_sep(ls);
      471 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:skip_sep (2x)
       26 ( 0.00%) .          .          .                     luaZ_resetbuffer(ls->buff);  
        4 ( 0.00%) .          .          .                     if (sep >= 2) {
        8 ( 0.00%) .          .          .                       read_long_string(ls, NULL, sep);  
   86,187 ( 0.40%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:read_long_string (2x)
       26 ( 0.00%) .          .          .                       luaZ_resetbuffer(ls->buff);  
        2 ( 0.00%) .          .          .                       break;
        .          .          .          .                     }
        .          .          .          .                   }
        .          .          .          .                   
   78,324 ( 0.36%) .          .          .                   while (!currIsNewline(ls) && ls->current != EOZ)
  216,847 ( 1.00%) .          .          .                     next(ls);  
      635 ( 0.00%) 1 ( 0.19%) 24,904 ( 0.00%) 22,950 ( 0.00%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaZ_fill (1x)
        .          .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case '[': {  
      184 ( 0.00%) .          .          .                   size_t sep = skip_sep(ls);
   15,731 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:skip_sep (92x)
      184 ( 0.00%) .          .          .                   if (sep >= 2) {
        4 ( 0.00%) .          .          .                     read_long_string(ls, seminfo, sep);
   28,658 ( 0.13%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:read_long_string (1x)
        2 ( 0.00%) .          .          .                     return TK_STRING;
        .          .          .          .                   }
      182 ( 0.00%) .          .          .                   else if (sep == 0)  
        .          .          .          .                     lexerror(ls, "invalid long string delimiter", TK_STRING);
        .          .          .          .                   return '[';
        .          .          .          .                 }
        .          .          .          .                 case '=': {
   22,800 ( 0.11%) .          .          .                   next(ls);
    2,557 ( 0.01%) .          .          .                   if (check_next1(ls, '=')) return TK_EQ;  
   14,232 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_next1 (475x)
        .          .          .          .                   else return '=';
        .          .          .          .                 }
        .          .          .          .                 case '<': {
      384 ( 0.00%) .          .          .                   next(ls);
       44 ( 0.00%) .          .          .                   if (check_next1(ls, '=')) return TK_LE;  
      264 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_next1 (8x)
       30 ( 0.00%) .          .          .                   else if (check_next1(ls, '<')) return TK_SHL;  
      120 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_next1 (6x)
        .          .          .          .                   else return '<';
        .          .          .          .                 }
        .          .          .          .                 case '>': {
      288 ( 0.00%) .          .          .                   next(ls);
       32 ( 0.00%) .          .          .                   if (check_next1(ls, '=')) return TK_GE;  
      172 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_next1 (6x)
       25 ( 0.00%) .          .          .                   else if (check_next1(ls, '>')) return TK_SHR;  
      100 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_next1 (5x)
        .          .          .          .                   else return '>';
        .          .          .          .                 }
        .          .          .          .                 case '/': {
      240 ( 0.00%) .          .          .                   next(ls);
       31 ( 0.00%) .          .          .                   if (check_next1(ls, '/')) return TK_IDIV;  
      256 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_next1 (5x)
        .          .          .          .                   else return '/';
        .          .          .          .                 }
        .          .          .          .                 case '~': {
      144 ( 0.00%) .          .          .                   next(ls);
       21 ( 0.00%) .          .          .                   if (check_next1(ls, '=')) return TK_NE;  
      216 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_next1 (3x)
        .          .          .          .                   else return '~';
        .          .          .          .                 }
        .          .          .          .                 case ':': {
       96 ( 0.00%) .          .          .                   next(ls);
       10 ( 0.00%) .          .          .                   if (check_next1(ls, ':')) return TK_DBCOLON;  
       40 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_next1 (2x)
        .          .          .          .                   else return ':';
        .          .          .          .                 }
        .          .          .          .                 case '"': case '\'': {  
    1,920 ( 0.01%) .          .          .                   read_string(ls, ls->current, seminfo);
  987,353 ( 4.56%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:read_string (240x)
      240 ( 0.00%) .          .          .                   return TK_STRING;
        .          .          .          .                 }
        .          .          .          .                 case '.': {  
    8,415 ( 0.04%) .          .          .                   save_and_next(ls);
   10,404 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (153x)
      765 ( 0.00%) .          .          .                   if (check_next1(ls, '.')) {
    4,360 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_next1 (153x)
      125 ( 0.00%) .          .          .                     if (check_next1(ls, '.'))
      604 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_next1 (25x)
        4 ( 0.00%) .          .          .                       return TK_DOTS;   
       46 ( 0.00%) .          .          .                     else return TK_CONCAT;   
        .          .          .          .                   }
    3,840 ( 0.02%) .          .          .                   else if (!lisdigit(ls->current)) return '.';
        .          .          .          .                   else return read_numeral(ls, seminfo);
        .          .          .          .                 }
        .          .          .          .                 case '0': case '1': case '2': case '3': case '4':
        .          .          .          .                 case '5': case '6': case '7': case '8': case '9': {
    1,155 ( 0.01%) .          .          .                   return read_numeral(ls, seminfo);
  186,180 ( 0.86%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:read_numeral (231x)
        .          .          .          .                 }
        .          .          .          .                 case EOZ: {
        .          .          .          .                   return TK_EOS;
        .          .          .          .                 }
        .          .          .          .                 default: {
  117,334 ( 0.54%) .          .          .                   if (lislalpha(ls->current)) {  
        .          .          .          .                     TString *ts;
        .          .          .          .                     do {
  522,940 ( 2.41%) .          .          .                       save_and_next(ls);
  646,544 ( 2.98%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:save (9,508x)
  256,716 ( 1.18%) .          .          .                     } while (lislalnum(ls->current));
   47,313 ( 0.22%) .          .          .                     ts = luaX_newstring(ls, luaZ_buffer(ls->buff),
2,595,901 (11.98%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_newstring (2,253x)
   11,265 ( 0.05%) .          .          .                                             luaZ_bufflen(ls->buff));
   11,265 ( 0.05%) .          .          .                     seminfo->ts = ts;
   42,807 ( 0.20%) .          .          .                     if (isreserved(ts))  
    5,376 ( 0.02%) .          .          .                       return ts->extra - 1 + FIRST_RESERVED;
        .          .          .          .                     else {
    3,162 ( 0.01%) .          .          .                       return TK_NAME;
        .          .          .          .                     }
        .          .          .          .                   }
        .          .          .          .                   else {  
    7,172 ( 0.03%) .          .          .                     int c = ls->current;
   86,064 ( 0.40%) .          .          .                     next(ls);
    1,793 ( 0.01%) .          .          .                     return c;
        .          .          .          .                   }
        .          .          .          .                 }
        .          .          .          .               }
        .          .          .          .             }
   47,466 ( 0.22%) .          .          .           }
        .          .          .          .           
   21,096 ( 0.10%) .          .          .           void luaX_next (LexState *ls) {
   84,384 ( 0.39%) .          .          .             ls->lastline = ls->linenumber;
   47,466 ( 0.22%) .          .          .             if (ls->lookahead.token != TK_EOS) {  
      354 ( 0.00%) .          .          .               ls->t = ls->lookahead;  
      295 ( 0.00%) .          .          .               ls->lookahead.token = TK_EOS;  
        .          .          .          .             }
        .          .          .          .             else
   67,795 ( 0.31%) .          .          .               ls->t.token = llex(ls, &ls->t.seminfo);  
6,670,256 (30.78%) 7 ( 1.31%) 130,232 ( 0.02%) 122,118 ( 0.02%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:llex (5,215x)
   26,311 ( 0.12%) .          .          .           }
        .          .          .          .           
      236 ( 0.00%) .          .          .           int luaX_lookahead (LexState *ls) {
      531 ( 0.00%) .          .          .             lua_assert(ls->lookahead.token == TK_EOS);
      944 ( 0.00%) .          .          .             ls->lookahead.token = llex(ls, &ls->lookahead.seminfo);
   10,788 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:llex (59x)
      236 ( 0.00%) .          .          .             return ls->lookahead.token;
      295 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           // root include lmem.c
        .          .          .          .           
        .          .          .          .           //included "stddef.h" 
        .          .          .          .           
        .          .          .          .           #if defined(EMERGENCYGCTESTS)
        .          .          .          .           
        .          .          .          .           static void *firsttry (global_State *g, void *block, size_t os, size_t ns) {
-- line 8219 ----------------------------------------
-- line 8224 ----------------------------------------
        .          .          .          .           }
        .          .          .          .           #else
        .          .          .          .           #define firsttry(g,block,os,ns)    ((*g->frealloc)(g->ud, block, os, ns))
        .          .          .          .           #endif
        .          .          .          .           
        .          .          .          .           #define MINSIZEARRAY	4
        .          .          .          .           
        .          .          .          .           void *luaM_growaux_ (lua_State *L, void *block, int nelems, int *psize,
  111,163 ( 0.51%) .          .          .                                int size_elems, int limit, const char *what) {
        .          .          .          .             void *newblock;
   42,755 ( 0.20%) .          .          .             int size = *psize;
   17,102 ( 0.08%) .          .          .             if (nelems + 1 <= size)  
   16,140 ( 0.07%) .          .          .               return block;  
    2,886 ( 0.01%) .          .          .             if (size >= limit / 2) {  
        .          .          .          .               if (l_unlikely(size >= limit))  
        .          .          .          .                 luaG_runerror(L, "too many %s (limit is %d)", what, limit);
        .          .          .          .               size = limit;  
        .          .          .          .             }
        .          .          .          .             else {
    1,443 ( 0.01%) .          .          .               size *= 2;
      962 ( 0.00%) .          .          .               if (size < MINSIZEARRAY)
      470 ( 0.00%) .          .          .                 size = MINSIZEARRAY;  
        .          .          .          .             }
    2,886 ( 0.01%) .          .          .             lua_assert(nelems + 1 <= size && size <= limit);
        .          .          .          .             
    6,734 ( 0.03%) .          .          .             newblock = luaM_saferealloc_(L, block, cast_sizet(*psize) * size_elems,
  163,965 ( 0.76%) 1 ( 0.19%) 26,259 ( 0.00%) 24,752 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_saferealloc_ (481x)
      481 ( 0.00%) .          .          .                                                    cast_sizet(size) * size_elems);
    2,405 ( 0.01%) .          .          .             *psize = size;  
        .          .          .          .             return newblock;
   76,959 ( 0.36%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void *luaM_shrinkvector_ (lua_State *L, void *block, int *size,
    4,788 ( 0.02%) .          .          .                                     int final_n, int size_elem) {
        .          .          .          .             void *newblock;
    3,591 ( 0.02%) .          .          .             size_t oldsize = cast_sizet((*size) * size_elem);
    1,596 ( 0.01%) .          .          .             size_t newsize = cast_sizet(final_n * size_elem);
      798 ( 0.00%) .          .          .             lua_assert(newsize <= oldsize);
    1,995 ( 0.01%) .          .          .             newblock = luaM_saferealloc_(L, block, oldsize, newsize);
   50,379 ( 0.23%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_saferealloc_ (399x)
    1,995 ( 0.01%) .          .          .             *size = final_n;
        .          .          .          .             return newblock;
    3,591 ( 0.02%) .          .          .           }
        .          .          .          .           
        .          .          .          .           l_noret luaM_toobig (lua_State *L) {
        .          .          .          .             luaG_runerror(L, "memory allocation error: block too big");
        .          .          .          .           }
        .          .          .          .           
    7,968 ( 0.04%) .          .          .           void luaM_free_ (lua_State *L, void *block, size_t osize) {
    7,968 ( 0.04%) .          .          .             global_State *g = G(L);
    5,976 ( 0.03%) .          .          .             lua_assert((osize == 0) == (block == NULL));
   16,932 ( 0.08%) .          .          .             (*g->frealloc)(g->ud, block, osize, 0);
  116,888 ( 0.54%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:l_alloc (996x)
   13,944 ( 0.06%) .          .          .             g->GCdebt -= osize;
    5,976 ( 0.03%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void *tryagain (lua_State *L, void *block,
        .          .          .          .                                  size_t osize, size_t nsize) {
        .          .          .          .             global_State *g = G(L);
        .          .          .          .             if (completestate(g) && !g->gcstopem) {
        .          .          .          .               luaC_fullgc(L, 1);  
        .          .          .          .               return (*g->frealloc)(g->ud, block, osize, nsize);  
        .          .          .          .             }
        .          .          .          .             else return NULL;  
        .          .          .          .           }
        .          .          .          .           
   10,329 ( 0.05%) .          .          .           void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {
        .          .          .          .             void *newblock;
    7,512 ( 0.03%) .          .          .             global_State *g = G(L);
    5,634 ( 0.03%) .          .          .             lua_assert((osize == 0) == (block == NULL));
   16,902 ( 0.08%) .          .          .             newblock = firsttry(g, block, osize, nsize);
  139,020 ( 0.64%) 1 ( 0.19%) 26,259 ( 0.00%) 24,752 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:l_alloc (939x)
    5,634 ( 0.03%) .          .          .             if (l_unlikely(newblock == NULL && nsize > 0)) {
        .          .          .          .               newblock = tryagain(L, block, osize, nsize);
        .          .          .          .               if (newblock == NULL)  
        .          .          .          .                 return NULL;  
        .          .          .          .             }
    3,756 ( 0.02%) .          .          .             lua_assert((nsize == 0) == (newblock == NULL));
   13,146 ( 0.06%) .          .          .             g->GCdebt = (g->GCdebt + nsize) - osize;
        .          .          .          .             return newblock;
    8,451 ( 0.04%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void *luaM_saferealloc_ (lua_State *L, void *block, size_t osize,
    4,445 ( 0.02%) .          .          .                                                               size_t nsize) {
      889 ( 0.00%) .          .          .             void *newblock = luaM_realloc_(L, block, osize, nsize);
  203,608 ( 0.94%) 1 ( 0.19%) 26,259 ( 0.00%) 24,752 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_realloc_ (889x)
    5,334 ( 0.02%) .          .          .             if (l_unlikely(newblock == NULL && nsize > 0))  
        .          .          .          .               luaM_error(L);
        .          .          .          .             return newblock;
    3,556 ( 0.02%) .          .          .           }
        .          .          .          .           
    3,997 ( 0.02%) .          .          .           void *luaM_malloc_ (lua_State *L, size_t size, int tag) {
    2,855 ( 0.01%) .          .          .             if (size == 0)
        .          .          .          .               return NULL;  
        .          .          .          .             else {
    4,568 ( 0.02%) .          .          .               global_State *g = G(L);
   10,849 ( 0.05%) .          .          .               void *newblock = firsttry(g, NULL, tag, size);
  117,074 ( 0.54%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:l_alloc (571x)
    1,142 ( 0.01%) .          .          .               if (l_unlikely(newblock == NULL)) {
        .          .          .          .                 newblock = tryagain(L, NULL, tag, size);
        .          .          .          .                 if (newblock == NULL)
        .          .          .          .                   luaM_error(L);
        .          .          .          .               }
    7,423 ( 0.03%) .          .          .               g->GCdebt += size;
        .          .          .          .               return newblock;
        .          .          .          .             }
    5,139 ( 0.02%) .          .          .           }
        .          .          .          .           
        .          .          .          .           // root include lobject.c
        .          .          .          .           
        .          .          .          .           //included "locale.h" 
        .          .          .          .           //included "math.h" 
        .          .          .          .           //included "stdarg.h" 
        .          .          .          .           //included "stdio.h" 
        .          .          .          .           //included "stdlib.h" 
        .          .          .          .           //included "string.h" 
        .          .          .          .           
        .          .          .          .           //included "lctype.h" 
        .          .          .          .           
      342 ( 0.00%) .          .          .           int luaO_ceillog2 (unsigned int x) {
        .          .          .          .             static const lu_byte log_2[256] = {  
        .          .          .          .               0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
        .          .          .          .               6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
        .          .          .          .               7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
        .          .          .          .               7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
        .          .          .          .               8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        .          .          .          .               8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        .          .          .          .               8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        .          .          .          .               8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
        .          .          .          .             };
      114 ( 0.00%) .          .          .             int l = 0;
      114 ( 0.00%) .          .          .             x--;
      482 ( 0.00%) .          .          .             while (x >= 256) { l += 8; x >>= 8; }
    2,166 ( 0.01%) .          .          .             return l + log_2[x];
      570 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static lua_Integer intarith (lua_State *L, int op, lua_Integer v1,
       12 ( 0.00%) .          .          .                                                              lua_Integer v2) {
       32 ( 0.00%) .          .          .             switch (op) {
        1 ( 0.00%) .          .          .               case LUA_OPADD: return intop(+, v1, v2);
        .          .          .          .               case LUA_OPSUB:return intop(-, v1, v2);
        .          .          .          .               case LUA_OPMUL:return intop(*, v1, v2);
        .          .          .          .               case LUA_OPMOD: return luaV_mod(L, v1, v2);
        4 ( 0.00%) .          .          .               case LUA_OPIDIV: return luaV_idiv(L, v1, v2);
       36 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_idiv (1x)
        .          .          .          .               case LUA_OPBAND: return intop(&, v1, v2);
        .          .          .          .               case LUA_OPBOR: return intop(|, v1, v2);
        .          .          .          .               case LUA_OPBXOR: return intop(^, v1, v2);
        .          .          .          .               case LUA_OPSHL: return luaV_shiftl(v1, v2);
        .          .          .          .               case LUA_OPSHR: return luaV_shiftl(v1, -v2);
        6 ( 0.00%) .          .          .               case LUA_OPUNM: return intop(-, 0, v1);
        .          .          .          .               case LUA_OPBNOT: return intop(^, ~l_castS2U(0), v1);
        .          .          .          .               default: luai_unreachable(); return 0;
        .          .          .          .             }
       16 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static lua_Number numarith (lua_State *L, int op, lua_Number v1,
        7 ( 0.00%) .          .          .                                                             lua_Number v2) {
       49 ( 0.00%) .          .          .             switch (op) {
        .          .          .          .               case LUA_OPADD: return luai_numadd(L, v1, v2);
        .          .          .          .               case LUA_OPSUB: return luai_numsub(L, v1, v2);
        .          .          .          .               case LUA_OPMUL: return luai_nummul(L, v1, v2);
        .          .          .          .               case LUA_OPDIV: return luai_numdiv(L, v1, v2);
       46 ( 0.00%) .          .          .               case LUA_OPPOW: return luai_numpow(L, v1, v2);
    1,218 ( 0.01%) .          .          .           => /usr/src/debug/glibc/glibc/math/./w_pow_template.c:pow@@GLIBC_2.29 (7x)
      602 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
        .          .          .          .               case LUA_OPIDIV: return luai_numidiv(L, v1, v2);
        .          .          .          .               case LUA_OPUNM: return luai_numunm(L, v1);
        .          .          .          .               case LUA_OPMOD: return luaV_modf(L, v1, v2);
        .          .          .          .               default: luai_unreachable(); return 0;
        .          .          .          .             }
       14 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           int luaO_rawarith (lua_State *L, int op, const TValue *p1, const TValue *p2,
      165 ( 0.00%) .          .          .                              TValue *res) {
       71 ( 0.00%) .          .          .             switch (op) {
        .          .          .          .               case LUA_OPBAND: case LUA_OPBOR: case LUA_OPBXOR:
        .          .          .          .               case LUA_OPSHL: case LUA_OPSHR:
        .          .          .          .               case LUA_OPBNOT: {  
        .          .          .          .                 lua_Integer i1; lua_Integer i2;
        .          .          .          .                 if (tointegerns(p1, &i1) && tointegerns(p2, &i2)) {
        .          .          .          .                   setivalue(res, intarith(L, op, i1, i2));
        .          .          .          .                   return 1;
        .          .          .          .                 }
        .          .          .          .                 else return 0;  
        .          .          .          .               }
        .          .          .          .               case LUA_OPDIV: case LUA_OPPOW: {  
        .          .          .          .                 lua_Number n1; lua_Number n2;
      392 ( 0.00%) .          .          .                 if (tonumberns(p1, n1) && tonumberns(p2, n2)) {
      126 ( 0.00%) .          .          .                   setfltvalue(res, numarith(L, op, n1, n2));
    1,936 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:numarith (7x)
       14 ( 0.00%) .          .          .                   return 1;
        .          .          .          .                 }
        .          .          .          .                 else return 0;  
        .          .          .          .               }
        .          .          .          .               default: {  
        .          .          .          .                 lua_Number n1; lua_Number n2;
       76 ( 0.00%) .          .          .                 if (ttisinteger(p1) && ttisinteger(p2)) {
      152 ( 0.00%) .          .          .                   setivalue(res, intarith(L, op, ivalue(p1), ivalue(p2)));
      107 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:intarith (4x)
        8 ( 0.00%) .          .          .                   return 1;
        .          .          .          .                 }
        .          .          .          .                 else if (tonumberns(p1, n1) && tonumberns(p2, n2)) {
        .          .          .          .                   setfltvalue(res, numarith(L, op, n1, n2));
        .          .          .          .                   return 1;
        .          .          .          .                 }
        .          .          .          .                 else return 0;  
        .          .          .          .               }
        .          .          .          .             }
      121 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaO_arith (lua_State *L, int op, const TValue *p1, const TValue *p2,
        .          .          .          .                            StkId res) {
        .          .          .          .             if (!luaO_rawarith(L, op, p1, p2, s2v(res))) {
        .          .          .          .               
        .          .          .          .               luaT_trybinTM(L, p1, p2, res, cast(TMS, (op - LUA_OPADD) + TM_ADD));
        .          .          .          .             }
        .          .          .          .           }
        .          .          .          .           
       32 ( 0.00%) .          .          .           int luaO_hexavalue (int c) {
      205 ( 0.00%) .          .          .             if (lisdigit(c)) return c - '0';
       84 ( 0.00%) .          .          .             else return (ltolower(c) - 'a') + 10;
       32 ( 0.00%) .          .          .           }
        .          .          .          .           
      924 ( 0.00%) .          .          .           static int isneg (const char **s) {
    2,310 ( 0.01%) .          .          .             if (**s == '-') { (*s)++; return 1; }
    1,386 ( 0.01%) .          .          .             else if (**s == '+') (*s)++;
      231 ( 0.00%) .          .          .             return 0;
      924 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #if !defined(lua_strx2number)
        .          .          .          .           
        .          .          .          .           #define MAXSIGDIG	30
        .          .          .          .           
        .          .          .          .           static lua_Number lua_strx2number (const char *s, char **endptr) {
        .          .          .          .             int dot = lua_getlocaledecpoint();
        .          .          .          .             lua_Number r = l_mathop(0.0);  
-- line 8449 ----------------------------------------
-- line 8494 ----------------------------------------
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #endif
        .          .          .          .           
        .          .          .          .           #if !defined (L_MAXLENNUM)
        .          .          .          .           #define L_MAXLENNUM	200
        .          .          .          .           #endif
        .          .          .          .           
        9 ( 0.00%) .          .          .           static const char *l_str2dloc (const char *s, lua_Number *result, int mode) {
        .          .          .          .             char *endptr;
        5 ( 0.00%) .          .          .             *result = (mode == 'x') ? lua_strx2number(s, &endptr)  
       13 ( 0.00%) .          .          .                                     : lua_str2number(s, &endptr);
      786 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/stdlib/strtod.c:strtod (1x)
      696 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
        2 ( 0.00%) .          .          .             if (endptr == s) return NULL;  
       27 ( 0.00%) .          .          .             while (lisspace(cast_uchar(*endptr))) endptr++;  
        2 ( 0.00%) .          .          .             return (*endptr == '\0') ? endptr : NULL;  
        9 ( 0.00%) .          .          .           }
        .          .          .          .           
       11 ( 0.00%) .          .          .           static const char *l_str2d (const char *s, lua_Number *result) {
        .          .          .          .             const char *endptr;
       11 ( 0.00%) .          .          .             const char *pmode = strpbrk(s, ".xXnN");  
      771 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
       34 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strcspn-sse4.c:__strpbrk_sse42 (1x)
       13 ( 0.00%) .          .          .             int mode = pmode ? ltolower(cast_uchar(*pmode)) : 0;
        2 ( 0.00%) .          .          .             if (mode == 'n')  
        .          .          .          .               return NULL;
        5 ( 0.00%) .          .          .             endptr = l_str2dloc(s, result, mode);  
    1,549 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:l_str2dloc (1x)
        2 ( 0.00%) .          .          .             if (endptr == NULL) {  
        .          .          .          .               char buff[L_MAXLENNUM + 1];
        .          .          .          .               const char *pdot = strchr(s, '.');
        .          .          .          .               if (pdot == NULL || strlen(s) > L_MAXLENNUM)
        .          .          .          .                 return NULL;  
        .          .          .          .               strcpy(buff, s);  
        .          .          .          .               buff[pdot - s] = lua_getlocaledecpoint();  
        .          .          .          .               endptr = l_str2dloc(buff, result, mode);  
        .          .          .          .               if (endptr != NULL)
        .          .          .          .                 endptr = s + (endptr - buff);  
        .          .          .          .             }
        .          .          .          .             return endptr;
       11 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #define MAXBY10		cast(lua_Unsigned, LUA_MAXINTEGER / 10)
        .          .          .          .           #define MAXLASTD	cast_int(LUA_MAXINTEGER % 10)
        .          .          .          .           
    2,079 ( 0.01%) .          .          .           static const char *l_str2int (const char *s, lua_Integer *result) {
        1 ( 0.00%) .          .          .             lua_Unsigned a = 0;
        1 ( 0.00%) .          .          .             int empty = 1;
        .          .          .          .             int neg;
    6,237 ( 0.03%) .          .          .             while (lisspace(cast_uchar(*s))) s++;  
      693 ( 0.00%) .          .          .             neg = isneg(&s);
    5,775 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:isneg (231x)
    1,205 ( 0.01%) .          .          .             if (s[0] == '0' &&
      250 ( 0.00%) .          .          .                 (s[1] == 'x' || s[1] == 'X')) {  
        5 ( 0.00%) .          .          .               s += 2;  
      274 ( 0.00%) .          .          .               for (; lisxdigit(cast_uchar(*s)); s++) {
       40 ( 0.00%) .          .          .                 a = a * 16 + luaO_hexavalue(*s);
      353 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaO_hexavalue (8x)
      698 ( 0.00%) .          .          .                 empty = 0;
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .             else {  
   17,240 ( 0.08%) .          .          .               for (; lisdigit(cast_uchar(*s)); s++) {
    1,532 ( 0.01%) .          .          .                 int d = *s - '0';
    1,149 ( 0.01%) .          .          .                 if (a >= MAXBY10 && (a > MAXBY10 || d > MAXLASTD + neg))  
        .          .          .          .                   return NULL;  
    1,149 ( 0.01%) .          .          .                 a = a * 10 + d;
      383 ( 0.00%) .          .          .                 empty = 0;
        .          .          .          .               }
        .          .          .          .             }
    5,775 ( 0.03%) .          .          .             while (lisspace(cast_uchar(*s))) s++;  
      926 ( 0.00%) .          .          .             if (empty || *s != '\0') return NULL;  
        .          .          .          .             else {
    2,070 ( 0.01%) .          .          .               *result = l_castU2S((neg) ? 0u - a : a);
      230 ( 0.00%) .          .          .               return s;
        .          .          .          .             }
    1,848 ( 0.01%) .          .          .           }
        .          .          .          .           
    2,310 ( 0.01%) .          .          .           size_t luaO_str2num (const char *s, TValue *o) {
        .          .          .          .             lua_Integer i; lua_Number n;
        .          .          .          .             const char *e;
    1,154 ( 0.01%) .          .          .             if ((e = l_str2int(s, &i)) != NULL) {  
   49,913 ( 0.23%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:l_str2int (231x)
    3,220 ( 0.01%) .          .          .               setivalue(o, i);
        .          .          .          .             }
        6 ( 0.00%) .          .          .             else if ((e = l_str2d(s, &n)) != NULL) {  
    2,409 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:l_str2d (1x)
       15 ( 0.00%) .          .          .               setfltvalue(o, n);
        .          .          .          .             }
        .          .          .          .             else
        .          .          .          .               return 0;  
    1,155 ( 0.01%) .          .          .             return (e - s) + 1;  
    2,079 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           int luaO_utf8esc (char *buff, unsigned long x) {
        .          .          .          .             int n = 1;  
        .          .          .          .             lua_assert(x <= 0x7FFFFFFFu);
        .          .          .          .             if (x < 0x80)  
        .          .          .          .               buff[UTF8BUFFSZ - 1] = cast_char(x);
        .          .          .          .             else {  
        .          .          .          .               unsigned int mfb = 0x3f;  
-- line 8586 ----------------------------------------
-- line 8591 ----------------------------------------
        .          .          .          .               } while (x > mfb);  
        .          .          .          .               buff[UTF8BUFFSZ - n] = cast_char((~mfb << 1) | x);  
        .          .          .          .             }
        .          .          .          .             return n;
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #define MAXNUMBER2STR	44
        .          .          .          .           
       28 ( 0.00%) .          .          .           static int tostringbuff (TValue *obj, char *buff) {
        .          .          .          .             int len;
       48 ( 0.00%) .          .          .             lua_assert(ttisnumber(obj));
       24 ( 0.00%) .          .          .             if (ttisinteger(obj))
       68 ( 0.00%) .          .          .               len = lua_integer2str(buff, MAXNUMBER2STR, ivalue(obj));
    2,002 ( 0.01%) .          .          .           => /usr/src/debug/glibc/glibc/stdio-common/snprintf.c:snprintf (4x)
        .          .          .          .             else {
        .          .          .          .               len = lua_number2str(buff, MAXNUMBER2STR, fltvalue(obj));
        .          .          .          .               if (buff[strspn(buff, "-0123456789")] == '\0') {  
        .          .          .          .                 buff[len++] = lua_getlocaledecpoint();
        .          .          .          .                 buff[len++] = '0';  
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .             return len;
       28 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaO_tostring (lua_State *L, TValue *obj) {
        .          .          .          .             char buff[MAXNUMBER2STR];
        .          .          .          .             int len = tostringbuff(obj, buff);
        .          .          .          .             setsvalue(L, obj, luaS_newlstr(L, buff, len));
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #define BUFVFS		200
-- line 8620 ----------------------------------------
-- line 8621 ----------------------------------------
        .          .          .          .           
        .          .          .          .           typedef struct BuffFS {
        .          .          .          .             lua_State *L;
        .          .          .          .             int pushed;  
        .          .          .          .             int blen;  
        .          .          .          .             char space[BUFVFS];  
        .          .          .          .           } BuffFS;
        .          .          .          .           
      100 ( 0.00%) .          .          .           static void pushstr (BuffFS *buff, const char *str, size_t l) {
       50 ( 0.00%) .          .          .             lua_State *L = buff->L;
    1,130 ( 0.01%) .          .          .             setsvalue2s(L, L->top, luaS_newlstr(L, str, l));
    9,627 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_newlstr (10x)
      140 ( 0.00%) .          .          .             L->top++;  
      160 ( 0.00%) .          .          .             buff->pushed++;
       70 ( 0.00%) .          .          .             luaV_concat(L, buff->pushed);  
      250 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_concat (10x)
       50 ( 0.00%) .          .          .             buff->pushed = 1;
       80 ( 0.00%) .          .          .           }
        .          .          .          .           
       40 ( 0.00%) .          .          .           static void clearbuff (BuffFS *buff) {
      190 ( 0.00%) .          .          .             pushstr(buff, buff->space, buff->blen);  
   11,657 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:pushstr (10x)
       50 ( 0.00%) .          .          .             buff->blen = 0;  
       40 ( 0.00%) .          .          .           }
        .          .          .          .           
      322 ( 0.00%) .          .          .           static char *getbuff (BuffFS *buff, int sz) {
      552 ( 0.00%) .          .          .             lua_assert(buff->blen <= BUFVFS); lua_assert(sz <= BUFVFS);
      460 ( 0.00%) .          .          .             if (sz > BUFVFS - buff->blen)  
        .          .          .          .               clearbuff(buff);
      874 ( 0.00%) .          .          .             return buff->space + buff->blen;
      276 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #define addsize(b,sz)	((b)->blen += (sz))
        .          .          .          .           
      336 ( 0.00%) .          .          .           static void addstr2buff (BuffFS *buff, const char *str, size_t slen) {
       84 ( 0.00%) .          .          .             if (slen <= BUFVFS) {  
      168 ( 0.00%) .          .          .               char *bf = getbuff(buff, cast_int(slen));
    2,268 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getbuff (42x)
      378 ( 0.00%) .          .          .               memcpy(bf, str, slen);  
      559 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:memcpy@GLIBC_2.2.5 (42x)
      630 ( 0.00%) .          .          .               addsize(buff, cast_int(slen));
        .          .          .          .             }
        .          .          .          .             else {  
        .          .          .          .               clearbuff(buff);  
        .          .          .          .               pushstr(buff, str, slen);  
        .          .          .          .             }
      252 ( 0.00%) .          .          .           }
        .          .          .          .           
       20 ( 0.00%) .          .          .           static void addnum2buff (BuffFS *buff, TValue *num) {
       12 ( 0.00%) .          .          .             char *numbuff = getbuff(buff, MAXNUMBER2STR);
      216 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getbuff (4x)
       12 ( 0.00%) .          .          .             int len = tostringbuff(num, numbuff);  
    2,198 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:tostringbuff (4x)
       64 ( 0.00%) .          .          .             addsize(buff, len);
       16 ( 0.00%) .          .          .           }
        .          .          .          .           
      130 ( 0.00%) .          .          .           const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
        .          .          .          .             BuffFS buff;  
        .          .          .          .             const char *e;  
       20 ( 0.00%) .          .          .             buff.pushed = buff.blen = 0;
       10 ( 0.00%) .          .          .             buff.L = L;
      262 ( 0.00%) .          .          .             while ((e = strchr(fmt, '%')) != NULL) {
      744 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strchr-sse2.S:__strchr_sse2 (28x)
       90 ( 0.00%) .          .          .               addstr2buff(&buff, fmt, e - fmt);  
    2,009 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:addstr2buff (18x)
      396 ( 0.00%) .          .          .               switch (*(e + 1)) {  
        .          .          .          .                 case 's': {  
       84 ( 0.00%) .          .          .                   const char *s = va_arg(argp, char *);
       28 ( 0.00%) .          .          .                   if (s == NULL) s = "(null)";
       98 ( 0.00%) .          .          .                   addstr2buff(&buff, s, strlen(s));
    1,556 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:addstr2buff (14x)
      256 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strlen-sse2.S:__strlen_sse2 (14x)
        .          .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case 'c': {  
        .          .          .          .                   char c = cast_uchar(va_arg(argp, int));
        .          .          .          .                   addstr2buff(&buff, &c, sizeof(char));
        .          .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case 'd': {  
        .          .          .          .                   TValue num;
       32 ( 0.00%) .          .          .                   setivalue(&num, va_arg(argp, int));
       12 ( 0.00%) .          .          .                   addnum2buff(&buff, &num);
    2,538 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:addnum2buff (4x)
        4 ( 0.00%) .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case 'I': {  
        .          .          .          .                   TValue num;
        .          .          .          .                   setivalue(&num, cast(lua_Integer, va_arg(argp, l_uacInt)));
        .          .          .          .                   addnum2buff(&buff, &num);
        .          .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case 'f': {  
-- line 8701 ----------------------------------------
-- line 8722 ----------------------------------------
        .          .          .          .                   addstr2buff(&buff, "%", 1);
        .          .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 default: {
        .          .          .          .                   luaG_runerror(L, "invalid option '%%%c' to 'lua_pushfstring'",
        .          .          .          .                                    *(e + 1));
        .          .          .          .                 }
        .          .          .          .               }
       72 ( 0.00%) .          .          .               fmt = e + 2;  
        .          .          .          .             }
      100 ( 0.00%) .          .          .             addstr2buff(&buff, fmt, strlen(fmt));  
    1,110 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:addstr2buff (10x)
      170 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strlen-sse2.S:__strlen_sse2 (10x)
       20 ( 0.00%) .          .          .             clearbuff(&buff);  
   11,977 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:clearbuff (10x)
       20 ( 0.00%) .          .          .             lua_assert(buff.pushed == 1);
      630 ( 0.00%) .          .          .             return svalue(s2v(L->top - 1));
      110 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           const char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {
        .          .          .          .             const char *msg;
        .          .          .          .             va_list argp;
        .          .          .          .             va_start(argp, fmt);
        .          .          .          .             msg = luaO_pushvfstring(L, fmt, argp);
        .          .          .          .             va_end(argp);
        .          .          .          .             return msg;
-- line 8744 ----------------------------------------
-- line 8745 ----------------------------------------
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #define RETS	"..."
        .          .          .          .           #define PRE	"[string \""
        .          .          .          .           #define POS	"\"]"
        .          .          .          .           
        .          .          .          .           #define addstr(a,b,l)	( memcpy(a,b,(l) * sizeof(char)), a += (l) )
        .          .          .          .           
    2,720 ( 0.01%) .          .          .           void luaO_chunkid (char *out, const char *source, size_t srclen) {
        .          .          .          .             size_t bufflen = LUA_IDSIZE;  
    1,700 ( 0.01%) .          .          .             if (*source == '=') {  
      134 ( 0.00%) .          .          .               if (srclen <= bufflen)  
      804 ( 0.00%) .          .          .                 memcpy(out, source + 1, srclen * sizeof(char));
      871 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:memcpy@GLIBC_2.2.5 (67x)
        .          .          .          .               else {  
        .          .          .          .                 addstr(out, source + 1, bufflen - 1);
        .          .          .          .                 *out = '\0';
        .          .          .          .               }
        .          .          .          .             }
      546 ( 0.00%) .          .          .             else if (*source == '@') {  
      546 ( 0.00%) .          .          .               if (srclen <= bufflen)  
    3,276 ( 0.02%) .          .          .                 memcpy(out, source + 1, srclen * sizeof(char));
    3,003 ( 0.01%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:memcpy@GLIBC_2.2.5 (273x)
        .          .          .          .               else {  
        .          .          .          .                 addstr(out, RETS, LL(RETS));
        .          .          .          .                 bufflen -= LL(RETS);
        .          .          .          .                 memcpy(out, source + 1 + srclen - bufflen, bufflen * sizeof(char));
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .             else {  
        .          .          .          .               const char *nl = strchr(source, '\n');  
-- line 8773 ----------------------------------------
-- line 8779 ----------------------------------------
        .          .          .          .               else {
        .          .          .          .                 if (nl != NULL) srclen = nl - source;  
        .          .          .          .                 if (srclen > bufflen) srclen = bufflen;
        .          .          .          .                 addstr(out, source, srclen);
        .          .          .          .                 addstr(out, RETS, LL(RETS));
        .          .          .          .               }
        .          .          .          .               memcpy(out, POS, (LL(POS) + 1) * sizeof(char));
        .          .          .          .             }
    2,040 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           // root include lopcodes.c
        .          .          .          .           
        .          .          .          .           // root include lparser.c
        .          .          .          .           
        .          .          .          .           //included "limits.h" 
        .          .          .          .           //included "string.h" 
        .          .          .          .           
-- line 8795 ----------------------------------------
-- line 8825 ----------------------------------------
        .          .          .          .                                 ? "main function"
        .          .          .          .                                 : luaO_pushfstring(L, "function at line %d", line);
        .          .          .          .             msg = luaO_pushfstring(L, "too many %s (limit is %d) in %s",
        .          .          .          .                                        what, limit, where);
        .          .          .          .             luaX_syntaxerror(fs->ls, msg);
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           static void checklimit (FuncState *fs, int v, int l, const char *what) {
    1,605 ( 0.01%) .          .          .             if (v > l) errorlimit(fs, l, what);
        .          .          .          .           }
        .          .          .          .           
   13,445 ( 0.06%) .          .          .           static int testnext (LexState *ls, int c) {
   24,201 ( 0.11%) .          .          .             if (ls->t.token == c) {
    2,264 ( 0.01%) .          .          .               luaX_next(ls);
2,236,761 (10.32%) 1 ( 0.19%) 24,904 ( 0.00%) 22,950 ( 0.00%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (1,132x)
    2,264 ( 0.01%) .          .          .               return 1;
        .          .          .          .             }
    1,557 ( 0.01%) .          .          .             else return 0;
   10,756 ( 0.05%) .          .          .           }
        .          .          .          .           
   11,545 ( 0.05%) .          .          .           static void check (LexState *ls, int c) {
   20,781 ( 0.10%) .          .          .             if (ls->t.token != c)
        .          .          .          .               error_expected(ls, c);
    9,236 ( 0.04%) .          .          .           }
        .          .          .          .           
    1,452 ( 0.01%) .          .          .           static void checknext (LexState *ls, int c) {
      726 ( 0.00%) .          .          .             check(ls, c);
   13,068 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check (726x)
    1,452 ( 0.01%) .          .          .             luaX_next(ls);
  918,073 ( 4.24%) 2 ( 0.37%) 39,203 ( 0.01%) 36,396 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (726x)
    1,452 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #define check_condition(ls,c,msg)	{ if (!(c)) luaX_syntaxerror(ls, msg); }
        .          .          .          .           
    6,957 ( 0.03%) .          .          .           static void check_match (LexState *ls, int what, int who, int where) {
    2,319 ( 0.01%) .          .          .             if (l_unlikely(!testnext(ls, what))) {
1,445,919 ( 6.67%) 1 ( 0.19%) 24,904 ( 0.00%) 22,950 ( 0.00%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:testnext (773x)
        .          .          .          .               if (where == ls->linenumber)  
        .          .          .          .                 error_expected(ls, what);  
        .          .          .          .               else {
        .          .          .          .                 luaX_syntaxerror(ls, luaO_pushfstring(ls->L,
        .          .          .          .                        "%s expected (to close %s at line %d)",
        .          .          .          .                         luaX_token2str(ls, what), luaX_token2str(ls, who), where));
        .          .          .          .               }
        .          .          .          .             }
    4,638 ( 0.02%) .          .          .           }
        .          .          .          .           
    6,324 ( 0.03%) .          .          .           static TString *str_checkname (LexState *ls) {
        .          .          .          .             TString *ts;
    3,162 ( 0.01%) .          .          .             check(ls, TK_NAME);
   28,458 ( 0.13%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check (1,581x)
   12,648 ( 0.06%) .          .          .             ts = ls->t.seminfo.ts;
    3,162 ( 0.01%) .          .          .             luaX_next(ls);
  619,846 ( 2.86%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (1,581x)
        .          .          .          .             return ts;
    7,905 ( 0.04%) .          .          .           }
        .          .          .          .           
   14,598 ( 0.07%) .          .          .           static void init_exp (expdesc *e, expkind k, int i) {
   48,660 ( 0.22%) .          .          .             e->f = e->t = NO_JUMP;
   12,165 ( 0.06%) .          .          .             e->k = k;
   12,165 ( 0.06%) .          .          .             e->u.info = i;
    9,732 ( 0.04%) .          .          .           }
        .          .          .          .           
    4,980 ( 0.02%) .          .          .           static void codestring (expdesc *e, TString *s) {
   19,920 ( 0.09%) .          .          .             e->f = e->t = NO_JUMP;
    4,980 ( 0.02%) .          .          .             e->k = VKSTR;
    4,980 ( 0.02%) .          .          .             e->u.strval = s;
    3,984 ( 0.02%) .          .          .           }
        .          .          .          .           
      358 ( 0.00%) .          .          .           static void codename (LexState *ls, expdesc *e) {
      716 ( 0.00%) .          .          .             codestring(e, str_checkname(ls));
   61,659 ( 0.28%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:str_checkname (179x)
    6,981 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codestring (179x)
      358 ( 0.00%) .          .          .           }
        .          .          .          .           
    3,930 ( 0.02%) .          .          .           static int registerlocalvar (LexState *ls, FuncState *fs, TString *varname) {
    1,965 ( 0.01%) .          .          .             Proto *f = fs->f;
    3,144 ( 0.01%) .          .          .             int oldsize = f->sizelocvars;
   17,685 ( 0.08%) .          .          .             luaM_growvector(ls->L, f->locvars, fs->ndebugvars, f->sizelocvars,
   30,886 ( 0.14%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_growaux_ (393x)
        .          .          .          .                             LocVar, SHRT_MAX, "local variables");
    6,999 ( 0.03%) .          .          .             while (oldsize < f->sizelocvars)
   14,160 ( 0.07%) .          .          .               f->locvars[oldsize++].varname = NULL;
    8,253 ( 0.04%) .          .          .             f->locvars[fs->ndebugvars].varname = varname;
   11,397 ( 0.05%) .          .          .             f->locvars[fs->ndebugvars].startpc = fs->pc;
    2,358 ( 0.01%) .          .          .             luaC_objbarrier(ls->L, f, varname);
    4,716 ( 0.02%) .          .          .             return fs->ndebugvars++;
    3,144 ( 0.01%) .          .          .           }
        .          .          .          .           
    3,537 ( 0.02%) .          .          .           static int new_localvar (LexState *ls, TString *name) {
    3,144 ( 0.01%) .          .          .             lua_State *L = ls->L;
    1,965 ( 0.01%) .          .          .             FuncState *fs = ls->fs;
    3,144 ( 0.01%) .          .          .             Dyndata *dyd = ls->dyd;
        .          .          .          .             Vardesc *var;
   10,611 ( 0.05%) .          .          .             checklimit(fs, dyd->actvar.n + 1 - fs->firstlocal,
    1,179 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checklimit (393x)
        .          .          .          .                            MAXVARS, "local variables");
   12,969 ( 0.06%) .          .          .             luaM_growvector(L, dyd->actvar.arr, dyd->actvar.n + 1,
   16,979 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_growaux_ (393x)
        .          .          .          .                             dyd->actvar.size, Vardesc, USHRT_MAX, "local variables");
    9,432 ( 0.04%) .          .          .             var = &dyd->actvar.arr[dyd->actvar.n++];
    3,144 ( 0.01%) .          .          .             var->vd.kind = VDKREG;  
    3,144 ( 0.01%) .          .          .             var->vd.name = name;
    6,288 ( 0.03%) .          .          .             return dyd->actvar.n - 1 - fs->firstlocal;
    3,537 ( 0.02%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #define new_localvarliteral(ls,v)     new_localvar(ls,        luaX_newstring(ls, "" v, (sizeof(v)/sizeof(char)) - 1));
        .          .          .          .           
  133,960 ( 0.62%) .          .          .           static Vardesc *getlocalvardesc (FuncState *fs, int vidx) {
1,071,680 ( 4.94%) .          .          .             return &fs->ls->dyd->actvar.arr[fs->firstlocal + vidx];
  107,168 ( 0.49%) .          .          .           }
        .          .          .          .           
   24,542 ( 0.11%) .          .          .           static int reglevel (FuncState *fs, int nvar) {
   24,542 ( 0.11%) .          .          .             while (nvar-- > 0) {
   12,836 ( 0.06%) .          .          .               Vardesc *vd = getlocalvardesc(fs, nvar);  
  157,241 ( 0.73%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getlocalvardesc (3,209x)
   28,881 ( 0.13%) .          .          .               if (vd->vd.kind != RDKCTC)  
   41,717 ( 0.19%) .          .          .                 return vd->vd.ridx + 1;
        .          .          .          .             }
      297 ( 0.00%) .          .          .             return 0;  
   21,036 ( 0.10%) .          .          .           }
        .          .          .          .           
    6,470 ( 0.03%) .          .          .           int luaY_nvarstack (FuncState *fs) {
   32,350 ( 0.15%) .          .          .             return reglevel(fs, fs->nactvar);
  289,565 ( 1.34%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reglevel (3,235x)
    6,470 ( 0.03%) .          .          .           }
        .          .          .          .           
    1,624 ( 0.01%) .          .          .           static LocVar *localdebuginfo (FuncState *fs, int vidx) {
      812 ( 0.00%) .          .          .             Vardesc *vd = getlocalvardesc(fs,  vidx);
   19,894 ( 0.09%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getlocalvardesc (406x)
    3,654 ( 0.02%) .          .          .             if (vd->vd.kind == RDKCTC)
        .          .          .          .               return NULL;  
        .          .          .          .             else {
    3,248 ( 0.01%) .          .          .               int idx = vd->vd.pidx;
    3,654 ( 0.02%) .          .          .               lua_assert(idx < fs->ndebugvars);
    8,120 ( 0.04%) .          .          .               return &fs->f->locvars[idx];
        .          .          .          .             }
    1,624 ( 0.01%) .          .          .           }
        .          .          .          .           
    3,228 ( 0.01%) .          .          .           static void init_var (FuncState *fs, expdesc *e, int vidx) {
   10,760 ( 0.05%) .          .          .             e->f = e->t = NO_JUMP;
    2,690 ( 0.01%) .          .          .             e->k = VLOCAL;
    2,690 ( 0.01%) .          .          .             e->u.var.vidx = vidx;
    9,146 ( 0.04%) .          .          .             e->u.var.ridx = getlocalvardesc(fs, vidx)->vd.ridx;
   26,362 ( 0.12%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getlocalvardesc (538x)
    2,152 ( 0.01%) .          .          .           }
        .          .          .          .           
      950 ( 0.00%) .          .          .           static void check_readonly (LexState *ls, expdesc *e) {
    1,520 ( 0.01%) .          .          .             FuncState *fs = ls->fs;
        .          .          .          .             TString *varname = NULL;  
    2,026 ( 0.01%) .          .          .             switch (e->k) {
        .          .          .          .               case VCONST: {
        .          .          .          .                 varname = ls->dyd->actvar.arr[e->u.info].vd.name;
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VLOCAL: {
      770 ( 0.00%) .          .          .                 Vardesc *vardesc = getlocalvardesc(fs, e->u.var.vidx);
    3,430 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getlocalvardesc (70x)
      630 ( 0.00%) .          .          .                 if (vardesc->vd.kind != VDKREG)  
        .          .          .          .                   varname = vardesc->vd.name;
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case VUPVAL: {
      416 ( 0.00%) .          .          .                 Upvaldesc *up = &fs->f->upvalues[e->u.info];
      144 ( 0.00%) .          .          .                 if (up->kind != VDKREG)
        .          .          .          .                   varname = up->name;
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default:
        .          .          .          .                 return;  
        .          .          .          .             }
        .          .          .          .             if (varname) {
        .          .          .          .               const char *msg = luaO_pushfstring(ls->L,
        .          .          .          .                  "attempt to assign to const variable '%s'", getstr(varname));
        .          .          .          .               luaK_semerror(ls, msg);  
        .          .          .          .             }
      760 ( 0.00%) .          .          .           }
        .          .          .          .           
    2,583 ( 0.01%) .          .          .           static void adjustlocalvars (LexState *ls, int nvars) {
    2,296 ( 0.01%) .          .          .             FuncState *fs = ls->fs;
      861 ( 0.00%) .          .          .             int reglevel = luaY_nvarstack(fs);
   26,621 ( 0.12%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaY_nvarstack (287x)
        .          .          .          .             int i;
    4,186 ( 0.02%) .          .          .             for (i = 0; i < nvars; i++) {
    5,895 ( 0.03%) .          .          .               int vidx = fs->nactvar++;
    1,179 ( 0.01%) .          .          .               Vardesc *var = getlocalvardesc(fs, vidx);
   19,257 ( 0.09%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getlocalvardesc (393x)
    4,716 ( 0.02%) .          .          .               var->vd.ridx = reglevel++;
    6,681 ( 0.03%) .          .          .               var->vd.pidx = registerlocalvar(ls, fs, var->vd.name);
  108,637 ( 0.50%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:registerlocalvar (393x)
        .          .          .          .             }
    2,296 ( 0.01%) .          .          .           }
        .          .          .          .           
    2,421 ( 0.01%) .          .          .           static void removevars (FuncState *fs, int tolevel) {
   12,912 ( 0.06%) .          .          .             fs->ls->dyd->actvar.n -= (fs->nactvar - tolevel);
    5,296 ( 0.02%) .          .          .             while (fs->nactvar > tolevel) {
    7,074 ( 0.03%) .          .          .               LocVar *var = localdebuginfo(fs, --fs->nactvar);
   41,265 ( 0.19%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:localdebuginfo (393x)
      786 ( 0.00%) .          .          .               if (var)  
    5,502 ( 0.03%) .          .          .                 var->endpc = fs->pc;
        .          .          .          .             }
    2,152 ( 0.01%) .          .          .           }
        .          .          .          .           
    9,569 ( 0.04%) .          .          .           static int searchupvalue (FuncState *fs, TString *name) {
        .          .          .          .             int i;
   17,771 ( 0.08%) .          .          .             Upvaldesc *up = fs->f->upvalues;
   29,074 ( 0.13%) .          .          .             for (i = 0; i < fs->nups; i++) {
   18,300 ( 0.08%) .          .          .               if (eqstr(up[i].name, name)) return i;
        .          .          .          .             }
      747 ( 0.00%) .          .          .             return -1;  
    9,569 ( 0.04%) .          .          .           }
        .          .          .          .           
      744 ( 0.00%) .          .          .           static Upvaldesc *allocupvalue (FuncState *fs) {
      465 ( 0.00%) .          .          .             Proto *f = fs->f;
      744 ( 0.00%) .          .          .             int oldsize = f->sizeupvalues;
    1,488 ( 0.01%) .          .          .             checklimit(fs, fs->nups + 1, MAXUPVAL, "upvalues");
      279 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checklimit (93x)
    4,278 ( 0.02%) .          .          .             luaM_growvector(fs->ls->L, f->upvalues, fs->nups, f->sizeupvalues,
   18,320 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_growaux_ (93x)
        .          .          .          .                             Upvaldesc, MAXUPVAL, "upvalues");
    1,827 ( 0.01%) .          .          .             while (oldsize < f->sizeupvalues)
    3,920 ( 0.02%) .          .          .               f->upvalues[oldsize++].name = NULL;
    2,046 ( 0.01%) .          .          .             return &f->upvalues[fs->nups++];
      744 ( 0.00%) .          .          .           }
        .          .          .          .           
      910 ( 0.00%) .          .          .           static int newupvalue (FuncState *fs, TString *name, expdesc *v) {
      182 ( 0.00%) .          .          .             Upvaldesc *up = allocupvalue(fs);
   33,651 ( 0.16%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:allocupvalue (91x)
      728 ( 0.00%) .          .          .             FuncState *prev = fs->prev;
      546 ( 0.00%) .          .          .             if (v->k == VLOCAL) {
      512 ( 0.00%) .          .          .               up->instack = 1;
    1,024 ( 0.00%) .          .          .               up->idx = v->u.var.ridx;
    1,728 ( 0.01%) .          .          .               up->kind = getlocalvardesc(prev, v->u.var.vidx)->vd.kind;
    3,136 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getlocalvardesc (64x)
    1,088 ( 0.01%) .          .          .               lua_assert(eqstr(name, getlocalvardesc(prev, v->u.var.vidx)->vd.name));
    3,136 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getlocalvardesc (64x)
        .          .          .          .             }
        .          .          .          .             else {
      216 ( 0.00%) .          .          .               up->instack = 0;
      432 ( 0.00%) .          .          .               up->idx = cast_byte(v->u.info);
    1,107 ( 0.01%) .          .          .               up->kind = prev->f->upvalues[v->u.info].kind;
      783 ( 0.00%) .          .          .               lua_assert(eqstr(name, prev->f->upvalues[v->u.info].name));
        .          .          .          .             }
      455 ( 0.00%) .          .          .             up->name = name;
    1,274 ( 0.01%) .          .          .             luaC_objbarrier(fs->ls->L, fs->f, name);
    1,001 ( 0.00%) .          .          .             return fs->nups - 1;
      819 ( 0.00%) .          .          .           }
        .          .          .          .           
   15,240 ( 0.07%) .          .          .           static int searchvar (FuncState *fs, TString *n, expdesc *var) {
        .          .          .          .             int i;
  152,121 ( 0.70%) .          .          .             for (i = cast_int(fs->nactvar) - 1; i >= 0; i--) {
   87,056 ( 0.40%) .          .          .               Vardesc *vd = getlocalvardesc(fs, i);
1,066,436 ( 4.92%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getlocalvardesc (21,764x)
  195,876 ( 0.90%) .          .          .               if (eqstr(n, vd->vd.name)) {  
    3,228 ( 0.01%) .          .          .                 if (vd->vd.kind == RDKCTC)  
        .          .          .          .                   init_exp(var, VCONST, fs->firstlocal + i);
        .          .          .          .                 else  
    2,152 ( 0.01%) .          .          .                   init_var(fs, var, i);
   57,028 ( 0.26%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:init_var (538x)
    3,228 ( 0.01%) .          .          .                 return var->k;
        .          .          .          .               }
        .          .          .          .             }
    1,367 ( 0.01%) .          .          .             return -1;  
   11,430 ( 0.05%) .          .          .           }
        .          .          .          .           
      320 ( 0.00%) .          .          .           static void markupval (FuncState *fs, int level) {
      512 ( 0.00%) .          .          .             BlockCnt *bl = fs->bl;
      977 ( 0.00%) .          .          .             while (bl->nactvar > level)
      114 ( 0.00%) .          .          .               bl = bl->previous;
      576 ( 0.00%) .          .          .             bl->upval = 1;
      512 ( 0.00%) .          .          .             fs->needclose = 1;
      256 ( 0.00%) .          .          .           }
        .          .          .          .           
       40 ( 0.00%) .          .          .           static void marktobeclosed (FuncState *fs) {
       80 ( 0.00%) .          .          .             BlockCnt *bl = fs->bl;
       80 ( 0.00%) .          .          .             bl->upval = 1;
       80 ( 0.00%) .          .          .             bl->insidetbc = 1;
       80 ( 0.00%) .          .          .             fs->needclose = 1;
       40 ( 0.00%) .          .          .           }
        .          .          .          .           
   14,886 ( 0.07%) .          .          .           static void singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {
   10,677 ( 0.05%) .          .          .             if (fs == NULL)  
    2,880 ( 0.01%) .          .          .               init_exp(var, VVOID, 0);  
   23,040 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:init_exp (576x)
        .          .          .          .             else {
    1,905 ( 0.01%) .          .          .               int v = searchvar(fs, n, var);  
1,436,882 ( 6.63%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:searchvar (1,734x)
    3,810 ( 0.02%) .          .          .               if (v >= 0) {  
    3,228 ( 0.01%) .          .          .                 if (v == VLOCAL && !base)
      704 ( 0.00%) .          .          .                   markupval(fs, var->u.var.vidx);  
    3,267 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:markupval (64x)
        .          .          .          .               }
        .          .          .          .               else {  
    4,101 ( 0.02%) .          .          .                 int idx = searchupvalue(fs, n);  
   78,194 ( 0.36%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:searchupvalue (1,260x)
    2,734 ( 0.01%) .          .          .                 if (idx < 0) {  
    8,964 ( 0.04%) .          .          .                   singlevaraux(fs->prev, n, var, 0);  
  213,024 ( 0.98%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:singlevaraux'2 (662x)
    5,976 ( 0.03%) .          .          .                   if (var->k == VLOCAL || var->k == VUPVAL)  
      455 ( 0.00%) .          .          .                     idx  = newupvalue(fs, n, var);  
   50,054 ( 0.23%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:newupvalue (86x)
        .          .          .          .                   else  
        .          .          .          .                     return;  
        .          .          .          .                 }
    3,555 ( 0.02%) .          .          .                 init_exp(var, VUPVAL, idx);  
   27,360 ( 0.13%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:init_exp (684x)
        .          .          .          .               }
        .          .          .          .             }
   14,886 ( 0.07%) .          .          .           }
        .          .          .          .           
   11,580 ( 0.05%) .          .          .           static void singlevar (LexState *ls, expdesc *var) {
    2,316 ( 0.01%) .          .          .             TString *varname = str_checkname(ls);
  531,341 ( 2.45%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:str_checkname (1,158x)
    9,264 ( 0.04%) .          .          .             FuncState *fs = ls->fs;
    5,790 ( 0.03%) .          .          .             singlevaraux(fs, varname, var, 1);
1,129,138 ( 5.21%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:singlevaraux (1,158x)
    6,948 ( 0.03%) .          .          .             if (var->k == VVOID) {  
        .          .          .          .               expdesc key;
    6,912 ( 0.03%) .          .          .               singlevaraux(fs, ls->envn, var, 1);  
  737,290 ( 3.40%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:singlevaraux (576x)
    3,456 ( 0.02%) .          .          .               lua_assert(var->k != VVOID);  
    2,304 ( 0.01%) .          .          .               codestring(&key, varname);  
   22,464 ( 0.10%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codestring (576x)
    2,304 ( 0.01%) .          .          .               luaK_indexed(fs, var, &key);  
  536,839 ( 2.48%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_indexed (576x)
        .          .          .          .             }
   10,998 ( 0.05%) .          .          .           }
        .          .          .          .           
    1,278 ( 0.01%) .          .          .           static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {
    1,136 ( 0.01%) .          .          .             FuncState *fs = ls->fs;
      568 ( 0.00%) .          .          .             int needed = nvars - nexps;  
    1,136 ( 0.01%) .          .          .             if (hasmultret(e->k)) {  
      159 ( 0.00%) .          .          .               int extra = needed + 1;  
      106 ( 0.00%) .          .          .               if (extra < 0)
        .          .          .          .                 extra = 0;
      159 ( 0.00%) .          .          .               luaK_setreturns(fs, e, extra);  
    3,445 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_setreturns (53x)
        .          .          .          .             }
        .          .          .          .             else {
      534 ( 0.00%) .          .          .               if (e->k != VVOID)  
      320 ( 0.00%) .          .          .                 luaK_exp2nextreg(fs, e);  
   48,466 ( 0.22%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2nextreg (80x)
      178 ( 0.00%) .          .          .               if (needed > 0)  
      180 ( 0.00%) .          .          .                 luaK_nil(fs, fs->freereg, needed);  
    6,307 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_nil (15x)
        .          .          .          .             }
      136 ( 0.00%) .          .          .             if (needed > 0)
      124 ( 0.00%) .          .          .               luaK_reserveregs(fs, needed);  
    1,842 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_reserveregs (31x)
        .          .          .          .             else  
    1,443 ( 0.01%) .          .          .               fs->freereg += needed;  
      852 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #define enterlevel(ls)	luaE_incCstack(ls->L)
        .          .          .          .           
        .          .          .          .           #define leavelevel(ls) ((ls)->L->nCcalls--)
        .          .          .          .           
        .          .          .          .           static l_noret jumpscopeerror (LexState *ls, Labeldesc *gt) {
        .          .          .          .             const char *varname = getstr(getlocalvardesc(ls->fs, gt->nactvar)->vd.name);
        .          .          .          .             const char *msg = "<goto %s> at line %d jumps into the scope of local '%s'";
-- line 9141 ----------------------------------------
-- line 9164 ----------------------------------------
        .          .          .          .               Labeldesc *lb = &dyd->label.arr[i];
        .          .          .          .               if (eqstr(lb->name, name))  
        .          .          .          .                 return lb;
        .          .          .          .             }
        .          .          .          .             return NULL;  
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           static int newlabelentry (LexState *ls, Labellist *l, TString *name,
      708 ( 0.00%) .          .          .                                     int line, int pc) {
      472 ( 0.00%) .          .          .             int n = l->n;
    2,183 ( 0.01%) .          .          .             luaM_growvector(ls->L, l->arr, n, l->size,
    2,239 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_growaux_ (59x)
        .          .          .          .                             Labeldesc, SHRT_MAX, "labels/gotos");
      944 ( 0.00%) .          .          .             l->arr[n].name = name;
    1,121 ( 0.01%) .          .          .             l->arr[n].line = line;
    1,888 ( 0.01%) .          .          .             l->arr[n].nactvar = ls->fs->nactvar;
    1,062 ( 0.00%) .          .          .             l->arr[n].close = 0;
    1,121 ( 0.01%) .          .          .             l->arr[n].pc = pc;
      472 ( 0.00%) .          .          .             l->n = n + 1;
        .          .          .          .             return n;
      531 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static int newgotoentry (LexState *ls, TString *name, int line, int pc) {
        .          .          .          .             return newlabelentry(ls, &ls->dyd->gt, name, line, pc);
        .          .          .          .           }
        .          .          .          .           
      531 ( 0.00%) .          .          .           static int solvegotos (LexState *ls, Labeldesc *lb) {
    1,239 ( 0.01%) .          .          .             Labellist *gl = &ls->dyd->gt;
    1,357 ( 0.01%) .          .          .             int i = ls->fs->bl->firstgoto;
       59 ( 0.00%) .          .          .             int needsclose = 0;
      649 ( 0.00%) .          .          .             while (i < gl->n) {
        .          .          .          .               if (eqstr(gl->arr[i].name, lb->name)) {
        .          .          .          .                 needsclose |= gl->arr[i].close;
        .          .          .          .                 solvegoto(ls, i, lb);  
        .          .          .          .               }
        .          .          .          .               else
        .          .          .          .                 i++;
        .          .          .          .             }
        .          .          .          .             return needsclose;
      531 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static int createlabel (LexState *ls, TString *name, int line,
      649 ( 0.00%) .          .          .                                   int last) {
      472 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
      944 ( 0.00%) .          .          .             Labellist *ll = &ls->dyd->label;
      531 ( 0.00%) .          .          .             int l = newlabelentry(ls, ll, name, line, luaK_getlabel(fs));
   12,741 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:newlabelentry (59x)
    1,711 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_getlabel (59x)
      118 ( 0.00%) .          .          .             if (last) {  
        .          .          .          .               
        .          .          .          .               ll->arr[l].nactvar = fs->bl->nactvar;
        .          .          .          .             }
    1,003 ( 0.00%) .          .          .             if (solvegotos(ls, &ll->arr[l])) {  
    4,366 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:solvegotos (59x)
        .          .          .          .               luaK_codeABC(fs, OP_CLOSE, luaY_nvarstack(fs), 0, 0);
        .          .          .          .               return 1;
        .          .          .          .             }
        .          .          .          .             return 0;
      472 ( 0.00%) .          .          .           }
        .          .          .          .           
    1,908 ( 0.01%) .          .          .           static void movegotosout (FuncState *fs, BlockCnt *bl) {
        .          .          .          .             int i;
    5,512 ( 0.03%) .          .          .             Labellist *gl = &fs->ls->dyd->gt;
        .          .          .          .             
    3,816 ( 0.02%) .          .          .             for (i = bl->firstgoto; i < gl->n; i++) {  
        .          .          .          .               Labeldesc *gt = &gl->arr[i];
        .          .          .          .               
        .          .          .          .               if (reglevel(fs, gt->nactvar) > reglevel(fs, bl->nactvar))
        .          .          .          .                 gt->close |= bl->upval;  
        .          .          .          .               gt->nactvar = bl->nactvar;  
        .          .          .          .             }
    1,696 ( 0.01%) .          .          .           }
        .          .          .          .           
    1,614 ( 0.01%) .          .          .           static void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isloop) {
    2,152 ( 0.01%) .          .          .             bl->isloop = isloop;
    3,497 ( 0.02%) .          .          .             bl->nactvar = fs->nactvar;
    6,994 ( 0.03%) .          .          .             bl->firstlabel = fs->ls->dyd->label.n;
    6,994 ( 0.03%) .          .          .             bl->firstgoto = fs->ls->dyd->gt.n;
    1,345 ( 0.01%) .          .          .             bl->upval = 0;
    7,308 ( 0.03%) .          .          .             bl->insidetbc = (fs->bl != NULL && fs->bl->insidetbc);
    2,690 ( 0.01%) .          .          .             bl->previous = fs->bl;
    1,345 ( 0.01%) .          .          .             fs->bl = bl;
    3,228 ( 0.01%) .          .          .             lua_assert(fs->freereg == luaY_nvarstack(fs));
   25,103 ( 0.12%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaY_nvarstack (269x)
    1,076 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static l_noret undefgoto (LexState *ls, Labeldesc *gt) {
        .          .          .          .             const char *msg;
        .          .          .          .             if (eqstr(gt->name, luaS_newliteral(ls->L, "break"))) {
        .          .          .          .               msg = "break outside loop at line %d";
        .          .          .          .               msg = luaO_pushfstring(ls->L, msg, gt->line);
        .          .          .          .             }
        .          .          .          .             else {
        .          .          .          .               msg = "no visible label '%s' for <goto> at line %d";
        .          .          .          .               msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line);
        .          .          .          .             }
        .          .          .          .             luaK_semerror(ls, msg);
        .          .          .          .           }
        .          .          .          .           
    1,614 ( 0.01%) .          .          .           static void leaveblock (FuncState *fs) {
    2,152 ( 0.01%) .          .          .             BlockCnt *bl = fs->bl;
    1,345 ( 0.01%) .          .          .             LexState *ls = fs->ls;
        .          .          .          .             int hasclose = 0;
    2,959 ( 0.01%) .          .          .             int stklevel = reglevel(fs, bl->nactvar);  
   21,337 ( 0.10%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reglevel (269x)
    2,421 ( 0.01%) .          .          .             if (bl->isloop)  
      944 ( 0.00%) .          .          .               hasclose = createlabel(ls, luaS_newliteral(ls->L, "break"), 0, 0);
   23,007 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:createlabel (59x)
   18,408 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_newlstr (59x)
    3,063 ( 0.01%) .          .          .             if (!hasclose && bl->previous && bl->upval)
      184 ( 0.00%) .          .          .               luaK_codeABC(fs, OP_CLOSE, stklevel, 0, 0);
    8,786 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (23x)
    2,690 ( 0.01%) .          .          .             fs->bl = bl->previous;
    1,883 ( 0.01%) .          .          .             removevars(fs, bl->nactvar);
   77,408 ( 0.36%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:removevars (269x)
    3,766 ( 0.02%) .          .          .             lua_assert(bl->nactvar == fs->nactvar);
    2,152 ( 0.01%) .          .          .             fs->freereg = stklevel;  
    5,649 ( 0.03%) .          .          .             ls->dyd->label.n = bl->firstlabel;  
    1,614 ( 0.01%) .          .          .             if (bl->previous)  
      636 ( 0.00%) .          .          .               movegotosout(fs, bl);  
   12,932 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:movegotosout (212x)
        .          .          .          .             else {
    1,083 ( 0.00%) .          .          .               if (bl->firstgoto < ls->dyd->gt.n)  
        .          .          .          .                 undefgoto(ls, &ls->dyd->gt.arr[bl->firstgoto]);  
        .          .          .          .             }
    1,614 ( 0.01%) .          .          .           }
        .          .          .          .           
      440 ( 0.00%) .          .          .           static Proto *addprototype (LexState *ls) {
        .          .          .          .             Proto *clp;
      440 ( 0.00%) .          .          .             lua_State *L = ls->L;
      275 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
      275 ( 0.00%) .          .          .             Proto *f = fs->f;  
      990 ( 0.00%) .          .          .             if (fs->np >= f->sizep) {
       60 ( 0.00%) .          .          .               int oldsize = f->sizep;
      480 ( 0.00%) .          .          .               luaM_growvector(L, f->p, fs->np, f->sizep, Proto *, MAXARG_Bx, "functions");
    6,365 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_growaux_ (15x)
      657 ( 0.00%) .          .          .               while (oldsize < f->sizep)
    1,840 ( 0.01%) .          .          .                 f->p[oldsize++] = NULL;
        .          .          .          .             }
    2,035 ( 0.01%) .          .          .             f->p[fs->np++] = clp = luaF_newproto(L);
   24,396 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_newproto (55x)
      330 ( 0.00%) .          .          .             luaC_objbarrier(L, f, clp);
        .          .          .          .             return clp;
      495 ( 0.00%) .          .          .           }
        .          .          .          .           
      275 ( 0.00%) .          .          .           static void codeclosure (LexState *ls, expdesc *v) {
      880 ( 0.00%) .          .          .             FuncState *fs = ls->fs->prev;
    1,100 ( 0.01%) .          .          .             init_exp(v, VRELOC, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np - 1));
   23,330 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABx (55x)
    2,200 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:init_exp (55x)
      165 ( 0.00%) .          .          .             luaK_exp2nextreg(fs, v);  
   16,390 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2nextreg (55x)
      220 ( 0.00%) .          .          .           }
        .          .          .          .           
      456 ( 0.00%) .          .          .           static void open_func (LexState *ls, FuncState *fs, BlockCnt *bl) {
      285 ( 0.00%) .          .          .             Proto *f = fs->f;
      912 ( 0.00%) .          .          .             fs->prev = ls->fs;  
      456 ( 0.00%) .          .          .             fs->ls = ls;
      285 ( 0.00%) .          .          .             ls->fs = fs;
      456 ( 0.00%) .          .          .             fs->pc = 0;
      912 ( 0.00%) .          .          .             fs->previousline = f->linedefined;
      456 ( 0.00%) .          .          .             fs->iwthabs = 0;
      285 ( 0.00%) .          .          .             fs->lasttarget = 0;
      285 ( 0.00%) .          .          .             fs->freereg = 0;
      285 ( 0.00%) .          .          .             fs->nk = 0;
      285 ( 0.00%) .          .          .             fs->nabslineinfo = 0;
      285 ( 0.00%) .          .          .             fs->np = 0;
      285 ( 0.00%) .          .          .             fs->nups = 0;
      285 ( 0.00%) .          .          .             fs->ndebugvars = 0;
      285 ( 0.00%) .          .          .             fs->nactvar = 0;
      456 ( 0.00%) .          .          .             fs->needclose = 0;
    1,197 ( 0.01%) .          .          .             fs->firstlocal = ls->dyd->actvar.n;
    1,026 ( 0.00%) .          .          .             fs->firstlabel = ls->dyd->label.n;
      285 ( 0.00%) .          .          .             fs->bl = NULL;
      912 ( 0.00%) .          .          .             f->source = ls->source;
      342 ( 0.00%) .          .          .             luaC_objbarrier(ls->L, f, f->source);
      285 ( 0.00%) .          .          .             f->maxstacksize = 2;  
      228 ( 0.00%) .          .          .             enterblock(fs, bl, 0);
    9,519 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:enterblock (57x)
      342 ( 0.00%) .          .          .           }
        .          .          .          .           
      456 ( 0.00%) .          .          .           static void close_func (LexState *ls) {
      456 ( 0.00%) .          .          .             lua_State *L = ls->L;
      285 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
      285 ( 0.00%) .          .          .             Proto *f = fs->f;
      342 ( 0.00%) .          .          .             luaK_ret(fs, luaY_nvarstack(fs), 0);  
   30,368 ( 0.14%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_ret (57x)
    4,067 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaY_nvarstack (57x)
      114 ( 0.00%) .          .          .             leaveblock(fs);
   27,957 ( 0.13%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:leaveblock (57x)
      513 ( 0.00%) .          .          .             lua_assert(fs->bl == NULL);
      114 ( 0.00%) .          .          .             luaK_finish(fs);
  433,902 ( 2.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_finish (57x)
    1,995 ( 0.01%) .          .          .             luaM_shrinkvector(L, f->code, f->sizecode, fs->pc, Instruction);
   10,659 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_shrinkvector_ (57x)
    1,653 ( 0.01%) .          .          .             luaM_shrinkvector(L, f->lineinfo, f->sizelineinfo, fs->pc, ls_byte);
   10,659 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_shrinkvector_ (57x)
    1,824 ( 0.01%) .          .          .             luaM_shrinkvector(L, f->abslineinfo, f->sizeabslineinfo,
    8,734 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_shrinkvector_ (57x)
        .          .          .          .                                  fs->nabslineinfo, AbsLineInfo);
    1,482 ( 0.01%) .          .          .             luaM_shrinkvector(L, f->k, f->sizek, fs->nk, TValue);
    9,854 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_shrinkvector_ (57x)
    1,482 ( 0.01%) .          .          .             luaM_shrinkvector(L, f->p, f->sizep, fs->np, Proto *);
    8,979 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_shrinkvector_ (57x)
    1,824 ( 0.01%) .          .          .             luaM_shrinkvector(L, f->locvars, f->sizelocvars, fs->ndebugvars, LocVar);
    9,644 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_shrinkvector_ (57x)
    1,653 ( 0.01%) .          .          .             luaM_shrinkvector(L, f->upvalues, f->sizeupvalues, fs->nups, Upvaldesc);
   10,204 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_shrinkvector_ (57x)
      570 ( 0.00%) .          .          .             ls->fs = fs->prev;
      969 ( 0.00%) .          .          .             luaC_checkGC(L);
      456 ( 0.00%) .          .          .           }
        .          .          .          .           
    4,700 ( 0.02%) .          .          .           static int block_follow (LexState *ls, int withuntil) {
   12,901 ( 0.06%) .          .          .             switch (ls->t.token) {
        .          .          .          .               case TK_ELSE: case TK_ELSEIF:
        .          .          .          .               case TK_END: case TK_EOS:
        .          .          .          .                 return 1;
       20 ( 0.00%) .          .          .               case TK_UNTIL: return withuntil;
    1,280 ( 0.01%) .          .          .               default: return 0;
        .          .          .          .             }
    3,760 ( 0.02%) .          .          .           }
        .          .          .          .           
      328 ( 0.00%) .          .          .           static void statlist (LexState *ls) {
        .          .          .          .             
    4,754 ( 0.02%) .          .          .             while (!block_follow(ls, 1)) {
    5,184 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:block_follow (216x)
    6,984 ( 0.03%) .          .          .               if (ls->t.token == TK_RETURN) {
       44 ( 0.00%) .          .          .                 statement(ls);
  254,312 ( 1.17%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:statement'2 (22x)
        .          .          .          .                 return;  
        .          .          .          .               }
    1,508 ( 0.01%) .          .          .               statement(ls);
14,386,000 (66.38%) 4 ( 0.75%) 90,366 ( 0.02%) 84,098 ( 0.02%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:statement (214x)
        .          .          .          .             }
      328 ( 0.00%) .          .          .           }
        .          .          .          .           
    1,290 ( 0.01%) .          .          .           static void fieldsel (LexState *ls, expdesc *v) {
        .          .          .          .             
    1,032 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
        .          .          .          .             expdesc key;
      387 ( 0.00%) .          .          .             luaK_exp2anyregup(fs, v);
   79,652 ( 0.37%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyregup (129x)
      258 ( 0.00%) .          .          .             luaX_next(ls);  
  255,235 ( 1.18%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (129x)
      516 ( 0.00%) .          .          .             codename(ls, &key);
   63,434 ( 0.29%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codename (129x)
      516 ( 0.00%) .          .          .             luaK_indexed(fs, v, &key);
  122,395 ( 0.56%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_indexed (129x)
    1,161 ( 0.01%) .          .          .           }
        .          .          .          .           
      455 ( 0.00%) .          .          .           static void yindex (LexState *ls, expdesc *v) {
        .          .          .          .             
       91 ( 0.00%) .          .          .             luaX_next(ls);  
   81,460 ( 0.38%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (85x)
      273 ( 0.00%) .          .          .             expr(ls, v);
  135,126 ( 0.62%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:expr (44x)
   83,735 ( 0.39%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:expr'2 (41x)
      910 ( 0.00%) .          .          .             luaK_exp2val(ls->fs, v);
    8,577 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2val (85x)
      273 ( 0.00%) .          .          .             checknext(ls, ']');
   35,598 ( 0.16%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checknext (85x)
      364 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           typedef struct ConsControl {
        .          .          .          .             expdesc v;  
        .          .          .          .             expdesc *t;  
        .          .          .          .             int nh;  
        .          .          .          .             int na;  
        .          .          .          .             int tostore;  
        .          .          .          .           } ConsControl;
        .          .          .          .           
      583 ( 0.00%) .          .          .           static void recfield (LexState *ls, ConsControl *cc) {
        .          .          .          .             
      424 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
      636 ( 0.00%) .          .          .             int reg = ls->fs->freereg;
        .          .          .          .             expdesc tab, key, val;
      318 ( 0.00%) .          .          .             if (ls->t.token == TK_NAME) {
      588 ( 0.00%) .          .          .               checklimit(fs, cc->nh, MAX_INT, "items in a constructor");
      141 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checklimit (47x)
      196 ( 0.00%) .          .          .               codename(ls, &key);
    6,110 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codename (47x)
        .          .          .          .             }
        .          .          .          .             else  
       12 ( 0.00%) .          .          .               yindex(ls, &key);
   10,063 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:yindex (4x)
      848 ( 0.00%) .          .          .             cc->nh++;
      159 ( 0.00%) .          .          .             checknext(ls, '=');
   76,997 ( 0.36%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checknext (51x)
      689 ( 0.00%) .          .          .             tab = *cc->t;
      265 ( 0.00%) .          .          .             luaK_indexed(fs, &tab, &key);
   45,396 ( 0.21%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_indexed (51x)
      212 ( 0.00%) .          .          .             expr(ls, &val);
  898,098 ( 4.14%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:expr'2 (51x)
      212 ( 0.00%) .          .          .             luaK_storevar(fs, &tab, &val);
   56,470 ( 0.26%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_storevar (51x)
      265 ( 0.00%) .          .          .             fs->freereg = reg;  
      530 ( 0.00%) .          .          .           }
        .          .          .          .           
      630 ( 0.00%) .          .          .           static void closelistfield (FuncState *fs, ConsControl *cc) {
      540 ( 0.00%) .          .          .             if (cc->v.k == VVOID) return;  
       98 ( 0.00%) .          .          .             luaK_exp2nextreg(fs, &cc->v);
    9,328 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2nextreg (14x)
       70 ( 0.00%) .          .          .             cc->v.k = VVOID;
      140 ( 0.00%) .          .          .             if (cc->tostore == LFIELDS_PER_FLUSH) {
        .          .          .          .               luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);  
        .          .          .          .               cc->na += cc->tostore;
        .          .          .          .               cc->tostore = 0;  
        .          .          .          .             }
      540 ( 0.00%) .          .          .           }
        .          .          .          .           
      945 ( 0.00%) .          .          .           static void lastlistfield (FuncState *fs, ConsControl *cc) {
    1,215 ( 0.01%) .          .          .             if (cc->tostore == 0) return;
      192 ( 0.00%) .          .          .             if (hasmultret(cc->v.k)) {
       32 ( 0.00%) .          .          .               luaK_setmultret(fs, &cc->v);
      358 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_setreturns (4x)
       88 ( 0.00%) .          .          .               luaK_setlist(fs, cc->t->u.info, cc->na, LUA_MULTRET);
    1,672 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_setlist (4x)
       56 ( 0.00%) .          .          .               cc->na--;  
        .          .          .          .             }
        .          .          .          .             else {
      120 ( 0.00%) .          .          .               if (cc->v.k != VVOID)
      152 ( 0.00%) .          .          .                 luaK_exp2nextreg(fs, &cc->v);
   13,588 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2nextreg (19x)
      460 ( 0.00%) .          .          .               luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);
    8,468 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_setlist (20x)
        .          .          .          .             }
      432 ( 0.00%) .          .          .             cc->na += cc->tostore;
      810 ( 0.00%) .          .          .           }
        .          .          .          .           
      185 ( 0.00%) .          .          .           static void listfield (LexState *ls, ConsControl *cc) {
        .          .          .          .             
      259 ( 0.00%) .          .          .             expr(ls, &cc->v);
  157,364 ( 0.73%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:expr'2 (33x)
      592 ( 0.00%) .          .          .             cc->tostore++;
      148 ( 0.00%) .          .          .           }
        .          .          .          .           
      450 ( 0.00%) .          .          .           static void field (LexState *ls, ConsControl *cc) {
        .          .          .          .             
    1,072 ( 0.00%) .          .          .             switch(ls->t.token) {
        .          .          .          .               case TK_NAME: {  
      236 ( 0.00%) .          .          .                 if (luaX_lookahead(ls) != '=')  
   11,717 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_lookahead (53x)
       40 ( 0.00%) .          .          .                   listfield(ls, cc);
  112,995 ( 0.52%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:listfield (9x)
        .          .          .          .                 else
      196 ( 0.00%) .          .          .                   recfield(ls, cc);
1,019,671 ( 4.70%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:recfield (44x)
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case '[': {
       12 ( 0.00%) .          .          .                 recfield(ls, cc);
   24,168 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:recfield (4x)
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: {
       81 ( 0.00%) .          .          .                 listfield(ls, cc);
   42,269 ( 0.20%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:listfield (20x)
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .             }
      387 ( 0.00%) .          .          .           }
        .          .          .          .           
    1,620 ( 0.01%) .          .          .           static void constructor (LexState *ls, expdesc *t) {
        .          .          .          .             
    1,080 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
      675 ( 0.00%) .          .          .             int line = ls->linenumber;
    1,080 ( 0.00%) .          .          .             int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
   47,085 ( 0.22%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (115x)
        .          .          .          .             ConsControl cc;
      405 ( 0.00%) .          .          .             luaK_code(fs, 0);  
   39,338 ( 0.18%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_code (115x)
      405 ( 0.00%) .          .          .             cc.na = cc.nh = cc.tostore = 0;
      135 ( 0.00%) .          .          .             cc.t = t;
    1,485 ( 0.01%) .          .          .             init_exp(t, VNONRELOC, fs->freereg);  
    4,600 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:init_exp (115x)
      405 ( 0.00%) .          .          .             luaK_reserveregs(fs, 1);
    6,758 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_reserveregs (115x)
      540 ( 0.00%) .          .          .             init_exp(&cc.v, VVOID, 0);  
    4,600 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:init_exp (115x)
      540 ( 0.00%) .          .          .             checknext(ls, '{');
  133,013 ( 0.61%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checknext (115x)
        .          .          .          .             do {
      342 ( 0.00%) .          .          .               lua_assert(cc.v.k == VVOID || cc.tostore > 0);
      942 ( 0.00%) .          .          .               if (ls->t.token == '}') break;
      360 ( 0.00%) .          .          .               closelistfield(fs, &cc);
   11,099 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:closelistfield (77x)
      270 ( 0.00%) .          .          .               field(ls, &cc);
1,212,945 ( 5.60%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:field (77x)
      795 ( 0.00%) .          .          .             } while (testnext(ls, ',') || testnext(ls, ';'));
   33,925 ( 0.16%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:testnext (134x)
      675 ( 0.00%) .          .          .             check_match(ls, '}', '{', line);
  125,589 ( 0.58%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_match (115x)
      405 ( 0.00%) .          .          .             lastlistfield(fs, &cc);
   19,430 ( 0.09%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lastlistfield (115x)
    2,025 ( 0.01%) .          .          .             luaK_settablesize(fs, pc, t->u.info, cc.na, cc.nh);
   10,257 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_settablesize (115x)
    1,485 ( 0.01%) .          .          .           }
        .          .          .          .           
       15 ( 0.00%) .          .          .           static void setvararg (FuncState *fs, int nparams) {
       39 ( 0.00%) .          .          .             fs->f->is_vararg = 1;
       21 ( 0.00%) .          .          .             luaK_codeABC(fs, OP_VARARGPREP, nparams, 0, 0);
    2,992 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (3x)
       12 ( 0.00%) .          .          .           }
        .          .          .          .           
      330 ( 0.00%) .          .          .           static void parlist (LexState *ls) {
        .          .          .          .             
      440 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
      275 ( 0.00%) .          .          .             Proto *f = fs->f;
       90 ( 0.00%) .          .          .             int nparams = 0;
       35 ( 0.00%) .          .          .             int isvararg = 0;
      330 ( 0.00%) .          .          .             if (ls->t.token != ')') {  
        .          .          .          .               do {
      196 ( 0.00%) .          .          .                 switch (ls->t.token) {
        .          .          .          .                   case TK_NAME: {
      105 ( 0.00%) .          .          .                     new_localvar(ls, str_checkname(ls));
    5,179 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:new_localvar (21x)
    4,641 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:str_checkname (21x)
       84 ( 0.00%) .          .          .                     nparams++;
        .          .          .          .                     break;
        .          .          .          .                   }
        .          .          .          .                   case TK_DOTS: {
        2 ( 0.00%) .          .          .                     luaX_next(ls);
      182 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (1x)
        1 ( 0.00%) .          .          .                     isvararg = 1;
        .          .          .          .                     break;
        .          .          .          .                   }
        .          .          .          .                   default: luaX_syntaxerror(ls, "<name> or '...' expected");
        .          .          .          .                 }
      145 ( 0.00%) .          .          .               } while (!isvararg && testnext(ls, ','));
    5,885 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:testnext (21x)
        .          .          .          .             }
      165 ( 0.00%) .          .          .             adjustlocalvars(ls, nparams);
   16,497 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:adjustlocalvars (55x)
      880 ( 0.00%) .          .          .             f->numparams = cast_byte(fs->nactvar);
      110 ( 0.00%) .          .          .             if (isvararg)
        8 ( 0.00%) .          .          .               setvararg(fs, f->numparams);  
    1,093 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:setvararg (1x)
      385 ( 0.00%) .          .          .             luaK_reserveregs(fs, fs->nactvar);  
    3,190 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_reserveregs (55x)
      330 ( 0.00%) .          .          .           }
        .          .          .          .           
      715 ( 0.00%) .          .          .           static void body (LexState *ls, expdesc *e, int ismethod, int line) {
        .          .          .          .             
        .          .          .          .             FuncState new_fs;
        .          .          .          .             BlockCnt bl;
      165 ( 0.00%) .          .          .             new_fs.f = addprototype(ls);
   28,065 ( 0.13%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:addprototype (42x)
      440 ( 0.00%) .          .          .             new_fs.f->linedefined = line;
      220 ( 0.00%) .          .          .             open_func(ls, &new_fs, &bl);
   15,540 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:open_func (42x)
      165 ( 0.00%) .          .          .             checknext(ls, '(');
   33,994 ( 0.16%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checknext (42x)
      110 ( 0.00%) .          .          .             if (ismethod) {
        7 ( 0.00%) .          .          .               new_localvarliteral(ls, "self");  
    2,170 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_newstring (1x)
      189 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:new_localvar (1x)
        4 ( 0.00%) .          .          .               adjustlocalvars(ls, 1);
      894 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:adjustlocalvars (1x)
        .          .          .          .             }
      110 ( 0.00%) .          .          .             parlist(ls);
   36,949 ( 0.17%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:parlist (42x)
      165 ( 0.00%) .          .          .             checknext(ls, ')');
   77,721 ( 0.36%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checknext (42x)
      110 ( 0.00%) .          .          .             statlist(ls);
3,283,951 (15.15%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:statlist'2 (42x)
      935 ( 0.00%) .          .          .             new_fs.f->lastlinedefined = ls->linenumber;
      275 ( 0.00%) .          .          .             check_match(ls, TK_END, TK_FUNCTION, line);
   69,746 ( 0.32%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_match (42x)
      165 ( 0.00%) .          .          .             codeclosure(ls, e);
   31,533 ( 0.15%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codeclosure (42x)
      110 ( 0.00%) .          .          .             close_func(ls);
  211,344 ( 0.98%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:close_func (42x)
      550 ( 0.00%) .          .          .           }
        .          .          .          .           
    5,026 ( 0.02%) .          .          .           static int explist (LexState *ls, expdesc *v) {
        .          .          .          .             
      718 ( 0.00%) .          .          .             int n = 1;  
      718 ( 0.00%) .          .          .             expr(ls, v);
5,855,519 (27.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:expr (477x)
   55,984 ( 0.26%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:expr'2 (11x)
    5,053 ( 0.02%) .          .          .             while (testnext(ls, ',')) {
  157,831 ( 0.73%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:testnext (558x)
    1,490 ( 0.01%) .          .          .               luaK_exp2nextreg(ls->fs, v);
   67,277 ( 0.31%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2nextreg (70x)
      447 ( 0.00%) .          .          .               expr(ls, v);
  452,603 ( 2.09%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:expr (65x)
   30,207 ( 0.14%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:expr'2 (5x)
      596 ( 0.00%) .          .          .               n++;
        .          .          .          .             }
        .          .          .          .             return n;
    5,026 ( 0.02%) .          .          .           }
        .          .          .          .           
    6,526 ( 0.03%) .          .          .           static void funcargs (LexState *ls, expdesc *f, int line) {
    4,016 ( 0.02%) .          .          .             FuncState *fs = ls->fs;
        .          .          .          .             expdesc args;
        .          .          .          .             int base, nparams;
    5,464 ( 0.03%) .          .          .             switch (ls->t.token) {
        .          .          .          .               case '(': {  
      948 ( 0.00%) .          .          .                 luaX_next(ls);
  728,911 ( 3.36%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (367x)
    2,844 ( 0.01%) .          .          .                 if (ls->t.token == ')')  
       82 ( 0.00%) .          .          .                   args.k = VVOID;
        .          .          .          .                 else {
    1,176 ( 0.01%) .          .          .                   explist(ls, &args);
2,299,702 (10.61%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:explist (202x)
1,049,483 ( 4.84%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:explist'2 (93x)
    1,568 ( 0.01%) .          .          .                   if (hasmultret(args.k))
      150 ( 0.00%) .          .          .                     luaK_setmultret(fs, &args);
    1,690 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_setreturns (26x)
        .          .          .          .                 }
    2,370 ( 0.01%) .          .          .                 check_match(ls, ')', '(', line);
  905,248 ( 4.18%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_match (367x)
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case '{': {  
        3 ( 0.00%) .          .          .                 constructor(ls, &args);
    3,933 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:constructor'2 (1x)
        1 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_STRING: {  
      189 ( 0.00%) .          .          .                 codestring(&args, ls->t.seminfo.ts);
      741 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codestring (19x)
       54 ( 0.00%) .          .          .                 luaX_next(ls);  
   35,260 ( 0.16%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (19x)
       27 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: {
        .          .          .          .                 luaX_syntaxerror(ls, "function arguments expected");
        .          .          .          .               }
        .          .          .          .             }
    3,012 ( 0.01%) .          .          .             lua_assert(f->k == VNONRELOC);
    4,016 ( 0.02%) .          .          .             base = f->u.info;  
    2,008 ( 0.01%) .          .          .             if (hasmultret(args.k))
       60 ( 0.00%) .          .          .               nparams = LUA_MULTRET;  
        .          .          .          .             else {
      944 ( 0.00%) .          .          .               if (args.k != VVOID)
    1,560 ( 0.01%) .          .          .                 luaK_exp2nextreg(fs, &args);  
  364,323 ( 1.68%) 1 ( 0.19%) 26,259 ( 0.00%) 24,752 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2nextreg (288x)
    7,552 ( 0.03%) .          .          .               nparams = fs->freereg - (base+1);
        .          .          .          .             }
    7,028 ( 0.03%) .          .          .             init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));
  156,231 ( 0.72%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (386x)
   15,440 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:init_exp (386x)
    1,506 ( 0.01%) .          .          .             luaK_fixline(fs, line);
  103,764 ( 0.48%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_fixline (386x)
    4,518 ( 0.02%) .          .          .             fs->freereg = base+1;  
    5,522 ( 0.03%) .          .          .           }
        .          .          .          .           
    5,820 ( 0.03%) .          .          .           static void primaryexp (LexState *ls, expdesc *v) {
        .          .          .          .             
   13,950 ( 0.06%) .          .          .             switch (ls->t.token) {
        .          .          .          .               case '(': {
       45 ( 0.00%) .          .          .                 int line = ls->linenumber;
       18 ( 0.00%) .          .          .                 luaX_next(ls);
   11,308 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (9x)
       27 ( 0.00%) .          .          .                 expr(ls, v);
  143,290 ( 0.66%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:expr (2x)
   71,273 ( 0.33%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:expr'2 (7x)
       45 ( 0.00%) .          .          .                 check_match(ls, ')', '(', line);
    7,356 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_match (9x)
       90 ( 0.00%) .          .          .                 luaK_dischargevars(ls->fs, v);
      183 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_dischargevars (9x)
        .          .          .          .                 return;
        .          .          .          .               }
        .          .          .          .               case TK_NAME: {
    3,465 ( 0.02%) .          .          .                 singlevar(ls, v);
2,959,212 (13.65%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:singlevar (1,129x)
    1,155 ( 0.01%) .          .          .                 return;
        .          .          .          .               }
        .          .          .          .               default: {
        .          .          .          .                 luaX_syntaxerror(ls, "unexpected symbol");
        .          .          .          .               }
        .          .          .          .             }
    4,656 ( 0.02%) .          .          .           }
        .          .          .          .           
   12,804 ( 0.06%) .          .          .           static void suffixedexp (LexState *ls, expdesc *v) {
        .          .          .          .             
    9,312 ( 0.04%) .          .          .             FuncState *fs = ls->fs;
    5,820 ( 0.03%) .          .          .             int line = ls->linenumber;
    4,656 ( 0.02%) .          .          .             primaryexp(ls, v);
2,392,738 (11.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:primaryexp (729x)
        .          .          .          .             for (;;) {
   23,292 ( 0.11%) .          .          .               switch (ls->t.token) {
        .          .          .          .                 case '.': {  
      384 ( 0.00%) .          .          .                   fieldsel(ls, v);
  313,896 ( 1.45%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:fieldsel (76x)
        .          .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case '[': {  
        .          .          .          .                   expdesc key;
      261 ( 0.00%) .          .          .                   luaK_exp2anyregup(fs, v);
   28,541 ( 0.13%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyregup (58x)
      348 ( 0.00%) .          .          .                   yindex(ls, &key);
  248,527 ( 1.15%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:yindex (58x)
      348 ( 0.00%) .          .          .                   luaK_indexed(fs, v, &key);
   23,487 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_indexed (58x)
       87 ( 0.00%) .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case ':': {  
        .          .          .          .                   expdesc key;
        2 ( 0.00%) .          .          .                   luaX_next(ls);
    1,449 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (1x)
        4 ( 0.00%) .          .          .                   codename(ls, &key);
      268 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codename (1x)
        4 ( 0.00%) .          .          .                   luaK_self(fs, v, &key);
    1,585 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_self (1x)
        4 ( 0.00%) .          .          .                   funcargs(ls, v, line);
    2,486 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:funcargs (1x)
        1 ( 0.00%) .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 case '(': case TK_STRING: case '{': {  
    1,503 ( 0.01%) .          .          .                   luaK_exp2nextreg(fs, v);
  292,132 ( 1.35%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2nextreg (378x)
    2,004 ( 0.01%) .          .          .                   funcargs(ls, v, line);
5,600,720 (25.84%) 1 ( 0.19%) 26,259 ( 0.00%) 24,752 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:funcargs (378x)
      501 ( 0.00%) .          .          .                   break;
        .          .          .          .                 }
        .          .          .          .                 default: return;
        .          .          .          .               }
        .          .          .          .             }
   11,640 ( 0.05%) .          .          .           }
        .          .          .          .           
    9,688 ( 0.04%) .          .          .           static void simpleexp (LexState *ls, expdesc *v) {
        .          .          .          .             
   30,006 ( 0.14%) .          .          .             switch (ls->t.token) {
        .          .          .          .               case TK_FLT: {
        4 ( 0.00%) .          .          .                 init_exp(v, VKFLT, 0);
       40 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:init_exp (1x)
       16 ( 0.00%) .          .          .                 v->u.nval = ls->t.seminfo.r;
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_INT: {
      920 ( 0.00%) .          .          .                 init_exp(v, VKINT, 0);
    5,560 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:init_exp (139x)
    3,680 ( 0.02%) .          .          .                 v->u.ival = ls->t.seminfo.i;
      230 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_STRING: {
    2,140 ( 0.01%) .          .          .                 codestring(v, ls->t.seminfo.ts);
    4,602 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:codestring (118x)
      214 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_NIL: {
      152 ( 0.00%) .          .          .                 init_exp(v, VNIL, 0);
    1,360 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:init_exp (34x)
       38 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_TRUE: {
       80 ( 0.00%) .          .          .                 init_exp(v, VTRUE, 0);
      360 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:init_exp (9x)
       20 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_FALSE: {
       56 ( 0.00%) .          .          .                 init_exp(v, VFALSE, 0);
      480 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:init_exp (12x)
       14 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_DOTS: {  
        8 ( 0.00%) .          .          .                 FuncState *fs = ls->fs;
       14 ( 0.00%) .          .          .                 check_condition(ls, fs->f->is_vararg,
        .          .          .          .                                 "cannot use '...' outside a vararg function");
       11 ( 0.00%) .          .          .                 init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 0, 1));
       40 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:init_exp (1x)
      382 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (1x)
        1 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case '{': {  
      402 ( 0.00%) .          .          .                 constructor(ls, v);
1,425,137 ( 6.58%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:constructor (85x)
      134 ( 0.00%) .          .          .                 return;
        .          .          .          .               }
        .          .          .          .               case TK_FUNCTION: {
       78 ( 0.00%) .          .          .                 luaX_next(ls);
    4,482 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (19x)
      351 ( 0.00%) .          .          .                 body(ls, v, 0, ls->linenumber);
1,018,857 ( 4.70%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:body (15x)
  180,526 ( 0.83%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:body'2 (4x)
       39 ( 0.00%) .          .          .                 return;
        .          .          .          .               }
        .          .          .          .               default: {
    2,079 ( 0.01%) .          .          .                 suffixedexp(ls, v);
2,019,562 ( 9.32%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:suffixedexp (236x)
1,314,978 ( 6.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:suffixedexp'2 (204x)
      693 ( 0.00%) .          .          .                 return;
        .          .          .          .               }
        .          .          .          .             }
    1,036 ( 0.00%) .          .          .             luaX_next(ls);
  234,367 ( 1.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (313x)
    8,304 ( 0.04%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static UnOpr getunopr (int op) {
    7,320 ( 0.03%) .          .          .             switch (op) {
        .          .          .          .               case TK_NOT: return OPR_NOT;
        4 ( 0.00%) .          .          .               case '-': return OPR_MINUS;
        .          .          .          .               case '~': return OPR_BNOT;
        8 ( 0.00%) .          .          .               case '#': return OPR_LEN;
    1,525 ( 0.01%) .          .          .               default: return OPR_NOUNOPR;
        .          .          .          .             }
    1,243 ( 0.01%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static BinOpr getbinopr (int op) {
   19,306 ( 0.09%) .          .          .             switch (op) {
        .          .          .          .               case '+': return OPR_ADD;
       18 ( 0.00%) .          .          .               case '-': return OPR_SUB;
       22 ( 0.00%) .          .          .               case '*': return OPR_MUL;
        2 ( 0.00%) .          .          .               case '%': return OPR_MOD;
       14 ( 0.00%) .          .          .               case '^': return OPR_POW;
        4 ( 0.00%) .          .          .               case '/': return OPR_DIV;
        6 ( 0.00%) .          .          .               case TK_IDIV: return OPR_IDIV;
        .          .          .          .               case '&': return OPR_BAND;
        .          .          .          .               case '|': return OPR_BOR;
        .          .          .          .               case '~': return OPR_BXOR;
        .          .          .          .               case TK_SHL: return OPR_SHL;
        .          .          .          .               case TK_SHR: return OPR_SHR;
       46 ( 0.00%) .          .          .               case TK_CONCAT: return OPR_CONCAT;
        6 ( 0.00%) .          .          .               case TK_NE: return OPR_NE;
      182 ( 0.00%) .          .          .               case TK_EQ: return OPR_EQ;
       12 ( 0.00%) .          .          .               case '<': return OPR_LT;
        4 ( 0.00%) .          .          .               case TK_LE: return OPR_LE;
       12 ( 0.00%) .          .          .               case '>': return OPR_GT;
        2 ( 0.00%) .          .          .               case TK_GE: return OPR_GE;
       24 ( 0.00%) .          .          .               case TK_AND: return OPR_AND;
       22 ( 0.00%) .          .          .               case TK_OR: return OPR_OR;
    2,255 ( 0.01%) .          .          .               default: return OPR_NOBINOPR;
        .          .          .          .             }
      123 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static const struct {
        .          .          .          .             lu_byte left;  
        .          .          .          .             lu_byte right; 
        .          .          .          .           } priority[] = {  
        .          .          .          .              {10, 10}, {10, 10},           
        .          .          .          .              {11, 11}, {11, 11},           
        .          .          .          .              {14, 13},                  
-- line 9757 ----------------------------------------
-- line 9761 ----------------------------------------
        .          .          .          .              {9, 8},                   
        .          .          .          .              {3, 3}, {3, 3}, {3, 3},   
        .          .          .          .              {3, 3}, {3, 3}, {3, 3},   
        .          .          .          .              {2, 2}, {1, 1}            
        .          .          .          .           };
        .          .          .          .           
        .          .          .          .           #define UNARY_PRIORITY	12  
        .          .          .          .           
   18,226 ( 0.08%) .          .          .           static BinOpr subexpr (LexState *ls, expdesc *v, int limit) {
        .          .          .          .             BinOpr op;
        .          .          .          .             UnOpr uop;
   12,618 ( 0.06%) .          .          .             enterlevel(ls);
   19,628 ( 0.09%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaE_incCstack (701x)
    9,814 ( 0.05%) .          .          .             uop = getunopr(ls->t.token);
    5,081 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getunopr (701x)
    2,804 ( 0.01%) .          .          .             if (uop != OPR_NOUNOPR) {  
       90 ( 0.00%) .          .          .               int line = ls->linenumber;
       36 ( 0.00%) .          .          .               luaX_next(ls);  
   22,926 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (16x)
       72 ( 0.00%) .          .          .               subexpr(ls, v, UNARY_PRIORITY);
   76,934 ( 0.35%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:subexpr'2 (16x)
      162 ( 0.00%) .          .          .               luaK_prefix(ls->fs, uop, v, line);
   18,316 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_prefix (16x)
        .          .          .          .             }
    5,536 ( 0.03%) .          .          .             else simpleexp(ls, v);
5,881,685 (27.14%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:simpleexp (685x)
        .          .          .          .             
    9,814 ( 0.05%) .          .          .             op = getbinopr(ls->t.token);
   10,877 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getbinopr (701x)
    8,161 ( 0.04%) .          .          .             while (op != OPR_NOBINOPR && priority[op].left > limit) {
        .          .          .          .               expdesc v2;
        .          .          .          .               BinOpr nextop;
    1,266 ( 0.01%) .          .          .               int line = ls->linenumber;
      422 ( 0.00%) .          .          .               luaX_next(ls);  
  184,646 ( 0.85%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (123x)
    1,688 ( 0.01%) .          .          .               luaK_infix(ls->fs, op, v);
   67,681 ( 0.31%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_infix (123x)
        .          .          .          .               
    4,009 ( 0.02%) .          .          .               nextop = subexpr(ls, &v2, priority[op].right);
  432,166 ( 1.99%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:subexpr'2 (123x)
    2,110 ( 0.01%) .          .          .               luaK_posfix(ls->fs, op, v, &v2, line);
  212,311 ( 0.98%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_posfix (123x)
      422 ( 0.00%) .          .          .               op = nextop;
        .          .          .          .             }
   26,638 ( 0.12%) .          .          .             leavelevel(ls);
        .          .          .          .             return op;  
   16,824 ( 0.08%) .          .          .           }
        .          .          .          .           
    1,173 ( 0.01%) .          .          .           static void expr (LexState *ls, expdesc *v) {
    2,346 ( 0.01%) .          .          .             subexpr(ls, v, 0);
6,993,692 (32.27%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:subexpr (701x)
    2,346 ( 0.01%) .          .          .           }
        .          .          .          .           
      483 ( 0.00%) .          .          .           static void block (LexState *ls) {
        .          .          .          .             
      552 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
        .          .          .          .             BlockCnt bl;
      276 ( 0.00%) .          .          .             enterblock(fs, &bl, 0);
   12,693 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:enterblock (50x)
      138 ( 0.00%) .          .          .             statlist(ls);
6,478,128 (29.89%) 2 ( 0.37%) 39,203 ( 0.01%) 36,396 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:statlist'2 (50x)
      138 ( 0.00%) .          .          .             leaveblock(fs);
   28,322 ( 0.13%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:leaveblock (50x)
      483 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           struct LHS_assign {
        .          .          .          .             struct LHS_assign *prev;
        .          .          .          .             expdesc v;  
        .          .          .          .           };
        .          .          .          .           
       60 ( 0.00%) .          .          .           static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
       48 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
       60 ( 0.00%) .          .          .             int extra = fs->freereg;  
        6 ( 0.00%) .          .          .             int conflict = 0;
       74 ( 0.00%) .          .          .             for (; lh; lh = lh->prev) {  
       77 ( 0.00%) .          .          .               if (vkisindexed(lh->v.k)) {  
        7 ( 0.00%) .          .          .                 if (lh->v.k == VINDEXUP) {  
        6 ( 0.00%) .          .          .                   if (v->k == VUPVAL && lh->v.u.ind.t == v->u.info) {
        .          .          .          .                     conflict = 1;  
        .          .          .          .                     lh->v.k = VINDEXSTR;
        .          .          .          .                     lh->v.u.ind.t = extra;  
        .          .          .          .                   }
        .          .          .          .                 }
        .          .          .          .                 else {  
        .          .          .          .                   if (v->k == VLOCAL && lh->v.u.ind.t == v->u.var.ridx) {
        .          .          .          .                     conflict = 1;  
-- line 9831 ----------------------------------------
-- line 9835 ----------------------------------------
        .          .          .          .                   if (lh->v.k == VINDEXED && v->k == VLOCAL &&
        .          .          .          .                       lh->v.u.ind.idx == v->u.var.ridx) {
        .          .          .          .                     conflict = 1;
        .          .          .          .                     lh->v.u.ind.idx = extra;  
        .          .          .          .                   }
        .          .          .          .                 }
        .          .          .          .               }
        .          .          .          .             }
       12 ( 0.00%) .          .          .             if (conflict) {
        .          .          .          .               
        .          .          .          .               if (v->k == VLOCAL)
        .          .          .          .                 luaK_codeABC(fs, OP_MOVE, extra, v->u.var.ridx, 0);
        .          .          .          .               else
        .          .          .          .                 luaK_codeABC(fs, OP_GETUPVAL, extra, v->u.info, 0);
        .          .          .          .               luaK_reserveregs(fs, 1);
        .          .          .          .             }
       48 ( 0.00%) .          .          .           }
        .          .          .          .           
    2,244 ( 0.01%) .          .          .           static void restassign (LexState *ls, struct LHS_assign *lh, int nvars) {
        .          .          .          .             expdesc e;
    2,057 ( 0.01%) .          .          .             check_condition(ls, vkisvar(lh->v.k), "syntax error");
    1,496 ( 0.01%) .          .          .             check_readonly(ls, &lh->v);
    9,278 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_readonly (167x)
      935 ( 0.00%) .          .          .             if (testnext(ls, ',')) {  
    9,746 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:testnext (167x)
        .          .          .          .               struct LHS_assign nv;
        9 ( 0.00%) .          .          .               nv.prev = lh;
       27 ( 0.00%) .          .          .               suffixedexp(ls, &nv.v);
   11,957 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:suffixedexp (7x)
       36 ( 0.00%) .          .          .               if (!vkisindexed(nv.v.k))
       30 ( 0.00%) .          .          .                 check_conflict(ls, lh, &nv.v);
      318 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_conflict (5x)
       81 ( 0.00%) .          .          .               enterlevel(ls);  
      196 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaE_incCstack (7x)
       63 ( 0.00%) .          .          .               restassign(ls, &nv, nvars+1);
   78,179 ( 0.36%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:restassign'2 (7x)
      171 ( 0.00%) .          .          .               leavelevel(ls);
        .          .          .          .             }
        .          .          .          .             else {  
        .          .          .          .               int nexps;
      534 ( 0.00%) .          .          .               checknext(ls, '=');
  251,111 ( 1.16%) 2 ( 0.37%) 39,203 ( 0.01%) 36,396 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:checknext (160x)
      712 ( 0.00%) .          .          .               nexps = explist(ls, &e);
2,108,250 ( 9.73%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:explist (151x)
  319,610 ( 1.47%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:explist'2 (9x)
      356 ( 0.00%) .          .          .               if (nexps != nvars)
       30 ( 0.00%) .          .          .                 adjust_assign(ls, nvars, nexps, &e);
    5,277 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:adjust_assign (6x)
        .          .          .          .               else {
    1,720 ( 0.01%) .          .          .                 luaK_setoneret(ls->fs, &e);  
    7,264 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_setoneret (160x)
    2,064 ( 0.01%) .          .          .                 luaK_storevar(ls->fs, &lh->v, &e);
  137,137 ( 0.63%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_storevar (160x)
      172 ( 0.00%) .          .          .                 return;  
        .          .          .          .               }
        .          .          .          .             }
      345 ( 0.00%) .          .          .             init_exp(&e, VNONRELOC, ls->fs->freereg-1);  
      280 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:init_exp (7x)
      180 ( 0.00%) .          .          .             luaK_storevar(ls->fs, &lh->v, &e);
    5,192 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_storevar (7x)
    1,870 ( 0.01%) .          .          .           }
        .          .          .          .           
       78 ( 0.00%) .          .          .           static int cond (LexState *ls) {
        .          .          .          .             
        .          .          .          .             expdesc v;
       26 ( 0.00%) .          .          .             expr(ls, &v);  
   80,971 ( 0.37%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:expr (13x)
       26 ( 0.00%) .          .          .             if (v.k == VNIL) v.k = VFALSE;  
      130 ( 0.00%) .          .          .             luaK_goiftrue(ls->fs, &v);
   12,163 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_goiftrue (13x)
       13 ( 0.00%) .          .          .             return v.f;
       78 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void gotostat (LexState *ls) {
        .          .          .          .             FuncState *fs = ls->fs;
        .          .          .          .             int line = ls->linenumber;
        .          .          .          .             TString *name = str_checkname(ls);  
        .          .          .          .             Labeldesc *lb = findlabel(ls, name);
        .          .          .          .             if (lb == NULL)  
        .          .          .          .               
-- line 9898 ----------------------------------------
-- line 9926 ----------------------------------------
        .          .          .          .             
        .          .          .          .             checknext(ls, TK_DBCOLON);  
        .          .          .          .             while (ls->t.token == ';' || ls->t.token == TK_DBCOLON)
        .          .          .          .               statement(ls);  
        .          .          .          .             checkrepeated(ls, name);  
        .          .          .          .             createlabel(ls, name, line, block_follow(ls, 0));
        .          .          .          .           }
        .          .          .          .           
       33 ( 0.00%) .          .          .           static void whilestat (LexState *ls, int line) {
        .          .          .          .             
       24 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
        .          .          .          .             int whileinit;
        .          .          .          .             int condexit;
        .          .          .          .             BlockCnt bl;
        6 ( 0.00%) .          .          .             luaX_next(ls);  
    4,159 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (3x)
        9 ( 0.00%) .          .          .             whileinit = luaK_getlabel(fs);
       87 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_getlabel (3x)
        9 ( 0.00%) .          .          .             condexit = cond(ls);
   12,361 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:cond (3x)
       12 ( 0.00%) .          .          .             enterblock(fs, &bl, 1);
      762 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:enterblock (3x)
        9 ( 0.00%) .          .          .             checknext(ls, TK_DO);
    4,700 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checknext (3x)
        6 ( 0.00%) .          .          .             block(ls);
  135,765 ( 0.63%) 2 ( 0.37%) 39,203 ( 0.01%) 36,396 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:block (3x)
       18 ( 0.00%) .          .          .             luaK_jumpto(fs, whileinit);
    1,125 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_jump (3x)
      948 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_patchlist (3x)
       15 ( 0.00%) .          .          .             check_match(ls, TK_END, TK_WHILE, line);
   24,489 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_match (3x)
        6 ( 0.00%) .          .          .             leaveblock(fs);
    3,207 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:leaveblock (3x)
        9 ( 0.00%) .          .          .             luaK_patchtohere(fs, condexit);  
    1,192 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_patchtohere (3x)
       30 ( 0.00%) .          .          .           }
        .          .          .          .           
      100 ( 0.00%) .          .          .           static void repeatstat (LexState *ls, int line) {
        .          .          .          .             
        .          .          .          .             int condexit;
       80 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
       30 ( 0.00%) .          .          .             int repeat_init = luaK_getlabel(fs);
      290 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_getlabel (10x)
        .          .          .          .             BlockCnt bl1, bl2;
       40 ( 0.00%) .          .          .             enterblock(fs, &bl1, 1);  
    2,540 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:enterblock (10x)
       40 ( 0.00%) .          .          .             enterblock(fs, &bl2, 0);  
    2,540 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:enterblock (10x)
       20 ( 0.00%) .          .          .             luaX_next(ls);  
   17,581 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (10x)
       20 ( 0.00%) .          .          .             statlist(ls);
  190,142 ( 0.88%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:statlist'2 (10x)
       50 ( 0.00%) .          .          .             check_match(ls, TK_UNTIL, TK_REPEAT, line);
   20,018 ( 0.09%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_match (10x)
       30 ( 0.00%) .          .          .             condexit = cond(ls);  
   81,124 ( 0.37%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:cond (10x)
       20 ( 0.00%) .          .          .             leaveblock(fs);  
    4,918 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:leaveblock (10x)
       20 ( 0.00%) .          .          .             if (bl2.upval) {  
        6 ( 0.00%) .          .          .               int exit = luaK_jump(fs);  
      750 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_jump (2x)
        6 ( 0.00%) .          .          .               luaK_patchtohere(fs, condexit);  
      834 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_patchtohere (2x)
       20 ( 0.00%) .          .          .               luaK_codeABC(fs, OP_CLOSE, reglevel(fs, bl2.nactvar), 0, 0);
      764 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (2x)
      190 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reglevel (2x)
        6 ( 0.00%) .          .          .               condexit = luaK_jump(fs);  
      750 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_jump (2x)
        8 ( 0.00%) .          .          .               luaK_patchtohere(fs, exit);  
      718 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_patchtohere (2x)
        .          .          .          .             }
       40 ( 0.00%) .          .          .             luaK_patchlist(fs, condexit, repeat_init);  
    3,447 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_patchlist (10x)
       20 ( 0.00%) .          .          .             leaveblock(fs);  
   10,690 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:leaveblock (10x)
       90 ( 0.00%) .          .          .           }
        .          .          .          .           
      450 ( 0.00%) .          .          .           static void exp1 (LexState *ls) {
        .          .          .          .             expdesc e;
      150 ( 0.00%) .          .          .             expr(ls, &e);
  136,936 ( 0.63%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:expr (75x)
      750 ( 0.00%) .          .          .             luaK_exp2nextreg(ls->fs, &e);
   58,728 ( 0.27%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2nextreg (75x)
      150 ( 0.00%) .          .          .             lua_assert(e.k == VNONRELOC);
      450 ( 0.00%) .          .          .           }
        .          .          .          .           
    1,012 ( 0.00%) .          .          .           static void fixforjump (FuncState *fs, int pc, int dest, int back) {
    1,840 ( 0.01%) .          .          .             Instruction *jmp = &fs->f->code[pc];
      644 ( 0.00%) .          .          .             int offset = dest - (pc + 1);
      184 ( 0.00%) .          .          .             if (back)
       92 ( 0.00%) .          .          .               offset = -offset;
      184 ( 0.00%) .          .          .             if (l_unlikely(offset > MAXARG_Bx))
        .          .          .          .               luaX_syntaxerror(fs->ls, "control structure too long");
    1,196 ( 0.01%) .          .          .             SETARG_Bx(*jmp, offset);
      736 ( 0.00%) .          .          .           }
        .          .          .          .           
      690 ( 0.00%) .          .          .           static void forbody (LexState *ls, int base, int line, int nvars, int isgen) {
        .          .          .          .             
        .          .          .          .             static const OpCode forprep[2] = {OP_FORPREP, OP_TFORPREP};
        .          .          .          .             static const OpCode forloop[2] = {OP_FORLOOP, OP_TFORLOOP};
        .          .          .          .             BlockCnt bl;
      368 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
        .          .          .          .             int prep, endfor;
      138 ( 0.00%) .          .          .             checknext(ls, TK_DO);
   70,121 ( 0.32%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checknext (44x)
    1,196 ( 0.01%) .          .          .             prep = luaK_codeABx(fs, forprep[isgen], base, 0);
   16,104 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABx (44x)
      184 ( 0.00%) .          .          .             enterblock(fs, &bl, 0);  
   11,166 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:enterblock (44x)
      138 ( 0.00%) .          .          .             adjustlocalvars(ls, nvars);
   21,203 ( 0.10%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:adjustlocalvars (44x)
      138 ( 0.00%) .          .          .             luaK_reserveregs(fs, nvars);
    2,585 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_reserveregs (44x)
       92 ( 0.00%) .          .          .             block(ls);
1,047,546 ( 4.83%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:block (32x)
  452,822 ( 2.09%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:block'2 (12x)
       92 ( 0.00%) .          .          .             leaveblock(fs);  
   22,970 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:leaveblock (44x)
      322 ( 0.00%) .          .          .             fixforjump(fs, prep, luaK_getlabel(fs), 0);
    2,772 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:fixforjump (44x)
    1,276 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_getlabel (44x)
       92 ( 0.00%) .          .          .             if (isgen) {  
       70 ( 0.00%) .          .          .               luaK_codeABC(fs, OP_TFORCALL, base, 0, nvars);
    3,820 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABCk (10x)
       40 ( 0.00%) .          .          .               luaK_fixline(fs, line);
    2,680 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_fixline (10x)
        .          .          .          .             }
    1,150 ( 0.01%) .          .          .             endfor = luaK_codeABx(fs, forloop[isgen], base, 0);
   18,782 ( 0.09%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_codeABx (44x)
      368 ( 0.00%) .          .          .             fixforjump(fs, endfor, prep + 1, 1);
    2,860 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:fixforjump (44x)
      138 ( 0.00%) .          .          .             luaK_fixline(fs, line);
   11,950 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_fixline (44x)
      506 ( 0.00%) .          .          .           }
        .          .          .          .           
      360 ( 0.00%) .          .          .           static void fornum (LexState *ls, TString *varname, int line) {
        .          .          .          .             
      288 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
      288 ( 0.00%) .          .          .             int base = fs->freereg;
      288 ( 0.00%) .          .          .             new_localvarliteral(ls, "(for state)");
   26,169 ( 0.12%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_newstring (34x)
    6,971 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:new_localvar (34x)
      252 ( 0.00%) .          .          .             new_localvarliteral(ls, "(for state)");
   25,146 ( 0.12%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_newstring (34x)
    6,426 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:new_localvar (34x)
      252 ( 0.00%) .          .          .             new_localvarliteral(ls, "(for state)");
   25,146 ( 0.12%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_newstring (34x)
    6,426 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:new_localvar (34x)
      108 ( 0.00%) .          .          .             new_localvar(ls, varname);
    6,426 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:new_localvar (34x)
      108 ( 0.00%) .          .          .             checknext(ls, '=');
   26,499 ( 0.12%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checknext (34x)
       72 ( 0.00%) .          .          .             exp1(ls);  
   38,128 ( 0.18%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:exp1 (34x)
      108 ( 0.00%) .          .          .             checknext(ls, ',');
   40,540 ( 0.19%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checknext (34x)
       72 ( 0.00%) .          .          .             exp1(ls);  
  129,214 ( 0.60%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:exp1 (34x)
      180 ( 0.00%) .          .          .             if (testnext(ls, ','))
    2,295 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:testnext (34x)
        6 ( 0.00%) .          .          .               exp1(ls);  
    5,759 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:exp1 (2x)
        .          .          .          .             else {  
      264 ( 0.00%) .          .          .               luaK_int(fs, fs->freereg, 1);
   12,692 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_int (32x)
      132 ( 0.00%) .          .          .               luaK_reserveregs(fs, 1);
    1,878 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_reserveregs (32x)
        .          .          .          .             }
      108 ( 0.00%) .          .          .             adjustlocalvars(ls, 3);  
   39,570 ( 0.18%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:adjustlocalvars (34x)
      216 ( 0.00%) .          .          .             forbody(ls, base, line, 1, 0);
1,298,317 ( 5.99%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:forbody (34x)
      288 ( 0.00%) .          .          .           }
        .          .          .          .           
      120 ( 0.00%) .          .          .           static void forlist (LexState *ls, TString *indexname) {
        .          .          .          .             
       80 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
        .          .          .          .             expdesc e;
       10 ( 0.00%) .          .          .             int nvars = 5;  
        .          .          .          .             int line;
       80 ( 0.00%) .          .          .             int base = fs->freereg;
        .          .          .          .             
       80 ( 0.00%) .          .          .             new_localvarliteral(ls, "(for state)");
    8,772 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_newstring (10x)
    1,890 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:new_localvar (10x)
       70 ( 0.00%) .          .          .             new_localvarliteral(ls, "(for state)");
    7,458 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_newstring (10x)
    1,890 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:new_localvar (10x)
       70 ( 0.00%) .          .          .             new_localvarliteral(ls, "(for state)");
    7,458 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_newstring (10x)
    1,890 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:new_localvar (10x)
       70 ( 0.00%) .          .          .             new_localvarliteral(ls, "(for state)");
    7,458 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_newstring (10x)
    1,890 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:new_localvar (10x)
        .          .          .          .             
       30 ( 0.00%) .          .          .             new_localvar(ls, indexname);
    2,724 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:new_localvar (10x)
       90 ( 0.00%) .          .          .             while (testnext(ls, ',')) {
    7,161 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:testnext (16x)
       30 ( 0.00%) .          .          .               new_localvar(ls, str_checkname(ls));
    1,134 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:new_localvar (6x)
    7,999 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:str_checkname (6x)
       24 ( 0.00%) .          .          .               nvars++;
        .          .          .          .             }
       30 ( 0.00%) .          .          .             checknext(ls, TK_IN);
   17,994 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checknext (10x)
       50 ( 0.00%) .          .          .             line = ls->linenumber;
       90 ( 0.00%) .          .          .             adjust_assign(ls, 4, explist(ls, &e), &e);
  104,274 ( 0.48%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:explist (10x)
    1,720 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:adjust_assign (10x)
       30 ( 0.00%) .          .          .             adjustlocalvars(ls, 4);  
   15,175 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:adjustlocalvars (10x)
       20 ( 0.00%) .          .          .             marktobeclosed(fs);  
      400 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:marktobeclosed (10x)
       30 ( 0.00%) .          .          .             luaK_checkstack(fs, 3);  
      361 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_checkstack (10x)
       90 ( 0.00%) .          .          .             forbody(ls, base, line, nvars - 4, 1);
  395,818 ( 1.83%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:forbody (10x)
      110 ( 0.00%) .          .          .           }
        .          .          .          .           
      460 ( 0.00%) .          .          .           static void forstat (LexState *ls, int line) {
        .          .          .          .             
      368 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
        .          .          .          .             TString *varname;
        .          .          .          .             BlockCnt bl;
      184 ( 0.00%) .          .          .             enterblock(fs, &bl, 1);  
   11,176 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:enterblock (44x)
       92 ( 0.00%) .          .          .             luaX_next(ls);  
   42,080 ( 0.19%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (44x)
      138 ( 0.00%) .          .          .             varname = str_checkname(ls);  
   15,055 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:str_checkname (44x)
      354 ( 0.00%) .          .          .             switch (ls->t.token) {
      144 ( 0.00%) .          .          .               case '=': fornum(ls, varname, line); break;
1,700,812 ( 7.85%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:fornum (34x)
       40 ( 0.00%) .          .          .               case ',': case TK_IN: forlist(ls, varname); break;
  594,670 ( 2.74%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:forlist (10x)
        .          .          .          .               default: luaX_syntaxerror(ls, "'=' or 'in' expected");
        .          .          .          .             }
      230 ( 0.00%) .          .          .             check_match(ls, TK_END, TK_FOR, line);
   94,423 ( 0.44%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_match (44x)
       92 ( 0.00%) .          .          .             leaveblock(fs);  
   72,015 ( 0.33%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:leaveblock (44x)
      414 ( 0.00%) .          .          .           }
        .          .          .          .           
      308 ( 0.00%) .          .          .           static void test_then_block (LexState *ls, int *escapelist) {
        .          .          .          .             
        .          .          .          .             BlockCnt bl;
      224 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
        .          .          .          .             expdesc v;
        .          .          .          .             int jf;  
       56 ( 0.00%) .          .          .             luaX_next(ls);  
  183,149 ( 0.85%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (25x)
       84 ( 0.00%) .          .          .             expr(ls, &v);  
  192,752 ( 0.89%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:expr (25x)
       84 ( 0.00%) .          .          .             checknext(ls, TK_THEN);
   58,700 ( 0.27%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checknext (25x)
      168 ( 0.00%) .          .          .             if (ls->t.token == TK_BREAK) {  
        .          .          .          .               int line = ls->linenumber;
        .          .          .          .               luaK_goiffalse(ls->fs, &v);  
        .          .          .          .               luaX_next(ls);  
        .          .          .          .               enterblock(fs, &bl, 0);  
        .          .          .          .               newgotoentry(ls, luaS_newliteral(ls->L, "break"), line, v.t);
        .          .          .          .               while (testnext(ls, ';')) {}  
        .          .          .          .               if (block_follow(ls, 0)) {  
        .          .          .          .                 leaveblock(fs);
        .          .          .          .                 return;  
        .          .          .          .               }
        .          .          .          .               else  
        .          .          .          .                 jf = luaK_jump(fs);
        .          .          .          .             }
        .          .          .          .             else {  
      196 ( 0.00%) .          .          .               luaK_goiftrue(ls->fs, &v);  
   31,901 ( 0.15%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_goiftrue (25x)
      112 ( 0.00%) .          .          .               enterblock(fs, &bl, 0);
    6,349 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:enterblock (25x)
       28 ( 0.00%) .          .          .               jf = v.f;
        .          .          .          .             }
       56 ( 0.00%) .          .          .             statlist(ls);  
3,350,544 (15.46%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:statlist'2 (25x)
       56 ( 0.00%) .          .          .             leaveblock(fs);
   13,720 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:leaveblock (25x)
      224 ( 0.00%) .          .          .             if (ls->t.token == TK_ELSE ||
        .          .          .          .                 ls->t.token == TK_ELSEIF)  
       49 ( 0.00%) .          .          .               luaK_concat(fs, escapelist, luaK_jump(fs));  
    1,875 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_jump (5x)
      145 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_concat (5x)
       84 ( 0.00%) .          .          .             luaK_patchtohere(fs, jf);
    9,599 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_patchtohere (25x)
      280 ( 0.00%) .          .          .           }
        .          .          .          .           
      243 ( 0.00%) .          .          .           static void ifstat (LexState *ls, int line) {
        .          .          .          .             
      216 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
       27 ( 0.00%) .          .          .             int escapelist = NO_JUMP;  
       81 ( 0.00%) .          .          .             test_then_block(ls, &escapelist);  
3,821,857 (17.63%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:test_then_block (24x)
      195 ( 0.00%) .          .          .             while (ls->t.token == TK_ELSEIF)
        3 ( 0.00%) .          .          .               test_then_block(ls, &escapelist);  
   49,779 ( 0.23%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:test_then_block'2 (1x)
      135 ( 0.00%) .          .          .             if (testnext(ls, TK_ELSE))
    7,128 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:testnext (24x)
       18 ( 0.00%) .          .          .               block(ls);  
  733,534 ( 3.38%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:block (2x)
  329,771 ( 1.52%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:block'2 (2x)
      135 ( 0.00%) .          .          .             check_match(ls, TK_END, TK_IF, line);
   69,427 ( 0.32%) 1 ( 0.19%) 24,904 ( 0.00%) 22,950 ( 0.00%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:check_match (24x)
       81 ( 0.00%) .          .          .             luaK_patchtohere(fs, escapelist);  
    3,256 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_patchtohere (24x)
      216 ( 0.00%) .          .          .           }
        .          .          .          .           
      104 ( 0.00%) .          .          .           static void localfunc (LexState *ls) {
        .          .          .          .             expdesc b;
      104 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
      104 ( 0.00%) .          .          .             int fvar = fs->nactvar;  
       65 ( 0.00%) .          .          .             new_localvar(ls, str_checkname(ls));  
    3,292 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:str_checkname (12x)
    2,778 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:new_localvar (12x)
       39 ( 0.00%) .          .          .             adjustlocalvars(ls, 1);  
    5,124 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:adjustlocalvars (12x)
      117 ( 0.00%) .          .          .             body(ls, &b, 0, ls->linenumber);  
1,679,076 ( 7.75%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:body (12x)
        .          .          .          .             
      221 ( 0.00%) .          .          .             localdebuginfo(fs, fvar)->startpc = fs->pc;
    1,260 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:localdebuginfo (12x)
      104 ( 0.00%) .          .          .           }
        .          .          .          .           
      632 ( 0.00%) .          .          .           static int getlocalattribute (LexState *ls) {
        .          .          .          .             
      632 ( 0.00%) .          .          .             if (testnext(ls, '<')) {
    3,002 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:testnext (158x)
        .          .          .          .               const char *attr = getstr(str_checkname(ls));
        .          .          .          .               checknext(ls, '>');
        .          .          .          .               if (strcmp(attr, "const") == 0)
        .          .          .          .                 return RDKCONST;  
        .          .          .          .               else if (strcmp(attr, "close") == 0)
        .          .          .          .                 return RDKTOCLOSE;  
        .          .          .          .               else
        .          .          .          .                 luaK_semerror(ls,
        .          .          .          .                   luaO_pushfstring(ls->L, "unknown attribute '%s'", attr));
        .          .          .          .             }
        .          .          .          .             return VDKREG;  
      632 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static void checktoclose (FuncState *fs, int level) {
      378 ( 0.00%) .          .          .             if (level != -1) {  
        .          .          .          .               marktobeclosed(fs);
        .          .          .          .               luaK_codeABC(fs, OP_TBC, reglevel(fs, level), 0, 0);
        .          .          .          .             }
        .          .          .          .           }
        .          .          .          .           
    1,386 ( 0.01%) .          .          .           static void localstat (LexState *ls) {
        .          .          .          .             
    1,008 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
      252 ( 0.00%) .          .          .             int toclose = -1;  
        .          .          .          .             Vardesc *var;  
        .          .          .          .             int vidx, kind;  
      126 ( 0.00%) .          .          .             int nvars = 0;
        .          .          .          .             int nexps;
        .          .          .          .             expdesc e;
        .          .          .          .             do {
      948 ( 0.00%) .          .          .               vidx = new_localvar(ls, str_checkname(ls));
   55,917 ( 0.26%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:str_checkname (155x)
   30,418 ( 0.14%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:new_localvar (155x)
      474 ( 0.00%) .          .          .               kind = getlocalattribute(ls);
    4,805 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getlocalattribute (155x)
    1,896 ( 0.01%) .          .          .               getlocalvardesc(fs, vidx)->vd.kind = kind;
    7,595 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getlocalvardesc (155x)
      316 ( 0.00%) .          .          .               if (kind == RDKTOCLOSE) {  
        .          .          .          .                 if (toclose != -1)  
        .          .          .          .                   luaK_semerror(ls, "multiple to-be-closed variables in local list");
        .          .          .          .                 toclose = fs->nactvar + nvars;
        .          .          .          .               }
      632 ( 0.00%) .          .          .               nvars++;
      790 ( 0.00%) .          .          .             } while (testnext(ls, ','));
  144,674 ( 0.67%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:testnext (155x)
      756 ( 0.00%) .          .          .             if (testnext(ls, '='))
  173,481 ( 0.80%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:testnext (123x)
      585 ( 0.00%) .          .          .               nexps = explist(ls, &e);
1,924,799 ( 8.88%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:explist (108x)
   76,183 ( 0.35%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:explist'2 (6x)
        .          .          .          .             else {
        9 ( 0.00%) .          .          .               e.k = VVOID;
        .          .          .          .               nexps = 0;
        .          .          .          .             }
      504 ( 0.00%) .          .          .             var = getlocalvardesc(fs, vidx);  
    6,027 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getlocalvardesc (123x)
      472 ( 0.00%) .          .          .             if (nvars == nexps &&  
      770 ( 0.00%) .          .          .                 var->vd.kind == RDKCONST &&  
        .          .          .          .                 luaK_exp2const(fs, &e, &var->k)) {  
        .          .          .          .               var->vd.kind = RDKCTC;  
        .          .          .          .               adjustlocalvars(ls, nvars - 1);  
        .          .          .          .               fs->nactvar++;  
        .          .          .          .             }
        .          .          .          .             else {
      630 ( 0.00%) .          .          .               adjust_assign(ls, nvars, nexps, &e);
   61,003 ( 0.28%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:adjust_assign (123x)
      378 ( 0.00%) .          .          .               adjustlocalvars(ls, nvars);
   81,575 ( 0.38%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:adjustlocalvars (123x)
        .          .          .          .             }
      378 ( 0.00%) .          .          .             checktoclose(fs, toclose);
      369 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:checktoclose (123x)
    1,386 ( 0.01%) .          .          .           }
        .          .          .          .           
       15 ( 0.00%) .          .          .           static int funcname (LexState *ls, expdesc *v) {
        .          .          .          .             
        2 ( 0.00%) .          .          .             int ismethod = 0;
        3 ( 0.00%) .          .          .             singlevar(ls, v);
    5,585 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:singlevar (3x)
       33 ( 0.00%) .          .          .             while (ls->t.token == '.')
        .          .          .          .               fieldsel(ls, v);
       18 ( 0.00%) .          .          .             if (ls->t.token == ':') {
        2 ( 0.00%) .          .          .               ismethod = 1;
        3 ( 0.00%) .          .          .               fieldsel(ls, v);
    4,407 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:fieldsel (1x)
        .          .          .          .             }
        .          .          .          .             return ismethod;
       12 ( 0.00%) .          .          .           }
        .          .          .          .           
       27 ( 0.00%) .          .          .           static void funcstat (LexState *ls, int line) {
        .          .          .          .             
        .          .          .          .             int ismethod;
        .          .          .          .             expdesc v, b;
        3 ( 0.00%) .          .          .             luaX_next(ls);  
    7,803 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (3x)
       15 ( 0.00%) .          .          .             ismethod = funcname(ls, &v);
   10,080 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:funcname (3x)
       12 ( 0.00%) .          .          .             body(ls, &b, ismethod, line);
  371,457 ( 1.71%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:body (3x)
        9 ( 0.00%) .          .          .             check_readonly(ls, &v);
       84 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_readonly (3x)
       33 ( 0.00%) .          .          .             luaK_storevar(ls->fs, &v, &b);
    2,244 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_storevar (3x)
       21 ( 0.00%) .          .          .             luaK_fixline(ls->fs, line);  
      804 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_fixline (3x)
       24 ( 0.00%) .          .          .           }
        .          .          .          .           
    3,234 ( 0.01%) .          .          .           static void exprstat (LexState *ls) {
        .          .          .          .             
    3,696 ( 0.02%) .          .          .             FuncState *fs = ls->fs;
        .          .          .          .             struct LHS_assign v;
    1,386 ( 0.01%) .          .          .             suffixedexp(ls, &v.v);
6,156,039 (28.40%) 1 ( 0.19%) 26,259 ( 0.00%) 24,752 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:suffixedexp (424x)
    5,082 ( 0.02%) .          .          .             if (ls->t.token == '=' || ls->t.token == ',') { 
      178 ( 0.00%) .          .          .               v.prev = NULL;
      890 ( 0.00%) .          .          .               restassign(ls, &v, 1);
2,913,958 (13.44%) 2 ( 0.37%) 39,203 ( 0.01%) 36,396 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:restassign (163x)
        .          .          .          .             }
        .          .          .          .             else {  
        .          .          .          .               Instruction *inst;
      568 ( 0.00%) .          .          .               check_condition(ls, v.v.k == VCALL, "syntax error");
    5,396 ( 0.02%) .          .          .               inst = &getinstruction(fs, &v.v);
    3,408 ( 0.02%) .          .          .               SETARG_C(*inst, 1);  
        .          .          .          .             }
    3,234 ( 0.01%) .          .          .           }
        .          .          .          .           
      242 ( 0.00%) .          .          .           static void retstat (LexState *ls) {
        .          .          .          .             
      176 ( 0.00%) .          .          .             FuncState *fs = ls->fs;
        .          .          .          .             expdesc e;
        .          .          .          .             int nret;  
       66 ( 0.00%) .          .          .             int first = luaY_nvarstack(fs);  
    1,732 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaY_nvarstack (22x)
      258 ( 0.00%) .          .          .             if (block_follow(ls, 1) || ls->t.token == ';')
      529 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:block_follow (22x)
        2 ( 0.00%) .          .          .               nret = 0;  
        .          .          .          .             else {
       84 ( 0.00%) .          .          .               nret = explist(ls, &e);  
  147,877 ( 0.68%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:explist (10x)
   33,300 ( 0.15%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:explist'2 (11x)
       84 ( 0.00%) .          .          .               if (hasmultret(e.k)) {
       12 ( 0.00%) .          .          .                 luaK_setmultret(fs, &e);
      195 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_setreturns (3x)
       63 ( 0.00%) .          .          .                 if (e.k == VCALL && nret == 1 && !fs->bl->insidetbc) {  
      147 ( 0.00%) .          .          .                   SET_OPCODE(getinstruction(fs,&e), OP_TAILCALL);
       90 ( 0.00%) .          .          .                   lua_assert(GETARG_A(getinstruction(fs,&e)) == luaY_nvarstack(fs));
      327 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaY_nvarstack (3x)
        .          .          .          .                 }
        6 ( 0.00%) .          .          .                 nret = LUA_MULTRET;  
        .          .          .          .               }
        .          .          .          .               else {
       36 ( 0.00%) .          .          .                 if (nret == 1)  
       90 ( 0.00%) .          .          .                   first = luaK_exp2anyreg(fs, &e);  
   16,617 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_exp2anyreg (18x)
        .          .          .          .                 else {  
        .          .          .          .                   luaK_exp2nextreg(fs, &e);
        .          .          .          .                   lua_assert(nret == fs->freereg - first);
        .          .          .          .                 }
        .          .          .          .               }
        .          .          .          .             }
       88 ( 0.00%) .          .          .             luaK_ret(fs, first, nret);
   10,473 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaK_ret (22x)
       66 ( 0.00%) .          .          .             testnext(ls, ';');  
      418 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:testnext (22x)
      242 ( 0.00%) .          .          .           }
        .          .          .          .           
    4,656 ( 0.02%) .          .          .           static void statement (LexState *ls) {
    6,208 ( 0.03%) .          .          .             int line = ls->linenumber;  
    6,984 ( 0.03%) .          .          .             enterlevel(ls);
    5,992 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaE_incCstack (214x)
   10,246 ( 0.05%) .          .          .             switch (ls->t.token) {
        .          .          .          .               case ';': {  
      100 ( 0.00%) .          .          .                 luaX_next(ls);  
   24,213 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (10x)
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_IF: {  
       81 ( 0.00%) .          .          .                 ifstat(ls, line);
4,025,267 (18.57%) 1 ( 0.19%) 24,904 ( 0.00%) 22,950 ( 0.00%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:ifstat (13x)
       27 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_WHILE: {  
        9 ( 0.00%) .          .          .                 whilestat(ls, line);
  188,981 ( 0.87%) 2 ( 0.37%) 39,203 ( 0.01%) 36,396 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:whilestat (3x)
        3 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_DO: {  
       28 ( 0.00%) .          .          .                 luaX_next(ls);  
   38,660 ( 0.18%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (12x)
       28 ( 0.00%) .          .          .                 block(ls);
4,581,233 (21.14%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:block (12x)
       70 ( 0.00%) .          .          .                 check_match(ls, TK_END, TK_DO, line);
   67,784 ( 0.31%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check_match (12x)
       14 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_FOR: {  
      138 ( 0.00%) .          .          .                 forstat(ls, line);
1,335,283 ( 6.16%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:forstat (25x)
       46 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_REPEAT: {  
       30 ( 0.00%) .          .          .                 repeatstat(ls, line);
  337,942 ( 1.56%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:repeatstat (10x)
       10 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_FUNCTION: {  
        9 ( 0.00%) .          .          .                 funcstat(ls, line);
  186,977 ( 0.86%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:funcstat (1x)
        3 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_LOCAL: {  
      278 ( 0.00%) .          .          .                 luaX_next(ls);  
  102,019 ( 0.47%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (39x)
      695 ( 0.00%) .          .          .                 if (testnext(ls, TK_FUNCTION))  
   15,296 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:testnext (39x)
       39 ( 0.00%) .          .          .                   localfunc(ls);
  992,004 ( 4.58%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:localfunc (6x)
        .          .          .          .                 else
      378 ( 0.00%) .          .          .                   localstat(ls);
  557,260 ( 2.57%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:localstat (33x)
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_DBCOLON: {  
        .          .          .          .                 luaX_next(ls);  
        .          .          .          .                 labelstat(ls, str_checkname(ls), line);
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_RETURN: {  
       44 ( 0.00%) .          .          .                 luaX_next(ls);  
   33,888 ( 0.16%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (22x)
       44 ( 0.00%) .          .          .                 retstat(ls);
  213,220 ( 0.98%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:retstat (22x)
       22 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_BREAK: {  
        .          .          .          .                 breakstat(ls);
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               case TK_GOTO: {  
        .          .          .          .                 luaX_next(ls);  
        .          .          .          .                 gotostat(ls);
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .               default: {  
      924 ( 0.00%) .          .          .                 exprstat(ls);
2,189,418 (10.10%) 1 ( 0.19%) 26,259 ( 0.00%) 24,752 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:exprstat (111x)
      462 ( 0.00%) .          .          .                 break;
        .          .          .          .               }
        .          .          .          .             }
   38,024 ( 0.18%) .          .          .             lua_assert(ls->fs->f->maxstacksize >= ls->fs->freereg &&
   23,252 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaY_nvarstack (214x)
        .          .          .          .                        ls->fs->freereg >= luaY_nvarstack(ls->fs));
   15,520 ( 0.07%) .          .          .             ls->fs->freereg = luaY_nvarstack(ls->fs);  
   23,252 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaY_nvarstack (214x)
   14,744 ( 0.07%) .          .          .             leavelevel(ls);
    4,656 ( 0.02%) .          .          .           }
        .          .          .          .           
       22 ( 0.00%) .          .          .           static void mainfunc (LexState *ls, FuncState *fs) {
        .          .          .          .             BlockCnt bl;
        .          .          .          .             Upvaldesc *env;
        4 ( 0.00%) .          .          .             open_func(ls, fs, &bl);
      740 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:open_func (2x)
        6 ( 0.00%) .          .          .             setvararg(fs, 0);  
    1,986 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:setvararg (2x)
        6 ( 0.00%) .          .          .             env = allocupvalue(fs);  
    1,204 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:allocupvalue (2x)
       16 ( 0.00%) .          .          .             env->instack = 1;
       16 ( 0.00%) .          .          .             env->idx = 0;
       16 ( 0.00%) .          .          .             env->kind = VDKREG;
       26 ( 0.00%) .          .          .             env->name = ls->envn;
       28 ( 0.00%) .          .          .             luaC_objbarrier(ls->L, fs->f, env->name);
        4 ( 0.00%) .          .          .             luaX_next(ls);  
   22,766 ( 0.11%) 4 ( 0.75%) 66,125 ( 0.01%) 62,772 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_next (2x)
        4 ( 0.00%) .          .          .             statlist(ls);  
14,394,628 (66.42%) 4 ( 0.75%) 90,366 ( 0.02%) 84,098 ( 0.02%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:statlist (2x)
        6 ( 0.00%) .          .          .             check(ls, TK_EOS);
       36 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:check (2x)
        4 ( 0.00%) .          .          .             close_func(ls);
  333,006 ( 1.54%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:close_func (2x)
       20 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LClosure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
       32 ( 0.00%) .          .          .                                  Dyndata *dyd, const char *name, int firstchar) {
        .          .          .          .             LexState lexstate;
        .          .          .          .             FuncState funcstate;
        6 ( 0.00%) .          .          .             LClosure *cl = luaF_newLclosure(L, 1);  
      846 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_newLclosure (2x)
      200 ( 0.00%) .          .          .             setclLvalue2s(L, L->top, cl);  
        4 ( 0.00%) .          .          .             luaD_inctop(L);
       74 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_inctop (2x)
        8 ( 0.00%) .          .          .             lexstate.h = luaH_new(L);  
      880 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_new (2x)
      194 ( 0.00%) .          .          .             sethvalue2s(L, L->top, lexstate.h);  
        4 ( 0.00%) .          .          .             luaD_inctop(L);
       74 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_inctop (2x)
       32 ( 0.00%) .          .          .             funcstate.f = cl->p = luaF_newproto(L);
      829 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_newproto (2x)
       12 ( 0.00%) .          .          .             luaC_objbarrier(L, cl, cl->p);
       26 ( 0.00%) .          .          .             funcstate.f->source = luaS_new(L, name);  
    1,137 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_new (2x)
       20 ( 0.00%) .          .          .             luaC_objbarrier(L, funcstate.f, funcstate.f->source);
        2 ( 0.00%) .          .          .             lexstate.buff = buff;
        2 ( 0.00%) .          .          .             lexstate.dyd = dyd;
       52 ( 0.00%) .          .          .             dyd->actvar.n = dyd->gt.n = dyd->label.n = 0;
       30 ( 0.00%) .          .          .             luaX_setinput(L, &lexstate, z, funcstate.f->source, firstchar);
    1,474 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_setinput (2x)
        6 ( 0.00%) .          .          .             mainfunc(&lexstate, &funcstate);
14,754,544 (68.08%) 8 ( 1.50%) 156,491 ( 0.03%) 146,870 ( 0.03%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:mainfunc (2x)
       12 ( 0.00%) .          .          .             lua_assert(!funcstate.prev && funcstate.nups == 1 && !lexstate.fs);
        .          .          .          .             
       36 ( 0.00%) .          .          .             lua_assert(dyd->actvar.n == 0 && dyd->gt.n == 0 && dyd->label.n == 0);
       28 ( 0.00%) .          .          .             L->top--;  
        .          .          .          .             return cl;  
       24 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           // root include lstate.c
        .          .          .          .           
        .          .          .          .           //included "stddef.h" 
        .          .          .          .           //included "string.h" 
        .          .          .          .           
        .          .          .          .           typedef struct LX {
        .          .          .          .             lu_byte extra_[LUA_EXTRASPACE];
-- line 10401 ----------------------------------------
-- line 10409 ----------------------------------------
        .          .          .          .           
        .          .          .          .           #define fromstate(L)	(cast(LX *, cast(lu_byte *, (L)) - offsetof(LX, l)))
        .          .          .          .           
        .          .          .          .           #if !defined(luai_makeseed)
        .          .          .          .           #include <time.h>
        .          .          .          .           
        .          .          .          .           #define addbuff(b,p,e)   { size_t t = cast_sizet(e);     memcpy(b + p, &t, sizeof(t)); p += sizeof(t); }
        .          .          .          .           
        6 ( 0.00%) .          .          .           static unsigned int luai_makeseed (lua_State *L) {
        .          .          .          .             char buff[3 * sizeof(size_t)];
        9 ( 0.00%) .          .          .             unsigned int h = cast_uint(time(NULL));
      774 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
        6 ( 0.00%) 1 ( 0.19%) 6,806 ( 0.00%) 4,726 ( 0.00%)  => /usr/src/debug/glibc/glibc/time/../sysdeps/unix/sysv/linux/time.c:time_syscall (1x)
        .          .          .          .             int p = 0;
        1 ( 0.00%) .          .          .             addbuff(buff, p, L);  
        2 ( 0.00%) .          .          .             addbuff(buff, p, &h);  
        2 ( 0.00%) .          .          .             addbuff(buff, p, &lua_newstate);  
        .          .          .          .             lua_assert(p == sizeof(buff));
        3 ( 0.00%) .          .          .             return luaS_hash(buff, p, h);
      571 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_hash (1x)
        6 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #endif
        .          .          .          .           
       45 ( 0.00%) .          .          .           void luaE_setdebt (global_State *g, l_mem debt) {
      100 ( 0.00%) .          .          .             l_mem tb = gettotalbytes(g);
       10 ( 0.00%) .          .          .             lua_assert(tb > 0);
       40 ( 0.00%) .          .          .             if (debt < tb - MAX_LMEM)
        .          .          .          .               debt = tb - MAX_LMEM;  
       35 ( 0.00%) .          .          .             g->totalbytes = tb - debt;
       25 ( 0.00%) .          .          .             g->GCdebt = debt;
       40 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API int lua_setcstacklimit (lua_State *L, unsigned int limit) {
        .          .          .          .             UNUSED(L); UNUSED(limit);
        .          .          .          .             return LUAI_MAXCCALLS;  
        .          .          .          .           }
        .          .          .          .           
       28 ( 0.00%) .          .          .           CallInfo *luaE_extendCI (lua_State *L) {
        .          .          .          .             CallInfo *ci;
      119 ( 0.00%) .          .          .             lua_assert(L->ci->next == NULL);
       35 ( 0.00%) .          .          .             ci = luaM_new(L, CallInfo);
    1,795 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_malloc_ (7x)
       98 ( 0.00%) .          .          .             lua_assert(L->ci->next == NULL);
       63 ( 0.00%) .          .          .             L->ci->next = ci;
       91 ( 0.00%) .          .          .             ci->previous = L->ci;
       56 ( 0.00%) .          .          .             ci->next = NULL;
       56 ( 0.00%) .          .          .             ci->u.l.trap = 0;
       77 ( 0.00%) .          .          .             L->nci++;
        .          .          .          .             return ci;
       35 ( 0.00%) .          .          .           }
        .          .          .          .           
        4 ( 0.00%) .          .          .           void luaE_freeCI (lua_State *L) {
        8 ( 0.00%) .          .          .             CallInfo *ci = L->ci;
        8 ( 0.00%) .          .          .             CallInfo *next = ci->next;
        5 ( 0.00%) .          .          .             ci->next = NULL;
        7 ( 0.00%) .          .          .             while ((ci = next) != NULL) {
       18 ( 0.00%) .          .          .               next = ci->next;
        8 ( 0.00%) .          .          .               luaM_free(L, ci);
      358 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (2x)
       22 ( 0.00%) .          .          .               L->nci--;
        .          .          .          .             }
        4 ( 0.00%) .          .          .           }
        .          .          .          .           
       36 ( 0.00%) .          .          .           void luaE_shrinkCI (lua_State *L) {
       96 ( 0.00%) .          .          .             CallInfo *ci = L->ci->next;  
        .          .          .          .             CallInfo *next;
       12 ( 0.00%) .          .          .             if (ci == NULL)
        .          .          .          .               return;  
       66 ( 0.00%) .          .          .             while ((next = ci->next) != NULL) {  
       35 ( 0.00%) .          .          .               CallInfo *next2 = next->next;  
       30 ( 0.00%) .          .          .               ci->next = next2;  
       55 ( 0.00%) .          .          .               L->nci--;
       20 ( 0.00%) .          .          .               luaM_free(L, next);  
      790 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (5x)
       10 ( 0.00%) .          .          .               if (next2 == NULL)
        .          .          .          .                 break;  
        .          .          .          .               else {
       14 ( 0.00%) .          .          .                 next2->previous = ci;
        2 ( 0.00%) .          .          .                 ci = next2;  
        .          .          .          .               }
        .          .          .          .             }
       36 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaE_checkcstack (lua_State *L) {
        .          .          .          .             if (getCcalls(L) == LUAI_MAXCCALLS)
        .          .          .          .               luaG_runerror(L, "C stack overflow");
        .          .          .          .             else if (getCcalls(L) >= (LUAI_MAXCCALLS / 10 * 11))
        .          .          .          .               luaD_throw(L, LUA_ERRERR);  
        .          .          .          .           }
        .          .          .          .           
    8,748 ( 0.04%) .          .          .           LUAI_FUNC void luaE_incCstack (lua_State *L) {
   30,618 ( 0.14%) .          .          .             L->nCcalls++;
   13,122 ( 0.06%) .          .          .             if (l_unlikely(getCcalls(L) >= LUAI_MAXCCALLS))
        .          .          .          .               luaE_checkcstack(L);
    8,748 ( 0.04%) .          .          .           }
        .          .          .          .           
        7 ( 0.00%) .          .          .           static void stack_init (lua_State *L1, lua_State *L) {
        .          .          .          .             int i; CallInfo *ci;
        .          .          .          .             
       12 ( 0.00%) .          .          .             L1->stack = luaM_newvector(L, BASIC_STACK_SIZE + EXTRA_STACK, StackValue);
      267 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_malloc_ (1x)
       12 ( 0.00%) .          .          .             L1->tbclist = L1->stack;
      274 ( 0.00%) .          .          .             for (i = 0; i < BASIC_STACK_SIZE + EXTRA_STACK; i++)
      855 ( 0.00%) .          .          .               setnilvalue(s2v(L1->stack + i));  
       10 ( 0.00%) .          .          .             L1->top = L1->stack;
       13 ( 0.00%) .          .          .             L1->stack_last = L1->stack + BASIC_STACK_SIZE;
        .          .          .          .             
        7 ( 0.00%) .          .          .             ci = &L1->base_ci;
       21 ( 0.00%) .          .          .             ci->next = ci->previous = NULL;
        8 ( 0.00%) .          .          .             ci->callstatus = CIST_C;
        9 ( 0.00%) .          .          .             ci->func = L1->top;
        5 ( 0.00%) .          .          .             ci->u.c.k = NULL;
        5 ( 0.00%) .          .          .             ci->nresults = 0;
        9 ( 0.00%) .          .          .             setnilvalue(s2v(L1->top));  
       14 ( 0.00%) .          .          .             L1->top++;
       13 ( 0.00%) .          .          .             ci->top = L1->top + LUA_MINSTACK;
        5 ( 0.00%) .          .          .             L1->ci = ci;
        6 ( 0.00%) .          .          .           }
        .          .          .          .           
        4 ( 0.00%) .          .          .           static void freestack (lua_State *L) {
        9 ( 0.00%) .          .          .             if (L->stack == NULL)
        .          .          .          .               return;  
       13 ( 0.00%) .          .          .             L->ci = &L->base_ci;  
        2 ( 0.00%) .          .          .             luaE_freeCI(L);
      442 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaE_freeCI (1x)
        6 ( 0.00%) .          .          .             lua_assert(L->nci == 0);
       26 ( 0.00%) .          .          .             luaM_freearray(L, L->stack, stacksize(L) + EXTRA_STACK);  
      158 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (1x)
        4 ( 0.00%) .          .          .           }
        .          .          .          .           
        7 ( 0.00%) .          .          .           static void init_registry (lua_State *L, global_State *g) {
        .          .          .          .             
        2 ( 0.00%) .          .          .             Table *registry = luaH_new(L);
      440 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_new (1x)
       96 ( 0.00%) .          .          .             sethvalue(L, &g->l_registry, registry);
        5 ( 0.00%) .          .          .             luaH_resize(L, registry, LUA_RIDX_LAST, 0);
      711 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_resize (1x)
        .          .          .          .             
       96 ( 0.00%) .          .          .             setthvalue(L, &registry->array[LUA_RIDX_MAINTHREAD - 1], L);
        .          .          .          .             
      100 ( 0.00%) .          .          .             sethvalue(L, &registry->array[LUA_RIDX_GLOBALS - 1], luaH_new(L));
      440 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_new (1x)
        6 ( 0.00%) .          .          .           }
        .          .          .          .           
        4 ( 0.00%) .          .          .           static void f_luaopen (lua_State *L, void *ud) {
        8 ( 0.00%) .          .          .             global_State *g = G(L);
        .          .          .          .             UNUSED(ud);
        3 ( 0.00%) .          .          .             stack_init(L, L);  
    1,552 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:stack_init (1x)
        3 ( 0.00%) .          .          .             init_registry(L, g);
    1,903 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:init_registry (1x)
        2 ( 0.00%) .          .          .             luaS_init(L);
    8,681 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_init (1x)
        2 ( 0.00%) .          .          .             luaT_init(L);
   30,810 ( 0.14%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaT_init (1x)
        2 ( 0.00%) .          .          .             luaX_init(L);
   24,202 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaX_init (1x)
        8 ( 0.00%) .          .          .             g->gcstp = 0;  
        5 ( 0.00%) .          .          .             setnilvalue(&g->nilvalue);  
        .          .          .          .             luai_userstateopen(L);
        4 ( 0.00%) .          .          .           }
        .          .          .          .           
        5 ( 0.00%) .          .          .           static void preinit_thread (lua_State *L, global_State *g) {
        8 ( 0.00%) .          .          .             G(L) = g;
        8 ( 0.00%) .          .          .             L->stack = NULL;
        5 ( 0.00%) .          .          .             L->ci = NULL;
        5 ( 0.00%) .          .          .             L->nci = 0;
        8 ( 0.00%) .          .          .             L->twups = L;  
        8 ( 0.00%) .          .          .             L->nCcalls = 0;
        5 ( 0.00%) .          .          .             L->errorJmp = NULL;
        5 ( 0.00%) .          .          .             L->hook = NULL;
        8 ( 0.00%) .          .          .             L->hookmask = 0;
        5 ( 0.00%) .          .          .             L->basehookcount = 0;
        5 ( 0.00%) .          .          .             L->allowhook = 1;
        9 ( 0.00%) .          .          .             resethookcount(L);
        5 ( 0.00%) .          .          .             L->openupval = NULL;
        5 ( 0.00%) .          .          .             L->status = LUA_OK;
        5 ( 0.00%) .          .          .             L->errfunc = 0;
        5 ( 0.00%) .          .          .             L->oldpc = 0;
        4 ( 0.00%) .          .          .           }
        .          .          .          .           
        6 ( 0.00%) .          .          .           static void close_state (lua_State *L) {
        8 ( 0.00%) .          .          .             global_State *g = G(L);
        9 ( 0.00%) .          .          .             if (!completestate(g))  
        .          .          .          .               luaC_freeallobjects(L);  
        .          .          .          .             else {  
       13 ( 0.00%) .          .          .               L->ci = &L->base_ci;  
        4 ( 0.00%) .          .          .               luaD_closeprotected(L, 1, LUA_OK);  
      251 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_closeprotected (1x)
        3 ( 0.00%) .          .          .               luaC_freeallobjects(L);  
  252,884 ( 1.17%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_freeallobjects (1x)
        .          .          .          .               luai_userstateclose(L);
        .          .          .          .             }
       26 ( 0.00%) .          .          .             luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size);
      201 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (1x)
        2 ( 0.00%) .          .          .             freestack(L);
      664 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freestack (1x)
       15 ( 0.00%) .          .          .             lua_assert(gettotalbytes(g) == sizeof(LG));
       18 ( 0.00%) .          .          .             (*g->frealloc)(g->ud, fromstate(L), sizeof(LG), 0);  
      142 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:l_alloc (1x)
        6 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           LUA_API lua_State *lua_newthread (lua_State *L) {
        .          .          .          .             global_State *g;
        .          .          .          .             lua_State *L1;
        .          .          .          .             lua_lock(L);
        .          .          .          .             g = G(L);
        .          .          .          .             luaC_checkGC(L);
        .          .          .          .             
-- line 10596 ----------------------------------------
-- line 10647 ----------------------------------------
        .          .          .          .           LUA_API int lua_resetthread (lua_State *L) {
        .          .          .          .             int status;
        .          .          .          .             lua_lock(L);
        .          .          .          .             status = luaE_resetthread(L, L->status);
        .          .          .          .             lua_unlock(L);
        .          .          .          .             return status;
        .          .          .          .           }
        .          .          .          .           
        9 ( 0.00%) .          .          .           LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
        .          .          .          .             int i;
        .          .          .          .             lua_State *L;
        .          .          .          .             global_State *g;
        6 ( 0.00%) .          .          .             LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)));
      906 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:l_alloc (1x)
        2 ( 0.00%) .          .          .             if (l == NULL) return NULL;
        7 ( 0.00%) .          .          .             L = &l->l.l;
        8 ( 0.00%) .          .          .             g = &l->g;
        9 ( 0.00%) .          .          .             L->tt = LUA_VTHREAD;
        8 ( 0.00%) .          .          .             g->currentwhite = bitmask(WHITE0BIT);
       13 ( 0.00%) .          .          .             L->marked = luaC_white(g);
        3 ( 0.00%) .          .          .             preinit_thread(L, g);
      108 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:preinit_thread (1x)
       21 ( 0.00%) .          .          .             g->allgc = obj2gco(L);  
        6 ( 0.00%) .          .          .             L->next = NULL;
       16 ( 0.00%) .          .          .             incnny(L);  
        5 ( 0.00%) .          .          .             g->frealloc = f;
        5 ( 0.00%) .          .          .             g->ud = ud;
        8 ( 0.00%) .          .          .             g->warnf = NULL;
        8 ( 0.00%) .          .          .             g->ud_warn = NULL;
        5 ( 0.00%) .          .          .             g->mainthread = L;
        8 ( 0.00%) .          .          .             g->seed = luai_makeseed(L);
    1,380 ( 0.01%) 1 ( 0.19%) 6,806 ( 0.00%) 4,726 ( 0.00%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luai_makeseed (1x)
        5 ( 0.00%) .          .          .             g->gcstp = GCSTPGC;  
       14 ( 0.00%) .          .          .             g->strt.size = g->strt.nuse = 0;
        5 ( 0.00%) .          .          .             g->strt.hash = NULL;
        5 ( 0.00%) .          .          .             setnilvalue(&g->l_registry);
        5 ( 0.00%) .          .          .             g->panic = NULL;
        5 ( 0.00%) .          .          .             g->gcstate = GCSpause;
        5 ( 0.00%) .          .          .             g->gckind = KGC_INC;
        5 ( 0.00%) .          .          .             g->gcstopem = 0;
        5 ( 0.00%) .          .          .             g->gcemergency = 0;
       23 ( 0.00%) .          .          .             g->finobj = g->tobefnz = g->fixedgc = NULL;
       32 ( 0.00%) .          .          .             g->firstold1 = g->survival = g->old1 = g->reallyold = NULL;
       23 ( 0.00%) .          .          .             g->finobjsur = g->finobjold1 = g->finobjrold = NULL;
        5 ( 0.00%) .          .          .             g->sweepgc = NULL;
       14 ( 0.00%) .          .          .             g->gray = g->grayagain = NULL;
       23 ( 0.00%) .          .          .             g->weak = g->ephemeron = g->allweak = NULL;
        5 ( 0.00%) .          .          .             g->twups = NULL;
        5 ( 0.00%) .          .          .             g->totalbytes = sizeof(LG);
        5 ( 0.00%) .          .          .             g->GCdebt = 0;
        5 ( 0.00%) .          .          .             g->lastatomic = 0;
       18 ( 0.00%) .          .          .             setivalue(&g->nilvalue, 0);  
        5 ( 0.00%) .          .          .             setgcparam(g->gcpause, LUAI_GCPAUSE);
        5 ( 0.00%) .          .          .             setgcparam(g->gcstepmul, LUAI_GCMUL);
        5 ( 0.00%) .          .          .             g->gcstepsize = LUAI_GCSTEPSIZE;
        5 ( 0.00%) .          .          .             setgcparam(g->genmajormul, LUAI_GENMAJORMUL);
        5 ( 0.00%) .          .          .             g->genminormul = LUAI_GENMINORMUL;
      202 ( 0.00%) .          .          .             for (i=0; i < LUA_NUMTAGS; i++) g->mt[i] = NULL;
        6 ( 0.00%) .          .          .             if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) {
   68,052 ( 0.31%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_rawrunprotected (1x)
        .          .          .          .               
        .          .          .          .               close_state(L);
        .          .          .          .               L = NULL;
        .          .          .          .             }
        .          .          .          .             return L;
        9 ( 0.00%) .          .          .           }
        .          .          .          .           
        2 ( 0.00%) .          .          .           LUA_API void lua_close (lua_State *L) {
        .          .          .          .             lua_lock(L);
       16 ( 0.00%) .          .          .             L = G(L)->mainthread;  
        1 ( 0.00%) .          .          .             close_state(L);
  254,252 ( 1.17%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:close_state (1x)
        2 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaE_warning (lua_State *L, const char *msg, int tocont) {
        .          .          .          .             lua_WarnFunction wf = G(L)->warnf;
        .          .          .          .             if (wf != NULL)
        .          .          .          .               wf(G(L)->ud_warn, msg, tocont);
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaE_warnerror (lua_State *L, const char *where) {
-- line 10722 ----------------------------------------
-- line 10733 ----------------------------------------
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           // root include lstring.c
        .          .          .          .           
        .          .          .          .           //included "string.h" 
        .          .          .          .           
        .          .          .          .           #define MAXSTRTB	cast_int(luaM_limitN(MAX_INT, TString*))
        .          .          .          .           
       45 ( 0.00%) .          .          .           int luaS_eqlngstr (TString *a, TString *b) {
       72 ( 0.00%) .          .          .             size_t len = a->u.lnglen;
      135 ( 0.00%) .          .          .             lua_assert(a->tt == LUA_VLNGSTR && b->tt == LUA_VLNGSTR);
       36 ( 0.00%) .          .          .             return (a == b) ||  
        .          .          .          .               ((len == b->u.lnglen) &&  
        .          .          .          .                (memcmp(getstr(a), getstr(b), len) == 0));  
       36 ( 0.00%) .          .          .           }
        .          .          .          .           
   20,118 ( 0.09%) .          .          .           unsigned int luaS_hash (const char *str, size_t l, unsigned int seed) {
    5,748 ( 0.03%) .          .          .             unsigned int h = seed ^ cast_uint(l);
   38,414 ( 0.18%) .          .          .             for (; l > 0; l--)
  312,816 ( 1.44%) .          .          .               h ^= ((h<<5) + (h>>2) + cast_byte(str[l - 1]));
        .          .          .          .             return h;
   20,118 ( 0.09%) .          .          .           }
        .          .          .          .           
      176 ( 0.00%) .          .          .           unsigned int luaS_hashlongstr (TString *ts) {
      396 ( 0.00%) .          .          .             lua_assert(ts->tt == LUA_VLNGSTR);
      396 ( 0.00%) .          .          .             if (ts->extra == 0) {  
       72 ( 0.00%) .          .          .               size_t len = ts->u.lnglen;
      198 ( 0.00%) .          .          .               ts->hash = luaS_hash(getstr(ts), len, ts->hash);
   14,224 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_hash (9x)
       54 ( 0.00%) .          .          .               ts->extra = 1;  
        .          .          .          .             }
      352 ( 0.00%) .          .          .             return ts->hash;
      176 ( 0.00%) .          .          .           }
        .          .          .          .           
       30 ( 0.00%) .          .          .           static void tablerehash (TString **vect, int osize, int nsize) {
        .          .          .          .             int i;
    3,599 ( 0.02%) .          .          .             for (i = osize; i < nsize; i++)  
    5,632 ( 0.03%) .          .          .               vect[i] = NULL;
    2,703 ( 0.01%) .          .          .             for (i = 0; i < osize; i++) {  
    4,608 ( 0.02%) .          .          .               TString *p = vect[i];
    3,840 ( 0.02%) .          .          .               vect[i] = NULL;
    1,920 ( 0.01%) .          .          .               while (p) {  
    3,072 ( 0.01%) .          .          .                 TString *hnext = p->u.hnext;  
    3,840 ( 0.02%) .          .          .                 unsigned int h = lmod(p->hash, nsize);  
    6,528 ( 0.03%) .          .          .                 p->u.hnext = vect[h];  
    2,688 ( 0.01%) .          .          .                 vect[h] = p;
      384 ( 0.00%) .          .          .                 p = hnext;
        .          .          .          .               }
        .          .          .          .             }
       24 ( 0.00%) .          .          .           }
        .          .          .          .           
       18 ( 0.00%) .          .          .           void luaS_resize (lua_State *L, int nsize) {
       30 ( 0.00%) .          .          .             stringtable *tb = &G(L)->strt;
       18 ( 0.00%) .          .          .             int osize = tb->size;
        .          .          .          .             TString **newvect;
        4 ( 0.00%) .          .          .             if (nsize < osize)  
        .          .          .          .               tablerehash(tb->hash, osize, nsize);  
       30 ( 0.00%) .          .          .             newvect = luaM_reallocvector(L, tb->hash, osize, nsize, TString*);
    1,513 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_realloc_ (2x)
        4 ( 0.00%) .          .          .             if (l_unlikely(newvect == NULL)) {  
        .          .          .          .               if (nsize < osize)  
        .          .          .          .                 tablerehash(tb->hash, nsize, osize);  
        .          .          .          .               
        .          .          .          .             }
        .          .          .          .             else {  
       10 ( 0.00%) .          .          .               tb->hash = newvect;
       10 ( 0.00%) .          .          .               tb->size = nsize;
        4 ( 0.00%) .          .          .               if (nsize > osize)
        8 ( 0.00%) .          .          .                 tablerehash(newvect, osize, nsize);  
   36,536 ( 0.17%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:tablerehash (2x)
        .          .          .          .             }
       18 ( 0.00%) .          .          .           }
        .          .          .          .           
       30 ( 0.00%) .          .          .           void luaS_clearcache (global_State *g) {
        .          .          .          .             int i, j;
    1,610 ( 0.01%) .          .          .             for (i = 0; i < STRCACHE_N; i++)
    4,240 ( 0.02%) .          .          .               for (j = 0; j < STRCACHE_M; j++) {
   16,430 ( 0.08%) .          .          .                 if (iswhite(g->strcache[i][j]))  
       81 ( 0.00%) .          .          .                   g->strcache[i][j] = g->memerrmsg;  
        .          .          .          .               }
       30 ( 0.00%) .          .          .           }
        .          .          .          .           
        6 ( 0.00%) .          .          .           void luaS_init (lua_State *L) {
        8 ( 0.00%) .          .          .             global_State *g = G(L);
        .          .          .          .             int i, j;
       12 ( 0.00%) .          .          .             stringtable *tb = &G(L)->strt;
       10 ( 0.00%) .          .          .             tb->hash = luaM_newvector(L, MINSTRTABSIZE, TString*);
      264 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_malloc_ (1x)
        8 ( 0.00%) .          .          .             tablerehash(tb->hash, 0, MINSTRTABSIZE);  
    2,332 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:tablerehash (1x)
        8 ( 0.00%) .          .          .             tb->size = MINSTRTABSIZE;
        .          .          .          .             
       13 ( 0.00%) .          .          .             g->memerrmsg = luaS_newliteral(L, MEMERRMSG);
    1,874 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_newlstr (1x)
       24 ( 0.00%) .          .          .             luaC_fix(L, obj2gco(g->memerrmsg));  
       84 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_fix (1x)
      322 ( 0.00%) .          .          .             for (i = 0; i < STRCACHE_N; i++)  
      848 ( 0.00%) .          .          .               for (j = 0; j < STRCACHE_M; j++)
    2,862 ( 0.01%) .          .          .                 g->strcache[i][j] = g->memerrmsg;
        6 ( 0.00%) .          .          .           }
        .          .          .          .           
    2,424 ( 0.01%) .          .          .           static TString *createstrobj (lua_State *L, size_t l, int tag, unsigned int h) {
        .          .          .          .             TString *ts;
        .          .          .          .             GCObject *o;
        .          .          .          .             size_t totalsize;  
      404 ( 0.00%) .          .          .             totalsize = sizelstring(l);
      808 ( 0.00%) .          .          .             o = luaC_newobj(L, tag, totalsize);
  138,460 ( 0.64%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_newobj (404x)
    6,060 ( 0.03%) .          .          .             ts = gco2ts(o);
    3,232 ( 0.01%) .          .          .             ts->hash = h;
    2,020 ( 0.01%) .          .          .             ts->extra = 0;
    4,444 ( 0.02%) .          .          .             getstr(ts)[l] = '\0';  
        .          .          .          .             return ts;
    2,020 ( 0.01%) .          .          .           }
        .          .          .          .           
       65 ( 0.00%) .          .          .           TString *luaS_createlngstrobj (lua_State *L, size_t l) {
      273 ( 0.00%) .          .          .             TString *ts = createstrobj(L, l, LUA_VLNGSTR, G(L)->seed);
    4,729 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:createstrobj (13x)
      104 ( 0.00%) .          .          .             ts->u.lnglen = l;
        .          .          .          .             return ts;
       65 ( 0.00%) .          .          .           }
        .          .          .          .           
    3,519 ( 0.02%) .          .          .           void luaS_remove (lua_State *L, TString *ts) {
    5,865 ( 0.03%) .          .          .             stringtable *tb = &G(L)->strt;
   16,813 ( 0.08%) .          .          .             TString **p = &tb->hash[lmod(ts->hash, tb->size)];
    3,991 ( 0.02%) .          .          .             while (*p != ts)  
      767 ( 0.00%) .          .          .               p = &(*p)->u.hnext;
    7,429 ( 0.03%) .          .          .             *p = (*p)->u.hnext;  
    5,083 ( 0.02%) .          .          .             tb->nuse--;
    3,128 ( 0.01%) .          .          .           }
        .          .          .          .           
       10 ( 0.00%) .          .          .           static void growstrtab (lua_State *L, stringtable *tb) {
       18 ( 0.00%) .          .          .             if (l_unlikely(tb->nuse == MAX_INT)) {  
        .          .          .          .               luaC_fullgc(L, 1);  
        .          .          .          .               if (tb->nuse == MAX_INT)  
        .          .          .          .                 luaM_error(L);  
        .          .          .          .             }
       20 ( 0.00%) .          .          .             if (tb->size <= MAXSTRTB / 2)  
       18 ( 0.00%) .          .          .               luaS_resize(L, tb->size * 2);
   38,203 ( 0.18%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_resize (2x)
       10 ( 0.00%) .          .          .           }
        .          .          .          .           
   28,640 ( 0.13%) .          .          .           static TString *internshrstr (lua_State *L, const char *str, size_t l) {
        .          .          .          .             TString *ts;
   28,640 ( 0.13%) .          .          .             global_State *g = G(L);
   22,912 ( 0.11%) .          .          .             stringtable *tb = &g->strt;
   34,368 ( 0.16%) .          .          .             unsigned int h = luaS_hash(str, l, g->seed);
  382,419 ( 1.76%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_hash (2,864x)
  108,832 ( 0.50%) .          .          .             TString **list = &tb->hash[lmod(h, tb->size)];
    5,728 ( 0.03%) .          .          .             lua_assert(str != NULL);  
   33,575 ( 0.15%) .          .          .             for (ts = *list; ts != NULL; ts = ts->u.hnext) {
   69,504 ( 0.32%) .          .          .               if (l == ts->shrlen && (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) {
   43,662 ( 0.20%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memcmp-sse2.S:__memcmp_sse2 (2,512x)
      715 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
        .          .          .          .                 
   42,041 ( 0.19%) .          .          .                 if (isdead(g, ts))  
        .          .          .          .                   changewhite(ts);  
        .          .          .          .                 return ts;
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .             
    4,301 ( 0.02%) .          .          .             if (tb->nuse >= tb->size) {  
        6 ( 0.00%) .          .          .               growstrtab(L, tb);
   38,279 ( 0.18%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:growstrtab (2x)
       70 ( 0.00%) .          .          .               list = &tb->hash[lmod(h, tb->size)];  
        .          .          .          .             }
    2,346 ( 0.01%) .          .          .             ts = createstrobj(L, l, LUA_VSHRSTR, h);
  155,143 ( 0.72%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:createstrobj (391x)
    6,651 ( 0.03%) .          .          .             memcpy(getstr(ts), str, l * sizeof(char));
    5,049 ( 0.02%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:memcpy@GLIBC_2.2.5 (391x)
      861 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
    2,346 ( 0.01%) .          .          .             ts->shrlen = cast_byte(l);
    4,692 ( 0.02%) .          .          .             ts->u.hnext = *list;
    2,346 ( 0.01%) .          .          .             *list = ts;
    5,083 ( 0.02%) .          .          .             tb->nuse++;
        .          .          .          .             return ts;
   25,776 ( 0.12%) .          .          .           }
        .          .          .          .           
   20,132 ( 0.09%) .          .          .           TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
    5,752 ( 0.03%) .          .          .             if (l <= LUAI_MAXSHORTLEN)  
    8,592 ( 0.04%) .          .          .               return internshrstr(L, str, l);
1,053,985 ( 4.86%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:internshrstr (2,864x)
        .          .          .          .             else {
        .          .          .          .               TString *ts;
       36 ( 0.00%) .          .          .               if (l_unlikely(l >= (MAX_SIZE - sizeof(TString))/sizeof(char)))
        .          .          .          .                 luaM_toobig(L);
       36 ( 0.00%) .          .          .               ts = luaS_createlngstrobj(L, l);
    4,936 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_createlngstrobj (12x)
      216 ( 0.00%) .          .          .               memcpy(getstr(ts), str, l * sizeof(char));
      330 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:memcpy@GLIBC_2.2.5 (12x)
        .          .          .          .               return ts;
        .          .          .          .             }
   20,132 ( 0.09%) .          .          .           }
        .          .          .          .           
    1,719 ( 0.01%) .          .          .           TString *luaS_new (lua_State *L, const char *str) {
    2,101 ( 0.01%) .          .          .             unsigned int i = (point2uint(str)) % STRCACHE_N;  
        .          .          .          .             int j;
    5,348 ( 0.02%) .          .          .             TString **p = G(L)->strcache[i];
    2,588 ( 0.01%) .          .          .             for (j = 0; j < STRCACHE_M; j++) {
   10,570 ( 0.05%) .          .          .               if (str[0] == getstr(p[j])[0] && strcmp(str, getstr(p[j])) == 0)  
    1,953 ( 0.01%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strcmp-sse4_2.S:__strcmp_sse42 (57x)
      729 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
      473 ( 0.00%) .          .          .                 return p[j];  
        .          .          .          .             }
        .          .          .          .             
    1,480 ( 0.01%) .          .          .             for (j = STRCACHE_M - 1; j > 0; j--)
    3,700 ( 0.02%) .          .          .               p[j] = p[j - 1];  
        .          .          .          .             
    2,372 ( 0.01%) .          .          .             p[0] = luaS_newlstr(L, str, strlen(str));
  123,393 ( 0.57%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_newlstr (148x)
    2,516 ( 0.01%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strlen-sse2.S:__strlen_sse2 (148x)
      709 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
      592 ( 0.00%) .          .          .             return p[0];
    1,719 ( 0.01%) .          .          .           }
        .          .          .          .           
        7 ( 0.00%) .          .          .           Udata *luaS_newudata (lua_State *L, size_t s, int nuvalue) {
        .          .          .          .             Udata *u;
        .          .          .          .             int i;
        .          .          .          .             GCObject *o;
        6 ( 0.00%) .          .          .             if (l_unlikely(s > MAX_SIZE - udatamemoffset(nuvalue)))
        .          .          .          .               luaM_toobig(L);
        8 ( 0.00%) .          .          .             o = luaC_newobj(L, LUA_VUSERDATA, sizeudata(nuvalue, s));
      347 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_newobj (1x)
       13 ( 0.00%) .          .          .             u = gco2u(o);
        8 ( 0.00%) .          .          .             u->len = s;
        5 ( 0.00%) .          .          .             u->nuvalue = nuvalue;
        8 ( 0.00%) .          .          .             u->metatable = NULL;
        4 ( 0.00%) .          .          .             for (i = 0; i < nuvalue; i++)
        .          .          .          .               setnilvalue(&u->uv[i].uv);
        .          .          .          .             return u;
        7 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           // root include ltable.c
        .          .          .          .           
        .          .          .          .           //included "math.h" 
        .          .          .          .           //included "limits.h" 
        .          .          .          .           
        .          .          .          .           #define MAXABITS	cast_int(sizeof(int) * CHAR_BIT - 1)
        .          .          .          .           
-- line 10945 ----------------------------------------
-- line 10960 ----------------------------------------
        .          .          .          .           
        .          .          .          .           static const Node dummynode_ = {
        .          .          .          .             {{NULL}, LUA_VEMPTY,  
        .          .          .          .              LUA_VNIL, 0, {NULL}}  
        .          .          .          .           };
        .          .          .          .           
        .          .          .          .           static const TValue absentkey = {ABSTKEYCONSTANT};
        .          .          .          .           
      210 ( 0.00%) .          .          .           static Node* hashpointer (const Table *t, void* p) {
      175 ( 0.00%) .          .          .           	lua_Unsigned ui = point2uint((size_t)p/sizeof(Udata0));
    1,470 ( 0.01%) .          .          .           	return hashmod(t, ui);
      210 ( 0.00%) .          .          .           }
        .          .          .          .           
      678 ( 0.00%) .          .          .           static Node *hashint (const Table *t, lua_Integer i) {
        .          .          .          .             lua_Unsigned ui = l_castS2U(i);
      339 ( 0.00%) .          .          .             if (ui <= (unsigned int)INT_MAX)
    5,198 ( 0.02%) .          .          .               return hashmod(t, cast_int(ui));
        .          .          .          .             else
        .          .          .          .               return hashmod(t, ui);
      678 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #if !defined(l_hashfloat)
       60 ( 0.00%) .          .          .           static int l_hashfloat (lua_Number n) {
        .          .          .          .             int i;
        .          .          .          .             lua_Integer ni;
       64 ( 0.00%) .          .          .             n = l_mathop(frexp)(n, &i) * -cast_num(INT_MIN);
      707 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
      360 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/math/../sysdeps/ieee754/dbl-64/s_frexp.c:frexp (15x)
       90 ( 0.00%) .          .          .             if (!lua_numbertointeger(n, &ni)) {  
        .          .          .          .               lua_assert(luai_numisnan(n) || l_mathop(fabs)(n) == cast_num(HUGE_VAL));
        .          .          .          .               return 0;
        .          .          .          .             }
        .          .          .          .             else {  
       15 ( 0.00%) .          .          .               unsigned int u = cast_uint(i) + cast_uint(ni);
       30 ( 0.00%) .          .          .               return cast_int(u <= cast_uint(INT_MAX) ? u : ~u);
        .          .          .          .             }
       75 ( 0.00%) .          .          .           }
        .          .          .          .           #endif
        .          .          .          .           
   13,209 ( 0.06%) .          .          .           static Node *mainpositionTV (const Table *t, const TValue *key) {
   32,079 ( 0.15%) .          .          .             switch (ttypetag(key)) {
        .          .          .          .               case LUA_VNUMINT: {
      671 ( 0.00%) .          .          .                 lua_Integer i = ivalue(key);
      122 ( 0.00%) .          .          .                 return hashint(t, i);
    3,721 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:hashint (61x)
        .          .          .          .               }
        .          .          .          .               case LUA_VNUMFLT: {
      165 ( 0.00%) .          .          .                 lua_Number n = fltvalue(key);
      735 ( 0.00%) .          .          .                 return hashmod(t, l_hashfloat(n));
    1,401 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:l_hashfloat (15x)
        .          .          .          .               }
        .          .          .          .               case LUA_VSHRSTR: {
   52,824 ( 0.24%) .          .          .                 TString *ts = tsvalue(key);
  163,584 ( 0.75%) .          .          .                 return hashstr(t, ts);
        .          .          .          .               }
        .          .          .          .               case LUA_VLNGSTR: {
    1,364 ( 0.01%) .          .          .                 TString *ts = tsvalue(key);
    3,960 ( 0.02%) .          .          .                 return hashpow2(t, luaS_hashlongstr(ts));
   16,044 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_hashlongstr (44x)
        .          .          .          .               }
        .          .          .          .               case LUA_VFALSE:
      408 ( 0.00%) .          .          .                 return hashboolean(t, 0);
        .          .          .          .               case LUA_VTRUE:
    1,892 ( 0.01%) .          .          .                 return hashboolean(t, 1);
        .          .          .          .               case LUA_VLIGHTUSERDATA: {
        .          .          .          .                 void *p = pvalue(key);
        .          .          .          .                 return hashpointer(t, p);
        .          .          .          .               }
        .          .          .          .               case LUA_VLCF: {
        .          .          .          .                 lua_CFunction f = fvalue(key);
        .          .          .          .                 return hashpointer(t, f);
        .          .          .          .               }
        .          .          .          .               default: {
      385 ( 0.00%) .          .          .                 GCObject *o = gcvalue(key);
      105 ( 0.00%) .          .          .                 return hashpointer(t, o);
    2,065 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:hashpointer (35x)
        .          .          .          .               }
        .          .          .          .             }
   11,322 ( 0.05%) .          .          .           }
        .          .          .          .           
    4,941 ( 0.02%) .          .          .           l_sinline Node *mainpositionfromnode (const Table *t, Node *nd) {
        .          .          .          .             TValue key;
   15,633 ( 0.07%) .          .          .             getnodekey(cast(lua_State *, NULL), &key, nd);
    1,647 ( 0.01%) .          .          .             return mainpositionTV(t, &key);
   84,851 ( 0.39%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:mainpositionTV (549x)
    4,392 ( 0.02%) .          .          .           }
        .          .          .          .           
      736 ( 0.00%) .          .          .           static int equalkey (const TValue *k1, const Node *n2, int deadok) {
    1,756 ( 0.01%) .          .          .             if ((rawtt(k1) != keytt(n2)) &&  
        .          .          .          .                  !(deadok && keyisdead(n2) && iscollectable(k1)))
       50 ( 0.00%) .          .          .              return 0;  
      412 ( 0.00%) .          .          .             switch (keytt(n2)) {
        .          .          .          .               case LUA_VNIL: case LUA_VFALSE: case LUA_VTRUE:
        .          .          .          .                 return 1;
        .          .          .          .               case LUA_VNUMINT:
        .          .          .          .                 return (ivalue(k1) == keyival(n2));
        .          .          .          .               case LUA_VNUMFLT:
      100 ( 0.00%) .          .          .                 return luai_numeq(fltvalue(k1), fltvalueraw(keyval(n2)));
        .          .          .          .               case LUA_VLIGHTUSERDATA:
        .          .          .          .                 return pvalue(k1) == pvalueraw(keyval(n2));
        .          .          .          .               case LUA_VLCF:
        .          .          .          .                 return fvalue(k1) == fvalueraw(keyval(n2));
        .          .          .          .               case ctb(LUA_VLNGSTR):
      558 ( 0.00%) .          .          .                 return luaS_eqlngstr(tsvalue(k1), keystrval(n2));
      324 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_eqlngstr (9x)
        .          .          .          .               default:
      418 ( 0.00%) .          .          .                 return gcvalue(k1) == gcvalueraw(keyval(n2));
        .          .          .          .             }
      552 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #define limitequalsasize(t)	(isrealasize(t) || ispow2((t)->alimit))
        .          .          .          .           
      918 ( 0.00%) .          .          .           LUAI_FUNC unsigned int luaH_realasize (const Table *t) {
    1,377 ( 0.01%) .          .          .             if (limitequalsasize(t))
    1,224 ( 0.01%) .          .          .               return t->alimit;  
        .          .          .          .             else {
        .          .          .          .               unsigned int size = t->alimit;
        .          .          .          .               
        .          .          .          .               size |= (size >> 1);
        .          .          .          .               size |= (size >> 2);
        .          .          .          .               size |= (size >> 4);
        .          .          .          .               size |= (size >> 8);
        .          .          .          .               size |= (size >> 16);
        .          .          .          .           #if (UINT_MAX >> 30) > 3
        .          .          .          .               size |= (size >> 32);  
        .          .          .          .           #endif
        .          .          .          .               size++;
        .          .          .          .               lua_assert(ispow2(size) && size/2 < t->alimit && t->alimit < size);
        .          .          .          .               return size;
        .          .          .          .             }
    1,071 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static int ispow2realasize (const Table *t) {
        .          .          .          .             return (!isrealasize(t) || ispow2(t->alimit));
        .          .          .          .           }
        .          .          .          .           
      320 ( 0.00%) .          .          .           static unsigned int setlimittosize (Table *t) {
      800 ( 0.00%) .          .          .             t->alimit = luaH_realasize(t);
    2,400 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_realasize (80x)
      880 ( 0.00%) .          .          .             setrealasize(t);
      320 ( 0.00%) .          .          .             return t->alimit;
      400 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #define limitasasize(t)	check_exp(isrealasize(t), t->alimit)
        .          .          .          .           
      532 ( 0.00%) .          .          .           static const TValue *getgeneric (Table *t, const TValue *key, int deadok) {
      228 ( 0.00%) .          .          .             Node *n = mainpositionTV(t, key);
   25,583 ( 0.12%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:mainpositionTV (76x)
        .          .          .          .             for (;;) {  
      552 ( 0.00%) .          .          .               if (equalkey(key, n, deadok))
    4,906 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:equalkey (92x)
      252 ( 0.00%) .          .          .                 return gval(n);  
        .          .          .          .               else {
      450 ( 0.00%) .          .          .                 int nx = gnext(n);
      100 ( 0.00%) .          .          .                 if (nx == 0)
       68 ( 0.00%) .          .          .                   return &absentkey;  
      128 ( 0.00%) .          .          .                 n += nx;
        .          .          .          .               }
        .          .          .          .             }
      456 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static unsigned int arrayindex (lua_Integer k) {
       72 ( 0.00%) .          .          .             if (l_castS2U(k) - 1u < MAXASIZE)  
       48 ( 0.00%) .          .          .               return cast_uint(k);  
        .          .          .          .             else
        .          .          .          .               return 0;
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           static unsigned int findindex (lua_State *L, Table *t, TValue *key,
        .          .          .          .                                          unsigned int asize) {
        .          .          .          .             unsigned int i;
        .          .          .          .             if (ttisnil(key)) return 0;  
-- line 11120 ----------------------------------------
-- line 11147 ----------------------------------------
        .          .          .          .                 getnodekey(L, s2v(key), n);
        .          .          .          .                 setobj2s(L, key + 1, gval(n));
        .          .          .          .                 return 1;
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .             return 0;  
        .          .          .          .           }
        .          .          .          .           
      320 ( 0.00%) .          .          .           static void freehash (lua_State *L, Table *t) {
      576 ( 0.00%) .          .          .             if (!isdummy(t))
    1,260 ( 0.01%) .          .          .               luaM_freearray(L, t->node, cast_sizet(sizenode(t)));
    7,806 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (45x)
      256 ( 0.00%) .          .          .           }
        .          .          .          .           
      306 ( 0.00%) .          .          .           static unsigned int computesizes (unsigned int nums[], unsigned int *pna) {
        .          .          .          .             int i;
        .          .          .          .             unsigned int twotoi;  
       34 ( 0.00%) .          .          .             unsigned int a = 0;  
       34 ( 0.00%) .          .          .             unsigned int na = 0;  
       34 ( 0.00%) .          .          .             unsigned int optimal = 0;  
        .          .          .          .             
      102 ( 0.00%) .          .          .             for (i = 0, twotoi = 1;
      530 ( 0.00%) .          .          .                  twotoi > 0 && *pna > twotoi / 2;
       95 ( 0.00%) .          .          .                  i++, twotoi *= 2) {
      209 ( 0.00%) .          .          .               a += nums[i];
       38 ( 0.00%) .          .          .               if (a > twotoi/2) {  
        8 ( 0.00%) .          .          .                 optimal = twotoi;  
        8 ( 0.00%) .          .          .                 na = a;  
        .          .          .          .               }
        .          .          .          .             }
      216 ( 0.00%) .          .          .             lua_assert((optimal == 0 || optimal / 2 < na) && na <= optimal);
      204 ( 0.00%) .          .          .             *pna = na;
        .          .          .          .             return optimal;
      306 ( 0.00%) .          .          .           }
        .          .          .          .           
       96 ( 0.00%) .          .          .           static int countint (lua_Integer key, unsigned int *nums) {
       24 ( 0.00%) .          .          .             unsigned int k = arrayindex(key);
      120 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:arrayindex (24x)
       48 ( 0.00%) .          .          .             if (k != 0) {  
      456 ( 0.00%) .          .          .               nums[luaO_ceillog2(k)]++;  
      908 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaO_ceillog2 (24x)
       48 ( 0.00%) .          .          .               return 1;
        .          .          .          .             }
        .          .          .          .             else
        .          .          .          .               return 0;
       96 ( 0.00%) .          .          .           }
        .          .          .          .           
      306 ( 0.00%) .          .          .           static unsigned int numusearray (const Table *t, unsigned int *nums) {
        .          .          .          .             int lg;
        .          .          .          .             unsigned int ttlg;  
       34 ( 0.00%) .          .          .             unsigned int ause = 0;  
       34 ( 0.00%) .          .          .             unsigned int i = 1;  
      612 ( 0.00%) .          .          .             unsigned int asize = limitasasize(t);  
        .          .          .          .             
      205 ( 0.00%) .          .          .             for (lg = 0, ttlg = 1; lg <= MAXABITS; lg++, ttlg *= 2) {
        .          .          .          .               unsigned int lc = 0;  
        5 ( 0.00%) .          .          .               unsigned int lim = ttlg;
      156 ( 0.00%) .          .          .               if (lim > asize) {
       10 ( 0.00%) .          .          .                 lim = asize;  
       68 ( 0.00%) .          .          .                 if (i > lim)
        .          .          .          .                   break;  
        .          .          .          .               }
        .          .          .          .               
       28 ( 0.00%) .          .          .               for (; i <= lim; i++) {
      132 ( 0.00%) .          .          .                 if (!isempty(&t->array[i-1]))
       10 ( 0.00%) .          .          .                   lc++;
        .          .          .          .               }
      125 ( 0.00%) .          .          .               nums[lg] += lc;
        5 ( 0.00%) .          .          .               ause += lc;
        .          .          .          .             }
        .          .          .          .             return ause;
      306 ( 0.00%) .          .          .           }
        .          .          .          .           
    1,057 ( 0.00%) .          .          .           static int numusehash (const Table *t, unsigned int *nums, unsigned int *pna) {
       34 ( 0.00%) .          .          .             int totaluse = 0;  
       34 ( 0.00%) .          .          .             int ause = 0;  
      680 ( 0.00%) .          .          .             int i = sizenode(t);
    3,789 ( 0.02%) .          .          .             while (i--) {
   10,755 ( 0.05%) .          .          .               Node *n = &t->node[i];
    6,453 ( 0.03%) .          .          .               if (!isempty(gval(n))) {
    6,408 ( 0.03%) .          .          .                 if (keyisinteger(n))
      360 ( 0.00%) .          .          .                   ause += countint(keyival(n), nums);
    1,796 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:countint (24x)
    2,848 ( 0.01%) .          .          .                 totaluse++;
        .          .          .          .               }
        .          .          .          .             }
      374 ( 0.00%) .          .          .             *pna += ause;
        .          .          .          .             return totaluse;
      306 ( 0.00%) .          .          .           }
        .          .          .          .           
      512 ( 0.00%) .          .          .           static void setnodevector (lua_State *L, Table *t, unsigned int size) {
      128 ( 0.00%) .          .          .             if (size == 0) {  
      171 ( 0.00%) .          .          .               t->node = cast(Node *, dummynode);  
       95 ( 0.00%) .          .          .               t->lsizenode = 0;
      197 ( 0.00%) .          .          .               t->lastfree = NULL;  
        .          .          .          .             }
        .          .          .          .             else {
        .          .          .          .               int i;
      135 ( 0.00%) .          .          .               int lsize = luaO_ceillog2(size);
    1,440 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaO_ceillog2 (45x)
      405 ( 0.00%) .          .          .               if (lsize > MAXHBITS || (1u << lsize) > MAXHSIZE)
        .          .          .          .                 luaG_runerror(L, "table overflow");
      495 ( 0.00%) .          .          .               size = twoto(lsize);
      765 ( 0.00%) .          .          .               t->node = luaM_newvector(L, size, Node);
   11,039 ( 0.05%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_malloc_ (45x)
    8,496 ( 0.04%) .          .          .               for (i = 0; i < (int)size; i++) {
   16,632 ( 0.08%) .          .          .                 Node *n = gnode(t, i);
   11,088 ( 0.05%) .          .          .                 gnext(n) = 0;
    6,930 ( 0.03%) .          .          .                 setnilkey(n);
    6,930 ( 0.03%) .          .          .                 setempty(gval(n));
        .          .          .          .               }
      225 ( 0.00%) .          .          .               t->lsizenode = cast_byte(lsize);
      855 ( 0.00%) .          .          .               t->lastfree = gnode(t, size);  
        .          .          .          .             }
      557 ( 0.00%) .          .          .           }
        .          .          .          .           
      598 ( 0.00%) .          .          .           static void reinsert (lua_State *L, Table *ot, Table *t) {
        .          .          .          .             int j;
      920 ( 0.00%) .          .          .             int size = sizenode(ot);
    4,558 ( 0.02%) .          .          .             for (j = 0; j < size; j++) {
   10,935 ( 0.05%) .          .          .               Node *old = gnode(ot, j);
    6,561 ( 0.03%) .          .          .               if (!isempty(gval(old))) {
        .          .          .          .                 
        .          .          .          .                 TValue k;
   41,473 ( 0.19%) .          .          .                 getnodekey(L, &k, old);
    6,408 ( 0.03%) .          .          .                 luaH_set(L, t, &k, gval(old));
  570,992 ( 2.63%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_set (712x)
        .          .          .          .               }
        .          .          .          .             }
      506 ( 0.00%) .          .          .           }
        .          .          .          .           
      414 ( 0.00%) .          .          .           static void exchangehashpart (Table *t1, Table *t2) {
      368 ( 0.00%) .          .          .             lu_byte lsizenode = t1->lsizenode;
      368 ( 0.00%) .          .          .             Node *node = t1->node;
      368 ( 0.00%) .          .          .             Node *lastfree = t1->lastfree;
      598 ( 0.00%) .          .          .             t1->lsizenode = t2->lsizenode;
      598 ( 0.00%) .          .          .             t1->node = t2->node;
      598 ( 0.00%) .          .          .             t1->lastfree = t2->lastfree;
      230 ( 0.00%) .          .          .             t2->lsizenode = lsizenode;
      230 ( 0.00%) .          .          .             t2->node = node;
      230 ( 0.00%) .          .          .             t2->lastfree = lastfree;
      368 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaH_resize (lua_State *L, Table *t, unsigned int newasize,
      690 ( 0.00%) .          .          .                                                     unsigned int nhsize) {
        .          .          .          .             unsigned int i;
        .          .          .          .             Table newt;  
      138 ( 0.00%) .          .          .             unsigned int oldasize = setlimittosize(t);
    2,944 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:setlimittosize (46x)
        .          .          .          .             TValue *newarray;
        .          .          .          .             
      184 ( 0.00%) .          .          .             setnodevector(L, &newt, nhsize);
   66,375 ( 0.31%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:setnodevector (46x)
       92 ( 0.00%) .          .          .             if (newasize < oldasize) {  
        .          .          .          .               t->alimit = newasize;  
        .          .          .          .               exchangehashpart(t, &newt);  
        .          .          .          .               
        .          .          .          .               for (i = newasize; i < oldasize; i++) {
        .          .          .          .                 if (!isempty(&t->array[i]))
        .          .          .          .                   luaH_setint(L, t, i + 1, &t->array[i]);
        .          .          .          .               }
        .          .          .          .               t->alimit = oldasize;  
        .          .          .          .               exchangehashpart(t, &newt);  
        .          .          .          .             }
        .          .          .          .             
      782 ( 0.00%) .          .          .             newarray = luaM_reallocvector(L, t->array, oldasize, newasize, TValue);
    4,473 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_realloc_ (46x)
      276 ( 0.00%) .          .          .             if (l_unlikely(newarray == NULL && newasize > 0)) {  
        .          .          .          .               freehash(L, &newt);  
        .          .          .          .               luaM_error(L);  
        .          .          .          .             }
        .          .          .          .             
      138 ( 0.00%) .          .          .             exchangehashpart(t, &newt);  
    4,370 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:exchangehashpart (46x)
      230 ( 0.00%) .          .          .             t->array = newarray;  
      230 ( 0.00%) .          .          .             t->alimit = newasize;
      156 ( 0.00%) .          .          .             for (i = oldasize; i < newasize; i++)  
      108 ( 0.00%) .          .          .                setempty(&t->array[i]);
        .          .          .          .             
      276 ( 0.00%) .          .          .             reinsert(L, &newt, t);  
  642,951 ( 2.97%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:reinsert (46x)
      138 ( 0.00%) .          .          .             freehash(L, &newt);  
    6,437 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freehash (46x)
      506 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaH_resizearray (lua_State *L, Table *t, unsigned int nasize) {
        .          .          .          .             int nsize = allocsizenode(t);
        .          .          .          .             luaH_resize(L, t, nasize, nsize);
        .          .          .          .           }
        .          .          .          .           
      442 ( 0.00%) .          .          .           static void rehash (lua_State *L, Table *t, const TValue *ek) {
        .          .          .          .             unsigned int asize;  
        .          .          .          .             unsigned int na;  
        .          .          .          .             unsigned int nums[MAXABITS + 1];
        .          .          .          .             int i;
        .          .          .          .             int totaluse;
   25,160 ( 0.12%) .          .          .             for (i = 0; i <= MAXABITS; i++) nums[i] = 0;  
       68 ( 0.00%) .          .          .             setlimittosize(t);
    2,176 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:setlimittosize (34x)
      204 ( 0.00%) .          .          .             na = numusearray(t, nums);  
    2,036 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:numusearray (34x)
       34 ( 0.00%) .          .          .             totaluse = na;  
      238 ( 0.00%) .          .          .             totaluse += numusehash(t, nums, &na);  
   34,894 ( 0.16%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:numusehash (34x)
        .          .          .          .             
      306 ( 0.00%) .          .          .             if (ttisinteger(ek))
        .          .          .          .               na += countint(ivalue(ek), nums);
       68 ( 0.00%) .          .          .             totaluse++;
        .          .          .          .             
      136 ( 0.00%) .          .          .             asize = computesizes(nums, &na);
    2,124 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:computesizes (34x)
        .          .          .          .             
      170 ( 0.00%) .          .          .             luaH_resize(L, t, asize, totaluse - na);
  719,494 ( 3.32%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_resize (34x)
      374 ( 0.00%) .          .          .           }
        .          .          .          .           
       72 ( 0.00%) .          .          .           Table *luaH_new (lua_State *L) {
       72 ( 0.00%) .          .          .             GCObject *o = luaC_newobj(L, LUA_VTABLE, sizeof(Table));
    6,260 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_newobj (18x)
      234 ( 0.00%) .          .          .             Table *t = gco2t(o);
      144 ( 0.00%) .          .          .             t->metatable = NULL;
       90 ( 0.00%) .          .          .             t->flags = cast_byte(maskflags);  
       90 ( 0.00%) .          .          .             t->array = NULL;
       90 ( 0.00%) .          .          .             t->alimit = 0;
       72 ( 0.00%) .          .          .             setnodevector(L, t, 0);
      720 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:setnodevector (18x)
        .          .          .          .             return t;
       90 ( 0.00%) .          .          .           }
        .          .          .          .           
       90 ( 0.00%) .          .          .           void luaH_free (lua_State *L, Table *t) {
       18 ( 0.00%) .          .          .             freehash(L, t);
    3,781 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:freehash (18x)
      270 ( 0.00%) .          .          .             luaM_freearray(L, t->array, luaH_realasize(t));
    1,524 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (18x)
      540 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_realasize (18x)
       72 ( 0.00%) .          .          .             luaM_free(L, t);
    3,199 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaM_free_ (18x)
       72 ( 0.00%) .          .          .           }
        .          .          .          .           
    2,332 ( 0.01%) .          .          .           static Node *getfreepos (Table *t) {
    5,830 ( 0.03%) .          .          .             if (!isdummy(t)) {
   11,836 ( 0.05%) .          .          .               while (t->lastfree > t->node) {
   13,611 ( 0.06%) .          .          .                 t->lastfree--;
   14,658 ( 0.07%) .          .          .                 if (keyisnil(t->lastfree))
    2,196 ( 0.01%) .          .          .                   return t->lastfree;
        .          .          .          .               }
        .          .          .          .             }
       29 ( 0.00%) .          .          .             return NULL;  
    2,915 ( 0.01%) .          .          .           }
        .          .          .          .           
   17,724 ( 0.08%) .          .          .           void luaH_newkey (lua_State *L, Table *t, const TValue *key, TValue *value) {
        .          .          .          .             Node *mp;
        .          .          .          .             TValue aux;
   13,926 ( 0.06%) .          .          .             if (l_unlikely(ttisnil(key)))
        .          .          .          .               luaG_runerror(L, "table index is nil");
    8,862 ( 0.04%) .          .          .             else if (ttisfloat(key)) {
       55 ( 0.00%) .          .          .               lua_Number f = fltvalue(key);
        .          .          .          .               lua_Integer k;
       30 ( 0.00%) .          .          .               if (luaV_flttointeger(f, &k, F2Ieq)) {  
      136 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_flttointeger (4x)
        .          .          .          .                 setivalue(&aux, k);
        .          .          .          .                 key = &aux;  
        .          .          .          .               }
       35 ( 0.00%) .          .          .               else if (l_unlikely(luai_numisnan(f)))
        .          .          .          .                 luaG_runerror(L, "table index is NaN");
        .          .          .          .             }
   11,394 ( 0.05%) .          .          .             if (ttisnil(value))
        .          .          .          .               return;  
    5,048 ( 0.02%) .          .          .             mp = mainpositionTV(t, key);
   80,289 ( 0.37%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:mainpositionTV (519x)
   18,776 ( 0.09%) .          .          .             if (!isempty(gval(mp)) || isdummy(t)) {  
        .          .          .          .               Node *othern;
    1,749 ( 0.01%) .          .          .               Node *f = getfreepos(t);  
   35,480 ( 0.16%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getfreepos (362x)
    1,166 ( 0.01%) .          .          .               if (f == NULL) {  
      170 ( 0.00%) .          .          .                 rehash(L, t, key);  
  787,924 ( 3.64%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:rehash (34x)
        .          .          .          .                 
      170 ( 0.00%) .          .          .                 luaH_set(L, t, key, value);  
   29,815 ( 0.14%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_set (34x)
       34 ( 0.00%) .          .          .                 return;
        .          .          .          .               }
    4,941 ( 0.02%) .          .          .               lua_assert(!isdummy(t));
    2,196 ( 0.01%) .          .          .               othern = mainpositionfromnode(t, mp);
   66,288 ( 0.31%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:mainpositionfromnode (328x)
    1,098 ( 0.01%) .          .          .               if (othern != mp) {  
        .          .          .          .                 
    3,401 ( 0.02%) .          .          .                 while (othern + gnext(othern) != mp)  
      264 ( 0.00%) .          .          .                   othern += gnext(othern);
    1,860 ( 0.01%) .          .          .                 gnext(othern) = cast_int(f - othern);  
    2,325 ( 0.01%) .          .          .                 *f = *mp;  
    1,550 ( 0.01%) .          .          .                 if (gnext(mp) != 0) {
      598 ( 0.00%) .          .          .                   gnext(f) += cast_int(mp - f);  
      138 ( 0.00%) .          .          .                   gnext(mp) = 0;  
        .          .          .          .                 }
    1,085 ( 0.01%) .          .          .                 setempty(gval(mp));
        .          .          .          .               }
        .          .          .          .               else {  
        .          .          .          .                 
    4,334 ( 0.02%) .          .          .                 if (gnext(mp) != 0)
    2,842 ( 0.01%) .          .          .                   gnext(f) = cast_int((mp + gnext(mp)) - f);  
    3,552 ( 0.02%) .          .          .                 else lua_assert(gnext(f) == 0);
    4,728 ( 0.02%) .          .          .                 gnext(mp) = cast_int(f - mp);
      788 ( 0.00%) .          .          .                 mp = f;
        .          .          .          .               }
        .          .          .          .             }
  131,246 ( 0.61%) .          .          .             setnodekey(L, mp, key);
   34,424 ( 0.16%) .          .          .             luaC_barrierback(L, obj2gco(t), key);
    8,596 ( 0.04%) .          .          .             lua_assert(isempty(gval(mp)));
   92,792 ( 0.43%) .          .          .             setobj2t(L, gval(mp), value);
   13,926 ( 0.06%) .          .          .           }
        .          .          .          .           
      406 ( 0.00%) .          .          .           const TValue *luaH_getint (Table *t, lua_Integer key) {
      696 ( 0.00%) .          .          .             if (l_castS2U(key) - 1u < t->alimit)  
       96 ( 0.00%) .          .          .               return &t->array[key - 1];
      312 ( 0.00%) .          .          .             else if (!limitequalsasize(t) &&  
        .          .          .          .                      (l_castS2U(key) == t->alimit + 1 ||
        .          .          .          .                       l_castS2U(key) - 1u < luaH_realasize(t))) {
        .          .          .          .               t->alimit = cast_uint(key);  
        .          .          .          .               return &t->array[key - 1];
        .          .          .          .             }
        .          .          .          .             else {
      260 ( 0.00%) .          .          .               Node *n = hashint(t, key);
    3,172 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:hashint (52x)
        .          .          .          .               for (;;) {  
      780 ( 0.00%) .          .          .                 if (keyisinteger(n) && keyival(n) == key)
       70 ( 0.00%) .          .          .                   return gval(n);  
        .          .          .          .                 else {
      513 ( 0.00%) .          .          .                   int nx = gnext(n);
      114 ( 0.00%) .          .          .                   if (nx == 0) break;
      120 ( 0.00%) .          .          .                   n += nx;
        .          .          .          .                 }
        .          .          .          .               }
       42 ( 0.00%) .          .          .               return &absentkey;
        .          .          .          .             }
      348 ( 0.00%) .          .          .           }
        .          .          .          .           
   31,801 ( 0.15%) .          .          .           const TValue *luaH_getshortstr (Table *t, TString *key) {
  390,698 ( 1.80%) .          .          .             Node *n = hashstr(t, key);
   27,258 ( 0.13%) .          .          .             lua_assert(key->tt == LUA_VSHRSTR);
        .          .          .          .             for (;;) {  
  350,977 ( 1.62%) .          .          .               if (keyisshrstr(n) && eqshrstr(keystrval(n), key))
   23,296 ( 0.11%) .          .          .                 return gval(n);  
        .          .          .          .               else {
   21,330 ( 0.10%) .          .          .                 int nx = gnext(n);
    4,740 ( 0.02%) .          .          .                 if (nx == 0)
    1,215 ( 0.01%) .          .          .                   return &absentkey;  
    9,240 ( 0.04%) .          .          .                 n += nx;
        .          .          .          .               }
        .          .          .          .             }
   27,258 ( 0.13%) .          .          .           }
        .          .          .          .           
   24,903 ( 0.11%) .          .          .           const TValue *luaH_getstr (Table *t, TString *key) {
   27,670 ( 0.13%) .          .          .             if (key->tt == LUA_VSHRSTR)
   11,032 ( 0.05%) .          .          .               return luaH_getshortstr(t, key);
  561,537 ( 2.59%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_getshortstr (2,758x)
        .          .          .          .             else {  
        .          .          .          .               TValue ko;
      252 ( 0.00%) .          .          .               setsvalue(cast(lua_State *, NULL), &ko, key);
       36 ( 0.00%) .          .          .               return getgeneric(t, &ko, 0);
   16,843 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getgeneric (9x)
        .          .          .          .             }
   22,136 ( 0.10%) .          .          .           }
        .          .          .          .           
   16,479 ( 0.08%) .          .          .           const TValue *luaH_get (Table *t, const TValue *key) {
   22,466 ( 0.10%) .          .          .             switch (ttypetag(key)) {
   59,745 ( 0.28%) .          .          .               case LUA_VSHRSTR: return luaH_getshortstr(t, tsvalue(key));
  311,162 ( 1.44%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_getshortstr (1,707x)
      798 ( 0.00%) .          .          .               case LUA_VNUMINT: return luaH_getint(t, ivalue(key));
    6,888 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_getint (57x)
        .          .          .          .               case LUA_VNIL: return &absentkey;
        .          .          .          .               case LUA_VNUMFLT: {
        .          .          .          .                 lua_Integer k;
      144 ( 0.00%) .          .          .                 if (luaV_flttointeger(fltvalue(key), &k, F2Ieq)) 
      306 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_flttointeger (9x)
        .          .          .          .                   return luaH_getint(t, k);  
       45 ( 0.00%) .          .          .                 return getgeneric(t, key, 0);
    2,673 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getgeneric (9x)
        .          .          .          .               }
        .          .          .          .               default:
      290 ( 0.00%) .          .          .                 return getgeneric(t, key, 0);
   13,739 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:getgeneric (58x)
        .          .          .          .             }
   14,648 ( 0.07%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaH_finishset (lua_State *L, Table *t, const TValue *key,
   16,570 ( 0.08%) .          .          .                                              const TValue *slot, TValue *value) {
   14,913 ( 0.07%) .          .          .             if (isabstkey(slot))
    7,596 ( 0.04%) .          .          .               luaH_newkey(L, t, key, value);
1,172,191 ( 5.41%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_newkey (523x)
        .          .          .          .             else
   13,685 ( 0.06%) .          .          .               setobj2t(L, cast(TValue *, slot), value);
    9,942 ( 0.05%) .          .          .           }
        .          .          .          .           
    6,714 ( 0.03%) .          .          .           void luaH_set (lua_State *L, Table *t, const TValue *key, TValue *value) {
    2,984 ( 0.01%) .          .          .             const TValue *slot = luaH_get(t, key);
  157,656 ( 0.73%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_get (746x)
    3,730 ( 0.02%) .          .          .             luaH_finishset(L, t, key, slot, value);
  425,247 ( 1.96%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_finishset'2 (746x)
    4,476 ( 0.02%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaH_setint (lua_State *L, Table *t, lua_Integer key, TValue *value) {
        .          .          .          .             const TValue *p = luaH_getint(t, key);
        .          .          .          .             if (isabstkey(p)) {
        .          .          .          .               TValue k;
        .          .          .          .               setivalue(&k, key);
        .          .          .          .               luaH_newkey(L, t, &k, value);
        .          .          .          .             }
-- line 11513 ----------------------------------------
-- line 11604 ----------------------------------------
        .          .          .          .           int luaH_isdummy (const Table *t) { return isdummy(t); }
        .          .          .          .           
        .          .          .          .           #endif
        .          .          .          .           
        .          .          .          .           // root include ltm.c
        .          .          .          .           
        .          .          .          .           //included "string.h" 
        .          .          .          .           
        6 ( 0.00%) .          .          .           void luaT_init (lua_State *L) {
        .          .          .          .             static const char *const luaT_eventname[] = {  
        .          .          .          .               "__index", "__newindex",
        .          .          .          .               "__gc", "__mode", "__len", "__eq",
        .          .          .          .               "__add", "__sub", "__mul", "__mod", "__pow",
        .          .          .          .               "__div", "__idiv",
        .          .          .          .               "__band", "__bor", "__bxor", "__shl", "__shr",
        .          .          .          .               "__unm", "__bnot", "__lt", "__le",
        .          .          .          .               "__concat", "__call", "__close"
        .          .          .          .             };
        .          .          .          .             int i;
      154 ( 0.00%) .          .          .             for (i=0; i<TM_N; i++) {
    1,225 ( 0.01%) .          .          .               G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);
   26,044 ( 0.12%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_new (25x)
    1,275 ( 0.01%) .          .          .               luaC_fix(L, obj2gco(G(L)->tmname[i]));  
    2,100 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaC_fix (25x)
        .          .          .          .             }
        6 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           const TValue *luaT_gettm (Table *events, TMS event, TString *ename) {
        .          .          .          .             const TValue *tm = luaH_getshortstr(events, ename);
        .          .          .          .             lua_assert(event <= TM_EQ);
        .          .          .          .             if (notm(tm)) {  
        .          .          .          .               events->flags |= cast_byte(1u<<event);  
        .          .          .          .               return NULL;
        .          .          .          .             }
-- line 11635 ----------------------------------------
-- line 11775 ----------------------------------------
        .          .          .          .               p2 = p1; p1 = &aux;  
        .          .          .          .             }
        .          .          .          .             else
        .          .          .          .               p2 = &aux;
        .          .          .          .             return luaT_callorderTM(L, p1, p2, event);
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,
       13 ( 0.00%) .          .          .                                    const Proto *p) {
        .          .          .          .             int i;
       19 ( 0.00%) .          .          .             int actual = cast_int(L->top - ci->func) - 1;  
        3 ( 0.00%) .          .          .             int nextra = actual - nfixparams;  
        8 ( 0.00%) .          .          .             ci->u.l.nextraargs = nextra;
       29 ( 0.00%) .          .          .             luaD_checkstack(L, p->maxstacksize + 1);
        .          .          .          .             
      123 ( 0.00%) .          .          .             setobjs2s(L, L->top++, ci->func);
        .          .          .          .             
        3 ( 0.00%) .          .          .             for (i = 1; i <= nfixparams; i++) {
        .          .          .          .               setobjs2s(L, L->top++, ci->func + i);
        .          .          .          .               setnilvalue(s2v(ci->func + i));  
        .          .          .          .             }
       18 ( 0.00%) .          .          .             ci->func += actual + 1;
       16 ( 0.00%) .          .          .             ci->top += actual + 1;
       21 ( 0.00%) .          .          .             lua_assert(L->top <= ci->top && ci->top <= L->stack_last);
        8 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaT_getvarargs (lua_State *L, CallInfo *ci, StkId where, int wanted) {
        .          .          .          .             int i;
        .          .          .          .             int nextra = ci->u.l.nextraargs;
        .          .          .          .             if (wanted < 0) {
        .          .          .          .               wanted = nextra;  
        .          .          .          .               checkstackGCp(L, nextra, where);  
        .          .          .          .               L->top = where + nextra;  
-- line 11807 ----------------------------------------
-- line 12131 ----------------------------------------
        .          .          .          .             else if (l_strton(obj, &v)) {  
        .          .          .          .               *n = nvalue(&v);  
        .          .          .          .               return 1;
        .          .          .          .             }
        .          .          .          .             else
        .          .          .          .               return 0;  
        .          .          .          .           }
        .          .          .          .           
      132 ( 0.00%) .          .          .           int luaV_flttointeger (lua_Number n, lua_Integer *p, F2Imod mode) {
      627 ( 0.00%) .          .          .             lua_Number f = l_floor(n);
       99 ( 0.00%) .          .          .             if (n != f) {  
       88 ( 0.00%) .          .          .               if (mode == F2Ieq) return 0;  
        .          .          .          .               else if (mode == F2Iceil)  
        .          .          .          .                 f += 1;  
        .          .          .          .             }
      143 ( 0.00%) .          .          .             return lua_numbertointeger(f, p);
      132 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           int luaV_tointegerns (const TValue *obj, lua_Integer *p, F2Imod mode) {
        .          .          .          .             if (ttisfloat(obj))
        .          .          .          .               return luaV_flttointeger(fltvalue(obj), p, mode);
        .          .          .          .             else if (ttisinteger(obj)) {
        .          .          .          .               *p = ivalue(obj);
        .          .          .          .               return 1;
        .          .          .          .             }
-- line 12155 ----------------------------------------
-- line 12248 ----------------------------------------
        .          .          .          .               setfltvalue(s2v(ra + 3), idx);  
        .          .          .          .               return 1;  
        .          .          .          .             }
        .          .          .          .             else
        .          .          .          .               return 0;  
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaV_finishget (lua_State *L, const TValue *t, TValue *key, StkId val,
      132 ( 0.00%) .          .          .                                 const TValue *slot) {
        .          .          .          .             int loop;  
        .          .          .          .             const TValue *tm;  
       44 ( 0.00%) .          .          .             for (loop = 0; loop < MAXTAGLOOP; loop++) {
       22 ( 0.00%) .          .          .               if (slot == NULL) {  
        .          .          .          .                 lua_assert(!ttistable(t));
        .          .          .          .                 tm = luaT_gettmbyobj(L, t, TM_INDEX);
        .          .          .          .                 if (l_unlikely(notm(tm)))
        .          .          .          .                   luaG_typeerror(L, t, "index");  
        .          .          .          .                 
        .          .          .          .               }
        .          .          .          .               else {  
       99 ( 0.00%) .          .          .                 lua_assert(isempty(slot));
      484 ( 0.00%) .          .          .                 tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);  
        .          .          .          .                 if (tm == NULL) {  
      121 ( 0.00%) .          .          .                   setnilvalue(s2v(val));  
        .          .          .          .                   return;
        .          .          .          .                 }
        .          .          .          .                 
        .          .          .          .               }
        .          .          .          .               if (ttisfunction(tm)) {  
        .          .          .          .                 luaT_callTMres(L, tm, t, key, val);  
        .          .          .          .                 return;
        .          .          .          .               }
-- line 12279 ----------------------------------------
-- line 12280 ----------------------------------------
        .          .          .          .               t = tm;  
        .          .          .          .               if (luaV_fastget(L, t, key, slot, luaH_get)) {  
        .          .          .          .                 setobj2s(L, val, slot);  
        .          .          .          .                 return;
        .          .          .          .               }
        .          .          .          .               
        .          .          .          .             }
        .          .          .          .             luaG_runerror(L, "'__index' chain too long; possible loop");
       88 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaV_finishset (lua_State *L, const TValue *t, TValue *key,
    1,524 ( 0.01%) .          .          .                                TValue *val, const TValue *slot) {
        .          .          .          .             int loop;  
      508 ( 0.00%) .          .          .             for (loop = 0; loop < MAXTAGLOOP; loop++) {
        .          .          .          .               const TValue *tm;  
      254 ( 0.00%) .          .          .               if (slot != NULL) {  
    4,318 ( 0.02%) .          .          .                 Table *h = hvalue(t);  
    1,270 ( 0.01%) .          .          .                 lua_assert(isempty(slot));  
    1,270 ( 0.01%) .          .          .                 tm = fasttm(L, h->metatable, TM_NEWINDEX);  
        .          .          .          .                 if (tm == NULL) {  
      762 ( 0.00%) .          .          .                   luaH_finishset(L, h, key, slot, val);  
  191,259 ( 0.88%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_finishset (127x)
    1,397 ( 0.01%) .          .          .                   invalidateTMcache(h);
    2,075 ( 0.01%) .          .          .                   luaC_barrierback(L, obj2gco(h), val);
        .          .          .          .                   return;
        .          .          .          .                 }
        .          .          .          .                 
        .          .          .          .               }
        .          .          .          .               else {  
        .          .          .          .                 tm = luaT_gettmbyobj(L, t, TM_NEWINDEX);
        .          .          .          .                 if (l_unlikely(notm(tm)))
        .          .          .          .                   luaG_typeerror(L, t, "index");
-- line 12310 ----------------------------------------
-- line 12317 ----------------------------------------
        .          .          .          .               t = tm;  
        .          .          .          .               if (luaV_fastget(L, t, key, slot, luaH_get)) {
        .          .          .          .                 luaV_finishfastset(L, t, slot, val);
        .          .          .          .                 return;  
        .          .          .          .               }
        .          .          .          .               
        .          .          .          .             }
        .          .          .          .             luaG_runerror(L, "'__newindex' chain too long; possible loop");
    1,016 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           static int l_strcmp (const TString *ls, const TString *rs) {
        .          .          .          .             const char *l = getstr(ls);
        .          .          .          .             size_t ll = tsslen(ls);
        .          .          .          .             const char *r = getstr(rs);
        .          .          .          .             size_t lr = tsslen(rs);
        .          .          .          .             for (;;) {  
        .          .          .          .               int temp = strcoll(l, r);
-- line 12333 ----------------------------------------
-- line 12341 ----------------------------------------
        .          .          .          .                   return -1;  
        .          .          .          .                 
        .          .          .          .                 len++;
        .          .          .          .                 l += len; ll -= len; r += len; lr -= len;
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .           }
        .          .          .          .           
        8 ( 0.00%) .          .          .           l_sinline int LTintfloat (lua_Integer i, lua_Number f) {
        5 ( 0.00%) .          .          .             if (l_intfitsf(i))
        6 ( 0.00%) .          .          .               return luai_numlt(cast_num(i), f);  
        .          .          .          .             else {  
        .          .          .          .               lua_Integer fi;
        .          .          .          .               if (luaV_flttointeger(f, &fi, F2Iceil))  
        .          .          .          .                 return i < fi;   
        .          .          .          .               else  
        .          .          .          .                 return f > 0;  
        .          .          .          .             }
        7 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           l_sinline int LEintfloat (lua_Integer i, lua_Number f) {
        .          .          .          .             if (l_intfitsf(i))
        .          .          .          .               return luai_numle(cast_num(i), f);  
        .          .          .          .             else {  
        .          .          .          .               lua_Integer fi;
        .          .          .          .               if (luaV_flttointeger(f, &fi, F2Ifloor))  
        .          .          .          .                 return i <= fi;   
        .          .          .          .               else  
        .          .          .          .                 return f > 0;  
        .          .          .          .             }
        .          .          .          .           }
        .          .          .          .           
       32 ( 0.00%) .          .          .           l_sinline int LTfloatint (lua_Number f, lua_Integer i) {
       20 ( 0.00%) .          .          .             if (l_intfitsf(i))
       24 ( 0.00%) .          .          .               return luai_numlt(f, cast_num(i));  
        .          .          .          .             else {  
        .          .          .          .               lua_Integer fi;
        .          .          .          .               if (luaV_flttointeger(f, &fi, F2Ifloor))  
        .          .          .          .                 return fi < i;   
        .          .          .          .               else  
        .          .          .          .                 return f < 0;  
        .          .          .          .             }
       28 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           l_sinline int LEfloatint (lua_Number f, lua_Integer i) {
        .          .          .          .             if (l_intfitsf(i))
        .          .          .          .               return luai_numle(f, cast_num(i));  
        .          .          .          .             else {  
        .          .          .          .               lua_Integer fi;
        .          .          .          .               if (luaV_flttointeger(f, &fi, F2Iceil))  
        .          .          .          .                 return fi <= i;   
        .          .          .          .               else  
        .          .          .          .                 return f < 0;  
        .          .          .          .             }
        .          .          .          .           }
        .          .          .          .           
       35 ( 0.00%) .          .          .           l_sinline int LTnum (const TValue *l, const TValue *r) {
      120 ( 0.00%) .          .          .             lua_assert(ttisnumber(l) && ttisnumber(r));
       30 ( 0.00%) .          .          .             if (ttisinteger(l)) {
        9 ( 0.00%) .          .          .               lua_Integer li = ivalue(l);
        6 ( 0.00%) .          .          .               if (ttisinteger(r))
        .          .          .          .                 return li < ivalue(r);  
        .          .          .          .               else  
       14 ( 0.00%) .          .          .                 return LTintfloat(li, fltvalue(r));  
       26 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:LTintfloat (1x)
        .          .          .          .             }
        .          .          .          .             else {
       44 ( 0.00%) .          .          .               lua_Number lf = fltvalue(l);  
       24 ( 0.00%) .          .          .               if (ttisfloat(r))
        .          .          .          .                 return luai_numlt(lf, fltvalue(r));  
        .          .          .          .               else  
       52 ( 0.00%) .          .          .                 return LTfloatint(lf, ivalue(r));
      104 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:LTfloatint (4x)
        .          .          .          .             }
       30 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           l_sinline int LEnum (const TValue *l, const TValue *r) {
        .          .          .          .             lua_assert(ttisnumber(l) && ttisnumber(r));
        .          .          .          .             if (ttisinteger(l)) {
        .          .          .          .               lua_Integer li = ivalue(l);
        .          .          .          .               if (ttisinteger(r))
        .          .          .          .                 return li <= ivalue(r);  
        .          .          .          .               else  
-- line 12421 ----------------------------------------
-- line 12453 ----------------------------------------
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           int luaV_lessequal (lua_State *L, const TValue *l, const TValue *r) {
        .          .          .          .             if (ttisnumber(l) && ttisnumber(r))  
        .          .          .          .               return LEnum(l, r);
        .          .          .          .             else return lessequalothers(L, l, r);
        .          .          .          .           }
        .          .          .          .           
    9,269 ( 0.04%) .          .          .           int luaV_equalobj (lua_State *L, const TValue *t1, const TValue *t2) {
        .          .          .          .             const TValue *tm;
   14,260 ( 0.07%) .          .          .             if (ttypetag(t1) != ttypetag(t2)) {  
        .          .          .          .               if (ttype(t1) != ttype(t2) || ttype(t1) != LUA_TNUMBER)
        .          .          .          .                 return 0;  
        .          .          .          .               else {  
        .          .          .          .                 
        .          .          .          .                 lua_Integer i1, i2;
        .          .          .          .                 return (luaV_tointegerns(t1, &i1, F2Ieq) &&
        .          .          .          .                         luaV_tointegerns(t2, &i2, F2Ieq) &&
        .          .          .          .                         i1 == i2);
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .             
    9,313 ( 0.04%) .          .          .             switch (ttypetag(t1)) {
        .          .          .          .               case LUA_VNIL: case LUA_VFALSE: case LUA_VTRUE: return 1;
      300 ( 0.00%) .          .          .               case LUA_VNUMINT: return (ivalue(t1) == ivalue(t2));
      112 ( 0.00%) .          .          .               case LUA_VNUMFLT: return luai_numeq(fltvalue(t1), fltvalue(t2));
        .          .          .          .               case LUA_VLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
        .          .          .          .               case LUA_VLCF: return fvalue(t1) == fvalue(t2);
   59,400 ( 0.27%) .          .          .               case LUA_VSHRSTR: return eqshrstr(tsvalue(t1), tsvalue(t2));
        .          .          .          .               case LUA_VLNGSTR: return luaS_eqlngstr(tsvalue(t1), tsvalue(t2));
        .          .          .          .               case LUA_VUSERDATA: {
        .          .          .          .                 if (uvalue(t1) == uvalue(t2)) return 1;
        .          .          .          .                 else if (L == NULL) return 0;
        .          .          .          .                 tm = fasttm(L, uvalue(t1)->metatable, TM_EQ);
        .          .          .          .                 if (tm == NULL)
        .          .          .          .                   tm = fasttm(L, uvalue(t2)->metatable, TM_EQ);
        .          .          .          .                 break;  
-- line 12489 ----------------------------------------
-- line 12500 ----------------------------------------
        .          .          .          .                 return gcvalue(t1) == gcvalue(t2);
        .          .          .          .             }
        .          .          .          .             if (tm == NULL)  
        .          .          .          .               return 0;  
        .          .          .          .             else {
        .          .          .          .               luaT_callTMres(L, tm, t1, t2, L->top);  
        .          .          .          .               return !l_isfalse(s2v(L->top));
        .          .          .          .             }
    7,843 ( 0.04%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #define tostring(L,o)  	(ttisstring(o) || (cvt2str(o) && (luaO_tostring(L, o), 1)))
        .          .          .          .           
        .          .          .          .           #define isemptystr(o)	(ttisshrstring(o) && tsvalue(o)->shrlen == 0)
        .          .          .          .           
       60 ( 0.00%) .          .          .           static void copy2buff (StkId top, int n, char *buff) {
       12 ( 0.00%) .          .          .             size_t tl = 0;  
        .          .          .          .             do {
    1,634 ( 0.01%) .          .          .               size_t l = vslen(s2v(top - n));  
      855 ( 0.00%) .          .          .               memcpy(buff + tl, svalue(s2v(top - n)), l * sizeof(char));
      198 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:memcpy@GLIBC_2.2.5 (15x)
       15 ( 0.00%) .          .          .               tl += l;
       90 ( 0.00%) .          .          .             } while (--n > 0);
       48 ( 0.00%) .          .          .           }
        .          .          .          .           
      204 ( 0.00%) .          .          .           void luaV_concat (lua_State *L, int total) {
       32 ( 0.00%) .          .          .             if (total == 1)
        .          .          .          .               return;  
        .          .          .          .             do {
       48 ( 0.00%) .          .          .               StkId top = L->top;
        .          .          .          .               int n = 2;  
      108 ( 0.00%) .          .          .               if (!(ttisstring(s2v(top - 2)) || cvt2str(s2v(top - 2))) ||
       60 ( 0.00%) .          .          .                   !tostring(L, s2v(top - 1)))
        .          .          .          .                 luaT_tryconcatTM(L);
      247 ( 0.00%) .          .          .               else if (isemptystr(s2v(top - 1)))  
        .          .          .          .                 cast_void(tostring(L, s2v(top - 2)));  
      282 ( 0.00%) .          .          .               else if (isemptystr(s2v(top - 2))) {  
        .          .          .          .                 setobjs2s(L, top - 2, top - 1);  
        .          .          .          .               }
        .          .          .          .               else {
        .          .          .          .                 
      425 ( 0.00%) .          .          .                 size_t tl = vslen(s2v(top - 1));
        .          .          .          .                 TString *ts;
        .          .          .          .                 
      246 ( 0.00%) .          .          .                 for (n = 1; n < total && tostring(L, s2v(top - n - 1)); n++) {
      909 ( 0.00%) .          .          .                   size_t l = vslen(s2v(top - n - 1));
       45 ( 0.00%) .          .          .                   if (l_unlikely(l >= (MAX_SIZE/sizeof(char)) - tl))
        .          .          .          .                     luaG_runerror(L, "string length overflow");
        9 ( 0.00%) .          .          .                   tl += l;
        .          .          .          .                 }
       18 ( 0.00%) .          .          .                 if (tl <= LUAI_MAXSHORTLEN) {  
        .          .          .          .                   char buff[LUAI_MAXSHORTLEN];
       25 ( 0.00%) .          .          .                   copy2buff(top, n, buff);  
    2,517 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:copy2buff (5x)
       25 ( 0.00%) .          .          .                   ts = luaS_newlstr(L, buff, tl);
    4,219 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_newlstr (5x)
        .          .          .          .                 }
        .          .          .          .                 else {  
        4 ( 0.00%) .          .          .                   ts = luaS_createlngstrobj(L, tl);
      300 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaS_createlngstrobj (1x)
       13 ( 0.00%) .          .          .                   copy2buff(top, n, getstr(ts));
      395 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:copy2buff (1x)
        .          .          .          .                 }
      678 ( 0.00%) .          .          .                 setsvalue2s(L, top - n, ts);  
        .          .          .          .               }
       42 ( 0.00%) .          .          .               total -= n-1;  
      114 ( 0.00%) .          .          .               L->top -= n-1;  
       12 ( 0.00%) .          .          .             } while (total > 1);  
      176 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaV_objlen (lua_State *L, StkId ra, const TValue *rb) {
        .          .          .          .             const TValue *tm;
        .          .          .          .             switch (ttypetag(rb)) {
        .          .          .          .               case LUA_VTABLE: {
        .          .          .          .                 Table *h = hvalue(rb);
        .          .          .          .                 tm = fasttm(L, h->metatable, TM_LEN);
        .          .          .          .                 if (tm) break;  
-- line 12570 ----------------------------------------
-- line 12584 ----------------------------------------
        .          .          .          .                 if (l_unlikely(notm(tm)))  
        .          .          .          .                   luaG_typeerror(L, rb, "get length of");
        .          .          .          .                 break;
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .             luaT_callTMres(L, tm, rb, rb, ra);
        .          .          .          .           }
        .          .          .          .           
        7 ( 0.00%) .          .          .           lua_Integer luaV_idiv (lua_State *L, lua_Integer m, lua_Integer n) {
        3 ( 0.00%) .          .          .             if (l_unlikely(l_castS2U(n) + 1u <= 1u)) {  
        .          .          .          .               if (n == 0)
        .          .          .          .                 luaG_runerror(L, "attempt to divide by zero");
        .          .          .          .               return intop(-, 0, m);   
        .          .          .          .             }
        .          .          .          .             else {
       16 ( 0.00%) .          .          .               lua_Integer q = m / n;  
        3 ( 0.00%) .          .          .               if ((m ^ n) < 0 && m % n != 0)  
        .          .          .          .                 q -= 1;  
        .          .          .          .               return q;
        .          .          .          .             }
        7 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           lua_Integer luaV_mod (lua_State *L, lua_Integer m, lua_Integer n) {
        .          .          .          .             if (l_unlikely(l_castS2U(n) + 1u <= 1u)) {  
        .          .          .          .               if (n == 0)
        .          .          .          .                 luaG_runerror(L, "attempt to perform 'n%%0'");
        .          .          .          .               return 0;   
        .          .          .          .             }
        .          .          .          .             else {
-- line 12612 ----------------------------------------
-- line 12634 ----------------------------------------
        .          .          .          .             }
        .          .          .          .             else {  
        .          .          .          .               if (y >= NBITS) return 0;
        .          .          .          .               else return intop(<<, x, y);
        .          .          .          .             }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           static void pushclosure (lua_State *L, Proto *p, UpVal **encup, StkId base,
      252 ( 0.00%) .          .          .                                    StkId ra) {
      162 ( 0.00%) .          .          .             int nup = p->sizeupvalues;
      144 ( 0.00%) .          .          .             Upvaldesc *uv = p->upvalues;
        .          .          .          .             int i;
       72 ( 0.00%) .          .          .             LClosure *ncl = luaF_newLclosure(L, nup);
    7,660 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_newLclosure (18x)
      144 ( 0.00%) .          .          .             ncl->p = p;
    1,656 ( 0.01%) .          .          .             setclLvalue2s(L, ra, ncl);  
      208 ( 0.00%) .          .          .             for (i = 0; i < nup; i++) {  
      374 ( 0.00%) .          .          .               if (uv[i].instack)  
      592 ( 0.00%) .          .          .                 ncl->upvals[i] = luaF_findupval(L, base + uv[i].idx);
    9,185 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_findupval (16x)
        .          .          .          .               else  
      216 ( 0.00%) .          .          .                 ncl->upvals[i] = encup[uv[i].idx];
      132 ( 0.00%) .          .          .               luaC_objbarrier(L, ncl, ncl->upvals[i]);
        .          .          .          .             }
      144 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           void luaV_finishOp (lua_State *L) {
        .          .          .          .             CallInfo *ci = L->ci;
        .          .          .          .             StkId base = ci->func + 1;
        .          .          .          .             Instruction inst = *(ci->u.l.savedpc - 1);  
        .          .          .          .             OpCode op = GET_OPCODE(inst);
        .          .          .          .             switch (op) {  
        .          .          .          .               case OP_MMBIN: case OP_MMBINI: case OP_MMBINK: {
-- line 12664 ----------------------------------------
-- line 12787 ----------------------------------------
        .          .          .          .           #define checkGC(L,c)  	{ luaC_condGC(L, (savepc(L), L->top = (c)),                          updatetrap(ci));            luai_threadyield(L); }
        .          .          .          .           
        .          .          .          .           #define vmfetch()	{   if (l_unlikely(trap)) {       trap = luaG_traceexec(L, pc);       updatebase(ci);     }   i = *(pc++);   ra = RA(i);  }
        .          .          .          .           
        .          .          .          .           #define vmdispatch(o)	switch(o)
        .          .          .          .           #define vmcase(l)	case l:
        .          .          .          .           #define vmbreak		break
        .          .          .          .           
       12 ( 0.00%) .          .          .           void luaV_execute (lua_State *L, CallInfo *ci) {
        .          .          .          .             LClosure *cl;
        .          .          .          .             TValue *k;
        .          .          .          .             StkId base;
        .          .          .          .             const Instruction *pc;
        .          .          .          .             int trap;
        .          .          .          .           #if LUA_USE_JUMPTABLE
        .          .          .          .           
        .          .          .          .           #undef vmdispatch
-- line 12803 ----------------------------------------
-- line 12902 ----------------------------------------
        .          .          .          .           &&L_OP_VARARG,
        .          .          .          .           &&L_OP_VARARGPREP,
        .          .          .          .           &&L_OP_EXTRAARG
        .          .          .          .           
        .          .          .          .           };
        .          .          .          .           
        .          .          .          .           #endif
        .          .          .          .            startfunc:
      121 ( 0.00%) .          .          .             trap = L->hookmask;
        .          .          .          .            returning:  
    1,100 ( 0.01%) .          .          .             cl = clLvalue(s2v(ci->func));
      400 ( 0.00%) .          .          .             k = cl->p->k;
      260 ( 0.00%) .          .          .             pc = ci->u.l.savedpc;
       40 ( 0.00%) .          .          .             if (l_unlikely(trap)) {
      300 ( 0.00%) .          .          .               if (pc == cl->p->code) {  
      121 ( 0.00%) .          .          .                 if (cl->p->is_vararg)
        2 ( 0.00%) .          .          .                   trap = 0;  
        .          .          .          .                 else  
       40 ( 0.00%) .          .          .                   luaD_hookcall(L, ci);
   94,291 ( 0.44%) 10 ( 1.87%) 162,440 ( 0.03%) 155,144 ( 0.03%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_hookcall (10x)
        .          .          .          .               }
      260 ( 0.00%) .          .          .               ci->u.l.trap = 1;  
        .          .          .          .             }
      260 ( 0.00%) .          .          .             base = ci->func + 1;
        .          .          .          .             
        .          .          .          .             for (;;) {
        .          .          .          .               Instruction i;  
        .          .          .          .               StkId ra;  
        .          .          .          .           
      502 ( 0.00%) .          .          .           		if (l_unlikely(trap)) {   
    1,000 ( 0.00%) .          .          .               	trap = luaG_traceexec(L, pc);   
1,683,795 ( 7.77%) 250 (46.82%) 4,222,232 ( 0.80%) 4,021,124 ( 0.82%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaG_traceexec (250x)
    3,500 ( 0.02%) .          .          .              		updatebase(ci);   
        .          .          .          .            		} 
    4,337 ( 0.02%) .          .          .            		i = *(pc++); 
    3,765 ( 0.02%) .          .          .             	ra = RA(i);  
        .          .          .          .               #if 0
        .          .          .          .                 
        .          .          .          .                 printf("line: %d\n", luaG_getfuncline(cl->p, pcRel(pc, cl->p)));
        .          .          .          .               #endif
    3,765 ( 0.02%) .          .          .               lua_assert(base == ci->func + 1);
    4,518 ( 0.02%) .          .          .               lua_assert(base <= L->top && L->top < L->stack_last);
        .          .          .          .               
    8,422 ( 0.04%) .          .          .               lua_assert(isIT(i) || (cast_void(L->top = base), 1));
    1,757 ( 0.01%) .          .          .               vmdispatch (GET_OPCODE(i)) {
        .          .          .          .                 vmcase(OP_MOVE) {
    2,057 ( 0.01%) .          .          .                   setobjs2s(L, ra, RB(i));
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_LOADI) {
      126 ( 0.00%) .          .          .                   lua_Integer b = GETARG_sBx(i);
      140 ( 0.00%) .          .          .                   setivalue(s2v(ra), b);
        7 ( 0.00%) .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_LOADF) {
        .          .          .          .                   int b = GETARG_sBx(i);
        .          .          .          .                   setfltvalue(s2v(ra), cast_num(b));
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_LOADK) {
      550 ( 0.00%) .          .          .                   TValue *rb = k + GETARG_Bx(i);
    2,575 ( 0.01%) .          .          .                   setobj2s(L, ra, rb);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_LOADKX) {
        .          .          .          .                   TValue *rb;
        .          .          .          .                   rb = k + GETARG_Ax(*pc); pc++;
        .          .          .          .                   setobj2s(L, ra, rb);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_LOADFALSE) {
       27 ( 0.00%) .          .          .                   setbfvalue(s2v(ra));
        3 ( 0.00%) .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_LFALSESKIP) {
        .          .          .          .                   setbfvalue(s2v(ra));
        .          .          .          .                   pc++;  
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_LOADTRUE) {
        .          .          .          .                   setbtvalue(s2v(ra));
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_LOADNIL) {
       28 ( 0.00%) .          .          .                   int b = GETARG_B(i);
        .          .          .          .                   do {
       31 ( 0.00%) .          .          .                     setnilvalue(s2v(ra++));
       16 ( 0.00%) .          .          .                   } while (b--);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_GETUPVAL) {
      221 ( 0.00%) .          .          .                   int b = GETARG_B(i);
    1,337 ( 0.01%) .          .          .                   setobj2s(L, ra, cl->upvals[b]->v);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_SETUPVAL) {
       52 ( 0.00%) .          .          .                   UpVal *uv = cl->upvals[GETARG_B(i)];
      108 ( 0.00%) .          .          .                   setobj(L, uv->v, s2v(ra));
       20 ( 0.00%) .          .          .                   luaC_barrier(L, uv, s2v(ra));
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_GETTABUP) {
        .          .          .          .                   const TValue *slot;
    1,462 ( 0.01%) .          .          .                   TValue *upval = cl->upvals[GETARG_B(i)]->v;
      688 ( 0.00%) .          .          .                   TValue *rc = KC(i);
    1,548 ( 0.01%) .          .          .                   TString *key = tsvalue(rc);  
    2,107 ( 0.01%) .          .          .                   if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
    8,917 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_getshortstr (43x)
    2,934 ( 0.01%) .          .          .                     setobj2s(L, ra, slot);
        .          .          .          .                   }
        .          .          .          .                   else
      160 ( 0.00%) .          .          .                     Protect(luaV_finishget(L, upval, rc, ra, slot));
      360 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_finishget (4x)
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_GETTABLE) {
        .          .          .          .                   const TValue *slot;
        .          .          .          .                   TValue *rb = vRB(i);
        .          .          .          .                   TValue *rc = vRC(i);
        .          .          .          .                   lua_Unsigned n;
        .          .          .          .                   if (ttisinteger(rc)  
-- line 13018 ----------------------------------------
-- line 13035 ----------------------------------------
        .          .          .          .                     TValue key;
        .          .          .          .                     setivalue(&key, c);
        .          .          .          .                     Protect(luaV_finishget(L, rb, &key, ra, slot));
        .          .          .          .                   }
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_GETFIELD) {
        .          .          .          .                   const TValue *slot;
      207 ( 0.00%) .          .          .                   TValue *rb = vRB(i);
      144 ( 0.00%) .          .          .                   TValue *rc = KC(i);
      324 ( 0.00%) .          .          .                   TString *key = tsvalue(rc);  
      441 ( 0.00%) .          .          .                   if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {
    1,805 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_getshortstr (9x)
      512 ( 0.00%) .          .          .                     setobj2s(L, ra, slot);
        .          .          .          .                   }
        .          .          .          .                   else
        .          .          .          .                     Protect(luaV_finishget(L, rb, rc, ra, slot));
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_SETTABUP) {
        .          .          .          .                   const TValue *slot;
      210 ( 0.00%) .          .          .                   TValue *upval = cl->upvals[GETARG_A(i)]->v;
      200 ( 0.00%) .          .          .                   TValue *rb = KB(i);
      307 ( 0.00%) .          .          .                   TValue *rc = RKC(i);
      350 ( 0.00%) .          .          .                   TString *key = tsvalue(rb);  
      490 ( 0.00%) .          .          .                   if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {
    1,888 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_getshortstr (10x)
        .          .          .          .                     luaV_finishfastset(L, upval, slot, rc);
        .          .          .          .                   }
        .          .          .          .                   else
      400 ( 0.00%) .          .          .                     Protect(luaV_finishset(L, upval, rb, rc, slot));
   40,839 ( 0.19%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_finishset (10x)
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_SETTABLE) {
        .          .          .          .                   const TValue *slot;
        .          .          .          .                   TValue *rb = vRB(i);  
        .          .          .          .                   TValue *rc = RKC(i);  
        .          .          .          .                   lua_Unsigned n;
        .          .          .          .                   if (ttisinteger(rb)  
-- line 13071 ----------------------------------------
-- line 13088 ----------------------------------------
        .          .          .          .                     TValue key;
        .          .          .          .                     setivalue(&key, c);
        .          .          .          .                     Protect(luaV_finishset(L, s2v(ra), &key, rc, slot));
        .          .          .          .                   }
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_SETFIELD) {
        .          .          .          .                   const TValue *slot;
      320 ( 0.00%) .          .          .                   TValue *rb = KB(i);
      496 ( 0.00%) .          .          .                   TValue *rc = RKC(i);
      560 ( 0.00%) .          .          .                   TString *key = tsvalue(rb);  
      848 ( 0.00%) .          .          .                   if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {
    2,504 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_getshortstr (16x)
        .          .          .          .                     luaV_finishfastset(L, s2v(ra), slot, rc);
        .          .          .          .                   }
        .          .          .          .                   else
      720 ( 0.00%) .          .          .                     Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));
   22,851 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_finishset (16x)
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_NEWTABLE) {
       98 ( 0.00%) .          .          .                   int b = GETARG_B(i);  
       84 ( 0.00%) .          .          .                   int c = GETARG_C(i);  
        .          .          .          .                   Table *t;
       21 ( 0.00%) .          .          .                   if (b > 0)
       75 ( 0.00%) .          .          .                     b = 1 << (b - 1);  
      385 ( 0.00%) .          .          .                   lua_assert((!TESTARG_k(i)) == (GETARG_Ax(*pc) == 0));
       70 ( 0.00%) .          .          .                   if (TESTARG_k(i))  
        .          .          .          .                     c += GETARG_Ax(*pc) * (MAXARG_C + 1);  
       35 ( 0.00%) .          .          .                   pc++;  
       63 ( 0.00%) .          .          .                   L->top = ra + 1;  
       21 ( 0.00%) .          .          .                   t = luaH_new(L);  
    3,372 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_new (7x)
      637 ( 0.00%) .          .          .                   sethvalue2s(L, ra, t);
       21 ( 0.00%) .          .          .                   if (b != 0 || c != 0)
       30 ( 0.00%) .          .          .                     luaH_resize(L, t, c, b);  
    4,141 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaH_resize (5x)
       98 ( 0.00%) .          .          .                   checkGC(L, ra + 1);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_SELF) {
        .          .          .          .                   const TValue *slot;
        .          .          .          .                   TValue *rb = vRB(i);
        .          .          .          .                   TValue *rc = RKC(i);
        .          .          .          .                   TString *key = tsvalue(rc);  
        .          .          .          .                   setobj2s(L, ra + 1, rb);
-- line 13129 ----------------------------------------
-- line 13134 ----------------------------------------
        .          .          .          .                     Protect(luaV_finishget(L, rb, rc, ra, slot));
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_ADDI) {
        .          .          .          .                   op_arithI(L, l_addi, luai_numadd);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_ADDK) {
      244 ( 0.00%) .          .          .                   op_arithK(L, l_addi, luai_numadd);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_SUBK) {
        .          .          .          .                   op_arithK(L, l_subi, luai_numsub);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_MULK) {
      131 ( 0.00%) .          .          .                   op_arithK(L, l_muli, luai_nummul);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_MODK) {
        .          .          .          .                   op_arithK(L, luaV_mod, luaV_modf);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_POWK) {
        .          .          .          .                   op_arithfK(L, luai_numpow);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_DIVK) {
      250 ( 0.00%) .          .          .                   op_arithfK(L, luai_numdiv);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_IDIVK) {
        .          .          .          .                   op_arithK(L, luaV_idiv, luai_numidiv);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_BANDK) {
        .          .          .          .                   op_bitwiseK(L, l_band);
-- line 13170 ----------------------------------------
-- line 13196 ----------------------------------------
        .          .          .          .                   }
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_ADD) {
        .          .          .          .                   op_arith(L, l_addi, luai_numadd);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_SUB) {
      236 ( 0.00%) .          .          .                   op_arith(L, l_subi, luai_numsub);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_MUL) {
        .          .          .          .                   op_arith(L, l_muli, luai_nummul);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_MOD) {
        .          .          .          .                   op_arith(L, luaV_mod, luaV_modf);
-- line 13212 ----------------------------------------
-- line 13303 ----------------------------------------
        .          .          .          .                     setbfvalue(s2v(ra));
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_LEN) {
        .          .          .          .                   Protect(luaV_objlen(L, ra, vRB(i)));
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_CONCAT) {
       65 ( 0.00%) .          .          .                   int n = GETARG_B(i);  
       55 ( 0.00%) .          .          .                   L->top = ra + n;  
      125 ( 0.00%) .          .          .                   ProtectNT(luaV_concat(L, n));
    9,725 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_concat (5x)
       70 ( 0.00%) .          .          .                   checkGC(L, L->top); 
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_CLOSE) {
       39 ( 0.00%) .          .          .                   Protect(luaF_close(L, ra, LUA_OK, 1));
      275 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaF_close (1x)
        1 ( 0.00%) .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_TBC) {
        .          .          .          .                   
        .          .          .          .                   halfProtect(luaF_newtbcupval(L, ra));
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_JMP) {
       38 ( 0.00%) .          .          .                   dojump(ci, i, 0);
        1 ( 0.00%) .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_EQ) {
        .          .          .          .                   int cond;
       23 ( 0.00%) .          .          .                   TValue *rb = vRB(i);
       44 ( 0.00%) .          .          .                   Protect(cond = luaV_equalobj(L, s2v(ra), rb));
      145 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaV_equalobj (1x)
       66 ( 0.00%) .          .          .                   docondjump();
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_LT) {
      521 ( 0.00%) .          .          .                   op_order(L, l_lti, LTnum, lessthanothers);
      494 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:LTnum (5x)
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_LE) {
        .          .          .          .                   op_order(L, l_lei, LEnum, lessequalothers);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_EQK) {
        .          .          .          .                   TValue *rb = KB(i);
-- line 13346 ----------------------------------------
-- line 13373 ----------------------------------------
        .          .          .          .                   op_orderI(L, l_gti, luai_numgt, 1, TM_LT);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_GEI) {
        .          .          .          .                   op_orderI(L, l_gei, luai_numge, 1, TM_LE);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_TEST) {
      140 ( 0.00%) .          .          .                   int cond = !l_isfalse(s2v(ra));
      249 ( 0.00%) .          .          .                   docondjump();
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_TESTSET) {
       24 ( 0.00%) .          .          .                   TValue *rb = vRB(i);
       32 ( 0.00%) .          .          .                   if (l_isfalse(rb) == GETARG_k(i))
        .          .          .          .                     pc++;
        .          .          .          .                   else {
       42 ( 0.00%) .          .          .                     setobj2s(L, ra, rb);
       57 ( 0.00%) .          .          .                     donextjump(ci);
        .          .          .          .                   }
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_CALL) {
        .          .          .          .                   CallInfo *newci;
      429 ( 0.00%) .          .          .                   int b = GETARG_B(i);
      429 ( 0.00%) .          .          .                   int nresults = GETARG_C(i) - 1;
       66 ( 0.00%) .          .          .                   if (b != 0)  
      297 ( 0.00%) .          .          .                     L->top = ra + b;  
        .          .          .          .                   
      297 ( 0.00%) .          .          .                   savepc(L);  
      196 ( 0.00%) .          .          .                   if ((newci = luaD_precall(L, ra, nresults)) == NULL)
11,524,077 (53.17%) 134 (25.09%) 2,413,191 ( 0.46%) 2,302,479 ( 0.47%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_precall (33x)
      264 ( 0.00%) .          .          .                     updatetrap(ci);  
        .          .          .          .                   else {  
       30 ( 0.00%) .          .          .                     ci = newci;
        .          .          .          .                     goto startfunc;
        .          .          .          .                   }
       22 ( 0.00%) .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_TAILCALL) {
       26 ( 0.00%) .          .          .                   int b = GETARG_B(i);  
        .          .          .          .                   int n;  
       22 ( 0.00%) .          .          .                   int nparams1 = GETARG_C(i);
        .          .          .          .                   
        4 ( 0.00%) .          .          .                   int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
        4 ( 0.00%) .          .          .                   if (b != 0)
       24 ( 0.00%) .          .          .                     L->top = ra + b;
        .          .          .          .                   else  
        .          .          .          .                     b = cast_int(L->top - ra);
       18 ( 0.00%) .          .          .                   savepc(ci);  
       20 ( 0.00%) .          .          .                   if (TESTARG_k(i)) {
        .          .          .          .                     luaF_closeupval(L, base);  
        .          .          .          .                     lua_assert(L->tbclist < base);  
        .          .          .          .                     lua_assert(base == ci->func + 1);
        .          .          .          .                   }
       20 ( 0.00%) .          .          .                   if ((n = luaD_pretailcall(L, ci, ra, b, delta)) < 0)  
   46,126 ( 0.21%) 22 ( 4.12%) 315,442 ( 0.06%) 306,378 ( 0.06%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_pretailcall (2x)
        .          .          .          .                     goto startfunc;  
        .          .          .          .                   else {  
       48 ( 0.00%) .          .          .                     ci->func -= delta;  
        8 ( 0.00%) .          .          .                     luaD_poscall(L, ci, n);  
    9,680 ( 0.04%) 2 ( 0.37%) 47,062 ( 0.01%) 45,076 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_poscall (2x)
       26 ( 0.00%) .          .          .                     updatetrap(ci);  
        2 ( 0.00%) .          .          .                     goto ret;  
        .          .          .          .                   }
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_RETURN) {
        .          .          .          .                   int n = GETARG_B(i) - 1;  
        .          .          .          .                   int nparams1 = GETARG_C(i);
        .          .          .          .                   if (n < 0)  
        .          .          .          .                     n = cast_int(L->top - ra);  
        .          .          .          .                   savepc(ci);
-- line 13441 ----------------------------------------
-- line 13450 ----------------------------------------
        .          .          .          .                   if (nparams1)  
        .          .          .          .                     ci->func -= ci->u.l.nextraargs + nparams1;
        .          .          .          .                   L->top = ra + n;  
        .          .          .          .                   luaD_poscall(L, ci, n);
        .          .          .          .                   updatetrap(ci);  
        .          .          .          .                   goto ret;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_RETURN0) {
       21 ( 0.00%) .          .          .                   if (l_unlikely(L->hookmask)) {
       15 ( 0.00%) .          .          .                     L->top = ra;
       27 ( 0.00%) .          .          .                     savepc(ci);
       12 ( 0.00%) .          .          .                     luaD_poscall(L, ci, 0);  
   26,195 ( 0.12%) 3 ( 0.56%) 48,674 ( 0.01%) 42,633 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_poscall (3x)
        6 ( 0.00%) .          .          .                     trap = 1;
        .          .          .          .                   }
        .          .          .          .                   else {  
        .          .          .          .                     int nres;
        .          .          .          .                     L->ci = ci->previous;  
        .          .          .          .                     L->top = base - 1;
        .          .          .          .                     for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
        .          .          .          .                       setnilvalue(s2v(L->top++));  
        .          .          .          .                   }
        .          .          .          .                   goto ret;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_RETURN1) {
       28 ( 0.00%) .          .          .                   if (l_unlikely(L->hookmask)) {
       36 ( 0.00%) .          .          .                     L->top = ra + 1;
       36 ( 0.00%) .          .          .                     savepc(ci);
       16 ( 0.00%) .          .          .                     luaD_poscall(L, ci, 1);  
   47,618 ( 0.22%) 4 ( 0.75%) 71,158 ( 0.01%) 68,132 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_poscall (4x)
        8 ( 0.00%) .          .          .                     trap = 1;
        .          .          .          .                   }
        .          .          .          .                   else {  
        .          .          .          .                     int nres = ci->nresults;
        .          .          .          .                     L->ci = ci->previous;  
        .          .          .          .                     if (nres == 0)
        .          .          .          .                       L->top = base - 1;  
        .          .          .          .                     else {
        .          .          .          .                       setobjs2s(L, base - 1, ra);  
        .          .          .          .                       L->top = base;
        .          .          .          .                       for (; l_unlikely(nres > 1); nres--)
        .          .          .          .                         setnilvalue(s2v(L->top++));  
        .          .          .          .                     }
        .          .          .          .                   }
        .          .          .          .                  ret:  
      117 ( 0.00%) .          .          .                   if (ci->callstatus & CIST_FRESH)
        .          .          .          .                     return;  
        .          .          .          .                   else {
       72 ( 0.00%) .          .          .                     ci = ci->previous;
        .          .          .          .                     goto returning;  
        .          .          .          .                   }
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_FORLOOP) {
        .          .          .          .                   if (ttisinteger(s2v(ra + 2))) {  
        .          .          .          .                     lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
        .          .          .          .                     if (count > 0) {  
        .          .          .          .                       lua_Integer step = ivalue(s2v(ra + 2));
-- line 13504 ----------------------------------------
-- line 13568 ----------------------------------------
        .          .          .          .                     TValue *val = s2v(ra + n);
        .          .          .          .                     setobj2t(L, &h->array[last - 1], val);
        .          .          .          .                     last--;
        .          .          .          .                     luaC_barrierback(L, obj2gco(h), val);
        .          .          .          .                   }
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_CLOSURE) {
      702 ( 0.00%) .          .          .                   Proto *p = cl->p->p[GETARG_Bx(i)];
      666 ( 0.00%) .          .          .                   halfProtect(pushclosure(L, p, cl->upvals, base, ra));
   20,941 ( 0.10%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:pushclosure (18x)
      252 ( 0.00%) .          .          .                   checkGC(L, ra + 1);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_VARARG) {
        .          .          .          .                   int n = GETARG_C(i) - 1;  
        .          .          .          .                   Protect(luaT_getvarargs(L, ci, ra, n));
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_VARARGPREP) {
       34 ( 0.00%) .          .          .                   ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));
      261 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:luaT_adjustvarargs (1x)
        2 ( 0.00%) .          .          .                   if (l_unlikely(trap)) {  
        3 ( 0.00%) .          .          .                     luaD_hookcall(L, ci);
    4,860 ( 0.02%) 1 ( 0.19%) 32,358 ( 0.01%) 30,493 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:luaD_hookcall (1x)
        6 ( 0.00%) .          .          .                     L->oldpc = 1;  
        .          .          .          .                   }
       13 ( 0.00%) .          .          .                   updatebase(ci);  
        1 ( 0.00%) .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .                 vmcase(OP_EXTRAARG) {
        .          .          .          .                   luai_unreachable(0);
        .          .          .          .                   vmbreak;
        .          .          .          .                 }
        .          .          .          .           			#ifndef LUA_USE_JUMPTABLE
        .          .          .          .           			default : luai_unreachable();
        .          .          .          .           			#endif
-- line 13601 ----------------------------------------
-- line 13602 ----------------------------------------
        .          .          .          .               }
        .          .          .          .             }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           // root include lzio.c
        .          .          .          .           
        .          .          .          .           //included "string.h" 
        .          .          .          .           
       64 ( 0.00%) .          .          .           int luaZ_fill (ZIO *z) {
        .          .          .          .             size_t size;
       64 ( 0.00%) .          .          .             lua_State *L = z->L;
        .          .          .          .             const char *buff;
        .          .          .          .             lua_unlock(L);
      112 ( 0.00%) .          .          .             buff = z->reader(L, z->data, &size);
    5,752 ( 0.03%) 7 ( 1.31%) 130,232 ( 0.02%) 122,118 ( 0.02%)  => /home/utoecat/Github/protected_github/onlylua/test.c:getF (8x)
        .          .          .          .             lua_lock(L);
       34 ( 0.00%) .          .          .             if (buff == NULL || size == 0)
        4 ( 0.00%) .          .          .               return EOZ;
       36 ( 0.00%) .          .          .             z->n = size - 1;  
       30 ( 0.00%) .          .          .             z->p = buff;
       96 ( 0.00%) .          .          .             return cast_uchar(*(z->p++));
       64 ( 0.00%) .          .          .           }
        .          .          .          .           
       18 ( 0.00%) .          .          .           void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader, void *data) {
       16 ( 0.00%) .          .          .             z->L = L;
       10 ( 0.00%) .          .          .             z->reader = reader;
       10 ( 0.00%) .          .          .             z->data = data;
       10 ( 0.00%) .          .          .             z->n = 0;
       10 ( 0.00%) .          .          .             z->p = NULL;
       12 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           size_t luaZ_read (ZIO *z, void *b, size_t n) {
        .          .          .          .             while (n) {
        .          .          .          .               size_t m;
        .          .          .          .               if (z->n == 0) {  
        .          .          .          .                 if (luaZ_fill(z) == EOZ)  
        .          .          .          .                   return n;  
        .          .          .          .                 else {
-- line 13638 ----------------------------------------

--------------------------------------------------------------------------------
-- User-annotated source: ../lua.c
--------------------------------------------------------------------------------
  No information has been collected for ../lua.c

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/utoecat/Github/protected_github/onlylua/test.c
--------------------------------------------------------------------------------
Ir             sysCount sysTime sysCpuTime 

-- line 8 ----------------------------------------
    .          .          .          .           #include <lua.h>
    .          .          .          .           #include <stdlib.h>
    .          .          .          .           #include <stdio.h>
    .          .          .          .           #include <stdarg.h>
    .          .          .          .           #include <string.h>
    .          .          .          .           #include <time.h>
    .          .          .          .           #include <errno.h>
    .          .          .          .           
    4 ( 0.00%) .          .          .           static int osclock (lua_State *L) {
   18 ( 0.00%) .          .          .             lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);
  692 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
  138 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushnumber (2x)
   68 ( 0.00%) 2 ( 0.37%) 9,787 ( 0.00%) 8,782 ( 0.00%)  => /usr/src/debug/glibc/glibc/time/../sysdeps/unix/sysv/linux/clock.c:clock (2x)
    .          .          .          .             return 1;
    6 ( 0.00%) .          .          .           }
    .          .          .          .           
    2 ( 0.00%) .          .          .           static int stacktrace(lua_State* L) {
    4 ( 0.00%) .          .          .           	if (lua_isnone(L, 1)) lua_pushstring(L, "fuck");
  103 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_type (1x)
    9 ( 0.00%) .          .          .           	luaL_traceback(L, L, lua_tostring(L, -1), 1);
83,976 ( 0.39%) 29 ( 5.43%) 529,647 ( 0.10%) 509,921 ( 0.10%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_traceback (1x)
  147 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_tolstring (1x)
    .          .          .          .           	return 1;
    3 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           /****************
    .          .          .          .            * We need to load files somehow...
    .          .          .          .            */
    .          .          .          .           
    .          .          .          .           typedef struct LoadF {
    .          .          .          .             int n;  /* number of pre-read characters */
    .          .          .          .             FILE *f;  /* file being read */
    .          .          .          .             char buff[BUFSIZ];  /* area for reading file */
    .          .          .          .           } LoadF;
    .          .          .          .           
   40 ( 0.00%) .          .          .           static const char *getF (lua_State *L, void *ud, size_t *size) {
    .          .          .          .             LoadF *lf = (LoadF *)ud;
    .          .          .          .             (void)L;  /* not used */
   56 ( 0.00%) .          .          .             if (lf->n > 0) {  /* are there pre-read characters to be read? */
   20 ( 0.00%) .          .          .               *size = lf->n;  /* return them (chars already in buffer) */
   10 ( 0.00%) .          .          .               lf->n = 0;  /* no more pre-read characters */
    .          .          .          .             }
    .          .          .          .             else {
   80 ( 0.00%) .          .          .               if (feof(lf->f)) return NULL;
  724 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
   42 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/libio/feof.c:feof (6x)
  104 ( 0.00%) .          .          .               *size = fread(lf->buff, 1, sizeof(lf->buff), lf->f);  /* read block */
3,905 ( 0.02%) 7 ( 1.31%) 130,232 ( 0.02%) 122,118 ( 0.02%)  => /usr/src/debug/glibc/glibc/libio/iofread.c:fread (4x)
  691 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
    .          .          .          .             }
   48 ( 0.00%) .          .          .             return lf->buff;
   32 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           static int errfile (lua_State *L, const char *what, int fnameindex) {
    .          .          .          .             const char *serr = strerror(errno);
    .          .          .          .             const char *filename = lua_tostring(L, fnameindex) + 1;
    .          .          .          .             lua_pushfstring(L, "cannot %s %s: %s", what, filename, serr);
    .          .          .          .             lua_remove(L, fnameindex);
    .          .          .          .             return LUA_ERRERR;
    .          .          .          .           }
    .          .          .          .           
   12 ( 0.00%) .          .          .           static int skipBOM (LoadF *lf) {
    4 ( 0.00%) .          .          .             const char *p = "\xEF\xBB\xBF";  /* UTF-8 BOM mark */
    .          .          .          .             int c;
   10 ( 0.00%) .          .          .             lf->n = 0;
    .          .          .          .             do {
   26 ( 0.00%) .          .          .               c = getc(lf->f);
  930 ( 0.00%) 4 ( 0.75%) 54,457 ( 0.01%) 52,377 ( 0.01%)  => /usr/src/debug/glibc/glibc/libio/getc.c:getc (2x)
  691 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
   22 ( 0.00%) .          .          .               if (c == EOF || c != *(const unsigned char *)p++) return c;
    .          .          .          .               lf->buff[lf->n++] = c;  /* to be read by the parser */
    .          .          .          .             } while (*p != '\0');
    .          .          .          .             lf->n = 0;  /* prefix matched; discard it */
    .          .          .          .             return getc(lf->f);  /* return next character */
   14 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           
    .          .          .          .           /*
    .          .          .          .           ** reads the first character of file 'f' and skips an optional BOM mark
    .          .          .          .           ** in its beginning plus its first line if it starts with '#'. Returns
    .          .          .          .           ** true if it skipped the first line.  In any case, '*cp' has the
    .          .          .          .           ** first "valid" character of the file (after the optional BOM and
    .          .          .          .           ** a first-line comment).
    .          .          .          .           */
   10 ( 0.00%) .          .          .           static int skipcomment (LoadF *lf, int *cp) {
   22 ( 0.00%) .          .          .             int c = *cp = skipBOM(lf);
1,709 ( 0.01%) 4 ( 0.75%) 54,457 ( 0.01%) 52,377 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/test.c:skipBOM (2x)
    4 ( 0.00%) .          .          .             if (c == '#') {  /* first line is a comment (Unix exec. file)? */
    .          .          .          .               do {  /* skip first line */
   80 ( 0.00%) .          .          .                 c = getc(lf->f);
  136 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/libio/getc.c:getc (8x)
   64 ( 0.00%) .          .          .               } while (c != EOF && c != '\n');
   13 ( 0.00%) .          .          .               *cp = getc(lf->f);  /* skip end-of-line, if present */
   17 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/libio/getc.c:getc (1x)
    2 ( 0.00%) .          .          .               return 1;  /* there was a comment */
    .          .          .          .             }
    1 ( 0.00%) .          .          .             else return 0;  /* no comment */
    8 ( 0.00%) .          .          .           }
    .          .          .          .           
   26 ( 0.00%) .          .          .           LUALIB_API int loadfilex (lua_State *L, const char *filename, const char *mode) {
    .          .          .          .             LoadF lf;
    .          .          .          .             int status, readstatus;
    .          .          .          .             int c;
    8 ( 0.00%) .          .          .             int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */
   72 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_gettop (2x)
    4 ( 0.00%) .          .          .             if (filename == NULL) {
    .          .          .          .               lua_pushliteral(L, "=stdin");
    .          .          .          .               lf.f = stdin;
    .          .          .          .             }
    .          .          .          .             else {
   10 ( 0.00%) .          .          .               lua_pushfstring(L, "@%s", filename);
3,378 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushfstring (2x)
   14 ( 0.00%) .          .          .               lf.f = fopen(filename, "r");
  724 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
1,021 ( 0.00%) 2 ( 0.37%) 94,992 ( 0.02%) 92,433 ( 0.02%)  => /usr/src/debug/glibc/glibc/libio/iofopen.c:fopen@@GLIBC_2.2.5 (2x)
    4 ( 0.00%) .          .          .               if (lf.f == NULL) return errfile(L, "open", fnameindex);
    .          .          .          .             }
   10 ( 0.00%) .          .          .             if (skipcomment(&lf, &c))  /* read initial portion */
2,066 ( 0.01%) 4 ( 0.75%) 54,457 ( 0.01%) 52,377 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/test.c:skipcomment (2x)
   25 ( 0.00%) .          .          .               lf.buff[lf.n++] = '\n';  /* add line to correct line numbers */
    4 ( 0.00%) .          .          .             if (c == LUA_SIGNATURE[0] && filename) {  /* binary file? */
    .          .          .          .               lf.f = freopen(filename, "rb", lf.f);  /* reopen in binary mode */
    .          .          .          .               if (lf.f == NULL) return errfile(L, "reopen", fnameindex);
    .          .          .          .               skipcomment(&lf, &c);  /* re-read initial portion */
    .          .          .          .             }
    6 ( 0.00%) .          .          .             if (c != EOF)
   50 ( 0.00%) .          .          .               lf.buff[lf.n++] = c;  /* 'c' is the first character of the stream */
   22 ( 0.00%) .          .          .             status = lua_load(L, getF, &lf, lua_tostring(L, -1), mode);
14,764,658 (68.12%) 8 ( 1.50%) 156,491 ( 0.03%) 146,870 ( 0.03%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_load (2x)
  294 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_tolstring (2x)
   12 ( 0.00%) .          .          .             readstatus = ferror(lf.f);
  734 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
   14 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/libio/ferror.c:ferror (2x)
   14 ( 0.00%) .          .          .             if (filename) fclose(lf.f);  /* close file (even in case of errors) */
  750 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
1,068 ( 0.00%) 2 ( 0.37%) 26,646 ( 0.01%) 23,257 ( 0.00%)  => /usr/src/debug/glibc/glibc/libio/iofclose.c:fclose@@GLIBC_2.2.5 (2x)
    4 ( 0.00%) .          .          .             if (readstatus) {
    .          .          .          .               lua_settop(L, fnameindex);  /* ignore results from 'lua_load' */
    .          .          .          .               return errfile(L, "read", fnameindex);
    .          .          .          .             }
   14 ( 0.00%) .          .          .             lua_remove(L, fnameindex);
  968 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_rotate (2x)
  182 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop (2x)
    .          .          .          .             return status;
   24 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           /*************
    .          .          .          .            * And lua wrapper. Theese functions are REMOVED from baselib... so add them here...
    .          .          .          .            */
    .          .          .          .           
    2 ( 0.00%) .          .          .           static int load_aux (lua_State *L, int status, int envidx) {
    2 ( 0.00%) .          .          .             if (luai_likely(status == LUA_OK)) {
    2 ( 0.00%) .          .          .               if (envidx != 0) {  /* 'env' parameter? */
    .          .          .          .                 lua_pushvalue(L, envidx);  /* environment for loaded function */
    .          .          .          .                 if (!lua_setupvalue(L, -2, 1))  /* set it as 1st upvalue */
    .          .          .          .                   lua_pop(L, 1);  /* remove 'env' if not used by previous call */
    .          .          .          .               }
    1 ( 0.00%) .          .          .               return 1;
    .          .          .          .             }
    .          .          .          .             else {  /* error (message is on top of the stack) */
    .          .          .          .               luaL_pushfail(L);
    .          .          .          .               lua_insert(L, -2);  /* put before error message */
    .          .          .          .               return 2;  /* return fail plus error message */
    .          .          .          .             }
    2 ( 0.00%) .          .          .           }
    .          .          .          .           
    6 ( 0.00%) .          .          .           static int luaB_loadfile (lua_State *L) {
    5 ( 0.00%) .          .          .             const char *fname = luaL_optstring(L, 1, NULL);
  292 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_optlstring (1x)
    6 ( 0.00%) .          .          .             const char *mode = luaL_optstring(L, 2, NULL);
  147 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_optlstring (1x)
    7 ( 0.00%) .          .          .             int env = (!lua_isnone(L, 3) ? 3 : 0);  /* 'env' index or 0 if no 'env' */
  126 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_type (1x)
    5 ( 0.00%) .          .          .             int status = loadfilex(L, fname, mode);
10,986,687 (50.69%) 9 ( 1.69%) 182,774 ( 0.03%) 173,505 ( 0.04%)  => /home/utoecat/Github/protected_github/onlylua/test.c:loadfilex (1x)
    3 ( 0.00%) .          .          .             return load_aux(L, status, env);
    9 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/test.c:load_aux (1x)
    6 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           static int dofilecont (lua_State *L, int d1, lua_KContext d2) {
    .          .          .          .             (void)d1;  (void)d2;  /* only to match 'lua_Kfunction' prototype */
    .          .          .          .             return lua_gettop(L) - 1;
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           static int luaB_dofile (lua_State *L) {
    .          .          .          .             const char *fname = luaL_optstring(L, 1, NULL);
-- line 160 ----------------------------------------
-- line 163 ----------------------------------------
    .          .          .          .           		fprintf(stderr, "DOFILE ERROR > %s %s\n", fname, lua_tostring(L, -1));
    .          .          .          .               return lua_error(L);
    .          .          .          .           	}
    .          .          .          .           	fprintf(stderr, "DOFILE > %s \n", fname);
    .          .          .          .             lua_callk(L, 0, LUA_MULTRET, 0, dofilecont);
    .          .          .          .             return dofilecont(L, 0, 0);
    .          .          .          .           }
    .          .          .          .           
    2 ( 0.00%) .          .          .           int protected (lua_State* L) {
    1 ( 0.00%) .          .          .           	luaL_openlibs(L);
436,415 ( 2.01%) 13 ( 2.43%) 386,380 ( 0.07%) 363,695 ( 0.07%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_openlibs (1x)
    4 ( 0.00%) .          .          .           	lua_pushcfunction(L, osclock);
   80 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushcclosure (1x)
    3 ( 0.00%) .          .          .           	lua_setglobal(L, "clock");
2,522 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_setglobal (1x)
    4 ( 0.00%) .          .          .           	lua_pushcfunction(L, luaB_loadfile);
   80 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushcclosure (1x)
    3 ( 0.00%) .          .          .           	lua_setglobal(L, "loadfile");
2,636 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_setglobal (1x)
    4 ( 0.00%) .          .          .           	lua_pushcfunction(L, luaB_dofile);
   80 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushcclosure (1x)
    3 ( 0.00%) .          .          .           	lua_setglobal(L, "dofile");
2,469 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_setglobal (1x)
    .          .          .          .           	return 0;
    3 ( 0.00%) .          .          .           }
    .          .          .          .           
2,345 ( 0.01%) .          .          .           void myHook (lua_State* L, lua_Debug* ar) {
2,680 ( 0.01%) .          .          .           	if (ar->event == LUA_HOOKLINE || ar->event == LUA_HOOKCOUNT) {
1,000 ( 0.00%) .          .          .           		lua_getinfo(L, "Snl", ar);
1,201,965 ( 5.55%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_getinfo (250x)
6,000 ( 0.03%) .          .          .           		fprintf(stderr, "HOOK (LINE) > %s (%s) %s at %i\n", ar->namewhat, ar->name, ar->source, ar->currentline);
361,036 ( 1.67%) 250 (46.82%) 4,222,232 ( 0.80%) 4,021,124 ( 0.82%)  => /usr/src/debug/glibc/glibc/stdio-common/fprintf.c:fprintf (250x)
  850 ( 0.00%) .          .          .           	} else if (ar->event == LUA_HOOKCALL || ar->event == LUA_HOOKTAILCALL) {
  176 ( 0.00%) .          .          .           		lua_getinfo(L, "Snl", ar);
200,732 ( 0.93%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_getinfo (44x)
1,016 ( 0.00%) .          .          .           		fprintf(stderr, "HOOK (CALL) > %s (%s) %s at %i\n", ar->namewhat, ar->name, ar->source, ar->currentline);
64,078 ( 0.30%) 44 ( 8.24%) 856,056 ( 0.16%) 816,954 ( 0.17%)  => /usr/src/debug/glibc/glibc/stdio-common/fprintf.c:fprintf (44x)
  766 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
    .          .          .          .           	} else {
  164 ( 0.00%) .          .          .           		lua_getinfo(L, "Snl", ar);
182,259 ( 0.84%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_getinfo (41x)
  943 ( 0.00%) .          .          .           		fprintf(stderr, "HOOK (RETN) > %s (%s) %s at %i\n", ar->namewhat, ar->name, ar->source, ar->currentline);
59,687 ( 0.28%) 41 ( 7.68%) 965,107 ( 0.18%) 912,010 ( 0.19%)  => /usr/src/debug/glibc/glibc/stdio-common/fprintf.c:fprintf (41x)
    .          .          .          .           	}
2,051 ( 0.01%) .          .          .           }
    .          .          .          .           
    5 ( 0.00%) .          .          .           int main(int l, const char** argv) {
    3 ( 0.00%) .          .          .           	if (l < 2) {
    .          .          .          .           		perror("file argument required!\n");
    .          .          .          .           		return -1;
    .          .          .          .           	}
    2 ( 0.00%) .          .          .           	lua_State *L = luaL_newstate();
71,099 ( 0.33%) 1 ( 0.19%) 6,806 ( 0.00%) 4,726 ( 0.00%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_newstate (1x)
    5 ( 0.00%) .          .          .           	lua_sethook(L, myHook, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
   91 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_sethook (1x)
    .          .          .          .           
    4 ( 0.00%) .          .          .           	lua_pushcclosure(L, stacktrace, 0);
   80 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushcclosure (1x)
    4 ( 0.00%) .          .          .           	lua_pushcclosure(L, protected, 0);
   80 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushcclosure (1x)
    9 ( 0.00%) .          .          .           	if (lua_pcallk(L, 0, 1, -2, 0, NULL) != LUA_OK) {
451,425 ( 2.08%) 15 ( 2.81%) 449,541 ( 0.09%) 423,427 ( 0.09%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pcallk (1x)
    .          .          .          .           		printf("Error! %s\n", lua_tostring(L, -1));
    .          .          .          .           		return -66;
    .          .          .          .           	}
    .          .          .          .           
    4 ( 0.00%) .          .          .           	lua_pushcclosure(L, stacktrace, 0);
   80 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushcclosure (1x)
   15 ( 0.00%) .          .          .           	if (loadfilex(L, argv[1], "bt") != LUA_OK) {
3,789,493 (17.48%) 7 ( 1.31%) 149,812 ( 0.03%) 141,432 ( 0.03%)  => /home/utoecat/Github/protected_github/onlylua/test.c:loadfilex (1x)
    .          .          .          .           		fprintf(stderr, "Can't load lua source! (%s, %s, %i)\n", lua_tostring(L, -1), argv[1], lua_gettop(L));
    .          .          .          .           		return -3;
    .          .          .          .           	}
    .          .          .          .           
    9 ( 0.00%) .          .          .           	if (lua_pcallk(L, 0, 0, -2, 0, NULL) != LUA_OK) {
13,625,940 (62.87%) 426 (79.78%) 7,312,557 ( 1.39%) 6,971,459 ( 1.42%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pcallk (1x)
   14 ( 0.00%) .          .          .           		printf("Error! (%s)\n", lua_tostring(L, -1));
1,988 ( 0.01%) 2 ( 0.37%) 49,021 ( 0.01%) 46,692 ( 0.01%)  => /usr/src/debug/glibc/glibc/stdio-common/printf.c:printf (1x)
  740 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
  147 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_tolstring (1x)
    .          .          .          .           	};
    .          .          .          .           
    2 ( 0.00%) .          .          .           	lua_close(L);
254,273 ( 1.17%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_close (1x)
    .          .          .          .           	return 0;
    7 ( 0.00%) .          .          .           }

--------------------------------------------------------------------------------
-- User-annotated source: ../lua.h
--------------------------------------------------------------------------------
  No information has been collected for ../lua.h

--------------------------------------------------------------------------------
-- User-annotated source: ../lualib.c
--------------------------------------------------------------------------------
  No information has been collected for ../lualib.c

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/utoecat/Github/protected_github/onlylua/lualib.c
--------------------------------------------------------------------------------
Ir             sysCount sysTime sysCpuTime 

-- line 38 ----------------------------------------
    .          .          .          .           #if !defined(MAX_SIZET)
    .          .          .          .           
    .          .          .          .           #define MAX_SIZET	((size_t)(~(size_t)0))
    .          .          .          .           #endif
    .          .          .          .           
    .          .          .          .           #define LEVELS1	10	
    .          .          .          .           #define LEVELS2	11	
    .          .          .          .           
   15 ( 0.00%) .          .          .           static void pushfuncname (lua_State *L, lua_Debug *ar) {
    .          .          .          .           	// function argument at the top of the stack is required!
   12 ( 0.00%) .          .          .           	lua_assert(lua_isfunction(L, -1));
  294 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_type (3x)
   36 ( 0.00%) .          .          .             if (*ar->namewhat != '\0')  
   22 ( 0.00%) .          .          .               lua_pushfstring(L, "%s '%s'", ar->namewhat, ar->name);  
4,426 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushfstring (2x)
   13 ( 0.00%) .          .          .             else if (*ar->what == 'm')  
    4 ( 0.00%) .          .          .                 lua_pushliteral(L, "main chunk");
1,232 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushstring (1x)
    .          .          .          .             else if (*ar->what != 'C')  
    .          .          .          .               lua_pushfstring(L, "function <%s:%d>", ar->short_src, ar->linedefined);
    .          .          .          .           	else if (*ar->what == 'C') {
    .          .          .          .           		// some shitty magic here...
    .          .          .          .           		lua_pushfstring(L, "Cfunction <%p>", lua_topointer(L, -1));
    .          .          .          .           	} else  
    .          .          .          .               lua_pushliteral(L, "?");
   12 ( 0.00%) .          .          .           }
    .          .          .          .           
   10 ( 0.00%) .          .          .           static int lastlevel (lua_State *L) {
    .          .          .          .             lua_Debug ar;
    2 ( 0.00%) .          .          .             int li = 1, le = 1;
    .          .          .          .             
   27 ( 0.00%) .          .          .             while (lua_getstack(L, le, &ar)) { li = le; le *= 2; }
  314 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_getstack (3x)
    .          .          .          .             
    4 ( 0.00%) .          .          .             while (li < le) {
    8 ( 0.00%) .          .          .               int m = (li + le)/2;
   10 ( 0.00%) .          .          .               if (lua_getstack(L, m, &ar)) li = m + 1;
  124 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_getstack (1x)
    .          .          .          .               else le = m;
    .          .          .          .             }
    3 ( 0.00%) .          .          .             return le - 1;
   11 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           LUALIB_API void luaL_traceback (lua_State *L, lua_State *L1,
   14 ( 0.00%) .          .          .                                           const char *msg, int level) {
    .          .          .          .             luaL_Buffer b;
    .          .          .          .             lua_Debug ar;
    3 ( 0.00%) .          .          .             int last = lastlevel(L1);
  513 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:lastlevel (1x)
    7 ( 0.00%) .          .          .             int limit2show = (last - level > LEVELS1 + LEVELS2) ? LEVELS1 : -1;
    3 ( 0.00%) .          .          .             luaL_buffinit(L, &b);
1,389 ( 0.01%) 1 ( 0.19%) 18,994 ( 0.00%) 18,166 ( 0.00%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_buffinit (1x)
    2 ( 0.00%) .          .          .             if (msg) {
    3 ( 0.00%) .          .          .               luaL_addstring(&b, msg);
5,469 ( 0.03%) 4 ( 0.75%) 65,224 ( 0.01%) 63,294 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_addstring (1x)
   15 ( 0.00%) .          .          .               luaL_addchar(&b, '\n');
    .          .          .          .             }
    3 ( 0.00%) .          .          .             luaL_addstring(&b, "stack traceback:");
5,427 ( 0.03%) 4 ( 0.75%) 53,928 ( 0.01%) 52,710 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_addstring (1x)
   47 ( 0.00%) .          .          .             while (lua_getstack(L1, level++, &ar)) {
  438 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_getstack (4x)
   15 ( 0.00%) .          .          .               if (limit2show-- == 0) {  
    .          .          .          .                 int n = last - level - LEVELS2 + 1;  
    .          .          .          .                 lua_pushfstring(L, "\n\t...\t(skipping %d levels)", n);
    .          .          .          .                 luaL_addvalue(&b);  
    .          .          .          .                 level += n;  
    .          .          .          .               }
    .          .          .          .               else {
   12 ( 0.00%) .          .          .                 lua_getinfo(L1, "Slnt", &ar);
24,027 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_getinfo (3x)
    9 ( 0.00%) .          .          .                 if (ar.currentline <= 0)
    6 ( 0.00%) .          .          .                   lua_pushfstring(L, "\n\t%s: in ", ar.short_src);
1,804 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushfstring (1x)
    .          .          .          .                 else
   10 ( 0.00%) .          .          .                   lua_pushfstring(L, "\n\t%s:%d: in ", ar.short_src, ar.currentline);
5,466 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushfstring (2x)
    9 ( 0.00%) .          .          .                 luaL_addvalue(&b);
13,314 ( 0.06%) 9 ( 1.69%) 184,595 ( 0.04%) 177,316 ( 0.04%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_addvalue (3x)
   15 ( 0.00%) .          .          .                 lua_getinfo(L1, "f", &ar); // get function object
  996 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_getinfo (3x)
    9 ( 0.00%) .          .          .                 pushfuncname(L, &ar);
6,066 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:pushfuncname (3x)
   21 ( 0.00%) .          .          .           			lua_remove(L, -2); // remove it
1,404 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_rotate (3x)
  273 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop (3x)
    6 ( 0.00%) .          .          .                 luaL_addvalue(&b);
13,314 ( 0.06%) 9 ( 1.69%) 178,852 ( 0.03%) 171,256 ( 0.03%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_addvalue (3x)
    6 ( 0.00%) .          .          .                 if (ar.istailcall)
    .          .          .          .                   luaL_addstring(&b, "\n\t(...tail calls...)");
    .          .          .          .               }
    .          .          .          .             }
    2 ( 0.00%) .          .          .             luaL_pushresult(&b);
3,848 ( 0.02%) 2 ( 0.37%) 28,054 ( 0.01%) 27,179 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_pushresult (1x)
   11 ( 0.00%) .          .          .           }
    .          .          .          .           
   11 ( 0.00%) .          .          .           LUALIB_API int luaL_argerror (lua_State *L, int arg, const char *extramsg) {
   20 ( 0.00%) .          .          .             lua_Debug ar = {0};
    6 ( 0.00%) .          .          .             if (!lua_getstack(L, 0, &ar))  
   49 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_getstack (1x)
    .          .          .          .               return luaL_error(L, "bad argument #%d (%s)", arg, extramsg);
    4 ( 0.00%) .          .          .             lua_getinfo(L, "Snf", &ar);
5,297 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_getinfo (1x)
    .          .          .          .           
    2 ( 0.00%) .          .          .           	if (ar.name == NULL) {
    .          .          .          .           		pushfuncname(L, &ar);
    .          .          .          .               ar.name = lua_tostring(L, -1);
    .          .          .          .           	}
    3 ( 0.00%) .          .          .           	lua_pop(L, 1); // pop function
   91 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop (1x)
    .          .          .          .           
    9 ( 0.00%) .          .          .             if (strcmp(ar.namewhat, "method") == 0) {
   43 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strcmp-sse4_2.S:__strcmp_sse42 (1x)
    .          .          .          .               arg--;  
    .          .          .          .               if (arg == 0)  
    .          .          .          .                 return luaL_error(L, "calling '%s' on bad self (%s)", ar.name, extramsg);
    .          .          .          .             }
    7 ( 0.00%) .          .          .             return luaL_error(L, "bad argument #%d to '%s' (%s)", arg, ar.name, extramsg);
98,786 ( 0.46%) 31 ( 5.81%) 578,926 ( 0.11%) 556,494 ( 0.11%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_error (1x)
    .          .          .          .           }
    .          .          .          .           
    6 ( 0.00%) .          .          .           LUALIB_API int luaL_typeerror (lua_State *L, int arg, const char *tname) {
    .          .          .          .             const char *msg;
    .          .          .          .             const char *typearg;  
    4 ( 0.00%) .          .          .             if (luaL_getmetafield(L, arg, "__name") == LUA_TSTRING)
  149 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_getmetafield (1x)
    .          .          .          .               typearg = lua_tostring(L, -1);  
    5 ( 0.00%) .          .          .             else if (lua_type(L, arg) == LUA_TLIGHTUSERDATA)
  121 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_type (1x)
    .          .          .          .               typearg = "light userdata";  
    .          .          .          .             else
    8 ( 0.00%) .          .          .               typearg = luaL_typename(L, arg);  
  121 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_type (1x)
   30 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_typename (1x)
    6 ( 0.00%) .          .          .             msg = lua_pushfstring(L, "%s expected, got %s", tname, typearg);
2,698 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushfstring (1x)
    3 ( 0.00%) .          .          .             return luaL_argerror(L, arg, msg);
104,328 ( 0.48%) 31 ( 5.81%) 578,926 ( 0.11%) 556,494 ( 0.11%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_argerror (1x)
    .          .          .          .           }
    .          .          .          .           
    6 ( 0.00%) .          .          .           static void tag_error (lua_State *L, int arg, int tag) {
    5 ( 0.00%) .          .          .             luaL_typeerror(L, arg, lua_typename(L, tag));
107,479 ( 0.50%) 31 ( 5.81%) 578,926 ( 0.11%) 556,494 ( 0.11%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_typeerror (1x)
   30 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_typename (1x)
    .          .          .          .           }
    .          .          .          .           
    6 ( 0.00%) .          .          .           LUALIB_API void luaL_where (lua_State *L, int level) {
    .          .          .          .             lua_Debug ar;
    4 ( 0.00%) .          .          .             if (lua_getstack(L, level, &ar)) {  
   74 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_getstack (1x)
    4 ( 0.00%) .          .          .               lua_getinfo(L, "Sl", &ar);  
1,884 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_getinfo (1x)
    3 ( 0.00%) .          .          .               if (ar.currentline > 0) {  
    5 ( 0.00%) .          .          .                 lua_pushfstring(L, "%s:%d: ", ar.short_src, ar.currentline);
2,635 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushfstring (1x)
    1 ( 0.00%) .          .          .                 return;
    .          .          .          .               }
    .          .          .          .             	lua_pushfstring(L, "%s: ", ar.what);  
    .          .          .          .           		return;
    .          .          .          .             }
    .          .          .          .             lua_pushfstring(L, "");  
    6 ( 0.00%) .          .          .           }
    .          .          .          .           
   14 ( 0.00%) .          .          .           LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
    .          .          .          .             va_list argp;
    6 ( 0.00%) .          .          .             va_start(argp, fmt);
    3 ( 0.00%) .          .          .             luaL_where(L, 1);
4,622 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_where (1x)
    4 ( 0.00%) .          .          .             lua_pushvfstring(L, fmt, argp);
2,549 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushvfstring (1x)
    .          .          .          .             va_end(argp);
    3 ( 0.00%) .          .          .             lua_concat(L, 2);
1,236 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_concat (1x)
    2 ( 0.00%) .          .          .             return lua_error(L);
90,347 ( 0.42%) 31 ( 5.81%) 578,926 ( 0.11%) 556,494 ( 0.11%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_error (1x)
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           LUALIB_API int luaL_fileresult (lua_State *L, int, const char*) {
    .          .          .          .           	luaL_error(L, "LuaL_fileresult is ABI deprecated!");
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           LUALIB_API int luaL_execresult (lua_State *L, int) {
    .          .          .          .           	luaL_error(L, "LuaL_execresult is ABI deprecated!");
-- line 179 ----------------------------------------
-- line 215 ----------------------------------------
    .          .          .          .           
    .          .          .          .           LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {
    .          .          .          .             void *p = luaL_testudata(L, ud, tname);
    .          .          .          .             luaL_argexpected(L, p != NULL, ud, tname);
    .          .          .          .             return p;
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           LUALIB_API int luaL_checkoption (lua_State *L, int arg, const char *def,
   10 ( 0.00%) .          .          .                                            const char *const lst[]) {
    5 ( 0.00%) .          .          .             const char *name = (def) ? luaL_optstring(L, arg, def) :
  292 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_optlstring (1x)
    .          .          .          .                                        luaL_checkstring(L, arg);
    .          .          .          .             int i;
   70 ( 0.00%) .          .          .             for (i=0; lst[i]; i++)
   68 ( 0.00%) .          .          .               if (strcmp(lst[i], name) == 0)
  125 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strcmp-sse4_2.S:__strcmp_sse42 (4x)
    .          .          .          .                 return i;
    .          .          .          .             return luaL_argerror(L, arg,
    .          .          .          .                                  lua_pushfstring(L, "invalid option '%s'", name));
    9 ( 0.00%) .          .          .           }
    .          .          .          .           
   40 ( 0.00%) .          .          .           LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *msg) {
   24 ( 0.00%) .          .          .             if (l_unlikely(!lua_checkstack(L, space))) {
  552 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_checkstack (8x)
    .          .          .          .               if (msg)
    .          .          .          .                 luaL_error(L, "stack overflow (%s)", msg);
    .          .          .          .               else
    .          .          .          .                 luaL_error(L, "stack overflow");
    .          .          .          .             }
   32 ( 0.00%) .          .          .           }
    .          .          .          .           
   36 ( 0.00%) .          .          .           LUALIB_API void luaL_checktype (lua_State *L, int arg, int t) {
   18 ( 0.00%) .          .          .             if (l_unlikely(lua_type(L, arg) != t))
  636 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_type (6x)
    4 ( 0.00%) .          .          .               tag_error(L, arg, t);
107,520 ( 0.50%) 31 ( 5.81%) 578,926 ( 0.11%) 556,494 ( 0.11%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:tag_error (1x)
   20 ( 0.00%) .          .          .           }
    .          .          .          .           
   25 ( 0.00%) .          .          .           LUALIB_API void luaL_checkany (lua_State *L, int arg) {
    5 ( 0.00%) .          .          .           	int t = lua_type(L, arg);
  515 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_type (5x)
   15 ( 0.00%) .          .          .             if (l_unlikely(t == LUA_TNONE || t == LUA_TNIL))
    .          .          .          .               luaL_argerror(L, arg, "value expected");
   20 ( 0.00%) .          .          .           }
    .          .          .          .           
   35 ( 0.00%) .          .          .           LUALIB_API const char *luaL_checklstring (lua_State *L, int arg, size_t *len) {
   14 ( 0.00%) .          .          .             const char *s = lua_tolstring(L, arg, len);
1,488 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_tolstring (7x)
   14 ( 0.00%) .          .          .             if (l_unlikely(!s)) tag_error(L, arg, LUA_TSTRING);
    .          .          .          .             return s;
   35 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           LUALIB_API const char *luaL_optlstring (lua_State *L, int arg,
   27 ( 0.00%) .          .          .                                                   const char *def, size_t *len) {
    9 ( 0.00%) .          .          .             if (lua_isnoneornil(L, arg)) {
  332 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_type (3x)
    2 ( 0.00%) .          .          .               if (len)
    .          .          .          .                 *len = (def ? strlen(def) : 0);
    1 ( 0.00%) .          .          .               return def;
    .          .          .          .             }
   10 ( 0.00%) .          .          .             else return luaL_checklstring(L, arg, len);
  332 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_checklstring (2x)
   18 ( 0.00%) .          .          .           }
    .          .          .          .           
   36 ( 0.00%) .          .          .           LUALIB_API lua_Number luaL_checknumber (lua_State *L, int arg) {
    .          .          .          .             int isnum;
   12 ( 0.00%) .          .          .             lua_Number d = lua_tonumberx(L, arg, &isnum);
  480 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_tonumberx (4x)
    8 ( 0.00%) .          .          .             if (l_unlikely(!isnum))
    .          .          .          .               tag_error(L, arg, LUA_TNUMBER);
    .          .          .          .             return d;
   36 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           LUALIB_API lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number def) {
    .          .          .          .             return luaL_opt(L, luaL_checknumber, arg, def);
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           static void interror (lua_State *L, int arg) {
    .          .          .          .             if (lua_isnumber(L, arg))
    .          .          .          .               luaL_argerror(L, arg, "number has no integer representation");
    .          .          .          .             else
    .          .          .          .               tag_error(L, arg, LUA_TNUMBER);
    .          .          .          .           }
    .          .          .          .           
   18 ( 0.00%) .          .          .           LUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int arg) {
    .          .          .          .             int isnum;
    6 ( 0.00%) .          .          .             lua_Integer d = lua_tointegerx(L, arg, &isnum);
  250 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_tointegerx (2x)
    4 ( 0.00%) .          .          .             if (l_unlikely(!isnum)) {
    .          .          .          .               interror(L, arg);
    .          .          .          .             }
    .          .          .          .             return d;
   18 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           LUALIB_API lua_Integer luaL_optinteger (lua_State *L, int arg,
    .          .          .          .                                                                 lua_Integer def) {
    .          .          .          .             return luaL_opt(L, luaL_checkinteger, arg, def);
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           #define freelist	(LUA_RIDX_LAST + 1)
    .          .          .          .           
-- line 304 ----------------------------------------
-- line 361 ----------------------------------------
    .          .          .          .             ls.size = size;
    .          .          .          .             return lua_load(L, getS, &ls, name, mode);
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           LUALIB_API int luaL_loadstring (lua_State *L, const char *s) {
    .          .          .          .             return luaL_loadbuffer(L, s, strlen(s), s);
    .          .          .          .           }
    .          .          .          .           
   50 ( 0.00%) .          .          .           LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
   40 ( 0.00%) .          .          .             if (!lua_getmetatable(L, obj))  
2,574 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_getmetatable (10x)
    .          .          .          .               return LUA_TNIL;
    .          .          .          .             else {
    .          .          .          .               int tt;
   27 ( 0.00%) .          .          .               lua_pushstring(L, event);
3,864 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushstring (9x)
   36 ( 0.00%) .          .          .               tt = lua_rawget(L, -2);
4,761 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_rawget (9x)
   18 ( 0.00%) .          .          .               if (tt == LUA_TNIL)  
   36 ( 0.00%) .          .          .                 lua_pop(L, 2);  
  819 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop (9x)
    .          .          .          .               else
    .          .          .          .                 lua_remove(L, -2);  
    .          .          .          .               return tt;  
    .          .          .          .             }
   50 ( 0.00%) .          .          .           }
    .          .          .          .           
   45 ( 0.00%) .          .          .           LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
   18 ( 0.00%) .          .          .             obj = lua_absindex(L, obj);
  108 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_absindex (9x)
   54 ( 0.00%) .          .          .             if (luaL_getmetafield(L, obj, event) == LUA_TNIL)  
12,126 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_getmetafield (9x)
    .          .          .          .               return 0;
    .          .          .          .             lua_pushvalue(L, obj);
    .          .          .          .             lua_call(L, 1, 1);
    .          .          .          .             return 1;
   36 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           LUALIB_API lua_Integer luaL_len (lua_State *L, int idx) {
    .          .          .          .             lua_Integer l;
    .          .          .          .             int isnum;
    .          .          .          .             lua_len(L, idx);
    .          .          .          .             l = lua_tointegerx(L, -1, &isnum);
    .          .          .          .             if (l_unlikely(!isnum))
    .          .          .          .               luaL_error(L, "object length is not an integer");
    .          .          .          .             lua_pop(L, 1);  
    .          .          .          .             return l;
    .          .          .          .           }
    .          .          .          .           
   63 ( 0.00%) .          .          .           LUALIB_API const char *luaL_tolstring (lua_State *L, int idx, size_t *len) {
   18 ( 0.00%) .          .          .             idx = lua_absindex(L,idx);
  108 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_absindex (9x)
   54 ( 0.00%) .          .          .             if (luaL_callmeta(L, idx, "__tostring")) {  
12,387 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_callmeta (9x)
    .          .          .          .               if (!lua_isstring(L, -1))
    .          .          .          .                 luaL_error(L, "'__tostring' must return a string");
    .          .          .          .             }
    .          .          .          .             else {
   72 ( 0.00%) .          .          .               switch (lua_type(L, idx)) {
  927 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_type (9x)
    .          .          .          .                 case LUA_TNUMBER: {
    .          .          .          .                   if (lua_isinteger(L, idx))
    .          .          .          .                     lua_pushfstring(L, "%I", (LUAI_UACINT)lua_tointeger(L, idx));
    .          .          .          .                   else
    .          .          .          .                     lua_pushfstring(L, "%f", (LUAI_UACNUMBER)lua_tonumber(L, idx));
    .          .          .          .                   break;
    .          .          .          .                 }
    .          .          .          .                 case LUA_TSTRING:
   27 ( 0.00%) .          .          .                   lua_pushvalue(L, idx);
2,151 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushvalue (9x)
    9 ( 0.00%) .          .          .                   break;
    .          .          .          .                 case LUA_TBOOLEAN:
    .          .          .          .                   lua_pushstring(L, (lua_toboolean(L, idx) ? "true" : "false"));
    .          .          .          .                   break;
    .          .          .          .                 case LUA_TNIL:
    .          .          .          .                   lua_pushliteral(L, "nil");
    .          .          .          .                   break;
    .          .          .          .                 default: {
    .          .          .          .                   int tt = luaL_getmetafield(L, idx, "__name");  
-- line 429 ----------------------------------------
-- line 431 ----------------------------------------
    .          .          .          .                                                            luaL_typename(L, idx);
    .          .          .          .                   lua_pushfstring(L, "%s (%p)", kind, lua_topointer(L, idx));
    .          .          .          .                   if (tt != LUA_TNIL)
    .          .          .          .                     lua_remove(L, -2);  
    .          .          .          .                   break;
    .          .          .          .                 }
    .          .          .          .               }
    .          .          .          .             }
   36 ( 0.00%) .          .          .             return lua_tolstring(L, -1, len);
2,087 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_tolstring (9x)
   54 ( 0.00%) .          .          .           }
    .          .          .          .           
   64 ( 0.00%) .          .          .           LUALIB_API void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup) {
   24 ( 0.00%) .          .          .             luaL_checkstack(L, nup, "too many upvalues");
  648 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_checkstack (8x)
1,032 ( 0.00%) .          .          .             for (; l->name != NULL; l++) {  
  880 ( 0.00%) .          .          .               if (l->func == NULL)  
   40 ( 0.00%) .          .          .                 lua_pushboolean(L, 0);
  650 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushboolean (10x)
    .          .          .          .               else {
    .          .          .          .                 int i;
  324 ( 0.00%) .          .          .                 for (i = 0; i < nup; i++)  
   12 ( 0.00%) .          .          .                   lua_pushvalue(L, -nup);
  468 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushvalue (2x)
  702 ( 0.00%) .          .          .                 lua_pushcclosure(L, l->func, nup);  
7,608 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushcclosure (78x)
    .          .          .          .               }
1,232 ( 0.01%) .          .          .               lua_setfield(L, -(nup + 2), l->name);
251,562 ( 1.16%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_setfield (88x)
    .          .          .          .             }
   32 ( 0.00%) .          .          .             lua_pop(L, nup);  
  686 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop (8x)
   48 ( 0.00%) .          .          .           }
    .          .          .          .           
   36 ( 0.00%) .          .          .           LUALIB_API int luaL_getsubtable (lua_State *L, int idx, const char *fname) {
   18 ( 0.00%) .          .          .             if (lua_getfield(L, idx, fname) == LUA_TTABLE)
5,323 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_getfield (6x)
    5 ( 0.00%) .          .          .               return 1;  
    .          .          .          .             else {
    3 ( 0.00%) .          .          .               lua_pop(L, 1);  
   91 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop (1x)
    4 ( 0.00%) .          .          .               idx = lua_absindex(L, idx);
   12 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_absindex (1x)
    4 ( 0.00%) .          .          .               lua_newtable(L);
14,167 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_createtable (1x)
    3 ( 0.00%) .          .          .               lua_pushvalue(L, -1);  
  234 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushvalue (1x)
    4 ( 0.00%) .          .          .               lua_setfield(L, idx, fname);  
4,684 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_setfield (1x)
    2 ( 0.00%) .          .          .               return 0;  
    .          .          .          .             }
   24 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           LUALIB_API void luaL_requiref (lua_State *L, const char *modname,
   54 ( 0.00%) .          .          .                                          lua_CFunction openf, int glb) {
   18 ( 0.00%) .          .          .             luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);
24,614 ( 0.11%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_getsubtable (6x)
   30 ( 0.00%) .          .          .           	lua_assert(lua_type(L, -1) == LUA_TTABLE);
  588 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_type (6x)
   24 ( 0.00%) .          .          .             lua_getfield(L, -1, modname);  
9,538 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_getfield (6x)
   30 ( 0.00%) .          .          .             if (!lua_toboolean(L, -1)) {  
  588 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_toboolean (6x)
   18 ( 0.00%) .          .          .               lua_pop(L, 1);  
  546 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop (6x)
   24 ( 0.00%) .          .          .               lua_pushcfunction(L, openf);
  480 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushcclosure (6x)
   18 ( 0.00%) .          .          .               lua_pushstring(L, modname);  
2,093 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushstring (6x)
   36 ( 0.00%) .          .          .               lua_call(L, 1, 1);  
354,829 ( 1.64%) 13 ( 2.43%) 386,380 ( 0.07%) 363,695 ( 0.07%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_callk (6x)
   18 ( 0.00%) .          .          .               lua_pushvalue(L, -1);  
1,404 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushvalue (6x)
   30 ( 0.00%) .          .          .               lua_setfield(L, -3, modname);  
26,631 ( 0.12%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_setfield (6x)
    .          .          .          .             }
   42 ( 0.00%) .          .          .             lua_remove(L, -2);  
3,024 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_rotate (6x)
  546 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop (6x)
   12 ( 0.00%) .          .          .             if (glb) {
   18 ( 0.00%) .          .          .               lua_pushvalue(L, -1);  
1,404 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushvalue (6x)
   18 ( 0.00%) .          .          .               lua_setglobal(L, modname);  
8,933 ( 0.04%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_setglobal (6x)
    .          .          .          .             }
   42 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           LUALIB_API const char *luaL_gsub (lua_State *L, const char *s,
    .          .          .          .                                             const char *p, const char *r) {
    .          .          .          .             luaL_Buffer b;
    .          .          .          .             luaL_buffinit(L, &b);
    .          .          .          .             luaL_addgsub(&b, s, p, r);
    .          .          .          .             luaL_pushresult(&b);
    .          .          .          .             return lua_tostring(L, -1);
    .          .          .          .           }
    .          .          .          .           
5,016 ( 0.02%) .          .          .           static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
    .          .          .          .             (void)ud; (void)osize;  
6,315 ( 0.03%) .          .          .             if (nsize == 0) {
2,422 ( 0.01%) .          .          .               free(ptr);
107,427 ( 0.50%) .          .          .           => /usr/src/debug/glibc/glibc/malloc/malloc.c:free (1,209x)
  695 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
2,418 ( 0.01%) .          .          .               return NULL;
    .          .          .          .             }
    .          .          .          .             else
2,602 ( 0.01%) .          .          .               return realloc(ptr, nsize);
241,415 ( 1.11%) 1 ( 0.19%) 26,259 ( 0.00%) 24,752 ( 0.01%)  => /usr/src/debug/glibc/glibc/malloc/malloc.c:realloc (1,299x)
  704 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
5,016 ( 0.02%) .          .          .           }
    .          .          .          .           
    .          .          .          .           static int panic (lua_State *) {
    .          .          .          .           	lua_writestringerror("Unprotected call to Lua API! %s\n", "aborting");
    .          .          .          .             return 0;  
    .          .          .          .           }
    .          .          .          .           
    1 ( 0.00%) .          .          .           LUALIB_API lua_State *luaL_newstate (void) {
    4 ( 0.00%) .          .          .             lua_State *L = lua_newstate(l_alloc, NULL);
71,047 ( 0.33%) 1 ( 0.19%) 6,806 ( 0.00%) 4,726 ( 0.00%)  => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_newstate (1x)
    2 ( 0.00%) .          .          .             if (l_likely(L)) {
    3 ( 0.00%) .          .          .               lua_atpanic(L, &panic);
   39 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_atpanic (1x)
    .          .          .          .             }
    .          .          .          .             return L;
    3 ( 0.00%) .          .          .           }
    .          .          .          .           
   30 ( 0.00%) .          .          .           LUALIB_API void luaL_checkversion_ (lua_State *L, lua_Number ver, size_t sz) {
    5 ( 0.00%) .          .          .             lua_Number v = lua_version(L);
   10 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_version (5x)
   15 ( 0.00%) .          .          .             if (sz != LUAL_NUMSIZES)  
    .          .          .          .               luaL_error(L, "core and library have incompatible numeric types");
   20 ( 0.00%) .          .          .             else if (v != ver)
    .          .          .          .               luaL_error(L, "version mismatch: app. needs %f, Lua core provides %f",
    .          .          .          .                             (LUAI_UACNUMBER)ver, (LUAI_UACNUMBER)v);
   20 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           // root include ./lualib/lbaselib.c
    .          .          .          .           
    .          .          .          .           #include <ctype.h>
    .          .          .          .           //included "stdio.h" 
    .          .          .          .           //included "stdlib.h" 
    .          .          .          .           //included "string.h" 
    .          .          .          .           
    .          .          .          .           //included "lualib.h" 
    .          .          .          .           
   77 ( 0.00%) .          .          .           static int luaB_print (lua_State *L) {
   14 ( 0.00%) .          .          .             int n = lua_gettop(L);  
  252 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_gettop (7x)
    .          .          .          .             int i;
   70 ( 0.00%) .          .          .             for (i = 1; i <= n; i++) {  
    .          .          .          .               size_t l;
   35 ( 0.00%) .          .          .               const char *s = luaL_tolstring(L, i, &l);  
14,195 ( 0.07%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_tolstring (7x)
   21 ( 0.00%) .          .          .               if (i > 1)  
    .          .          .          .                 lua_writestring(" ", 1);  
   88 ( 0.00%) .          .          .               lua_writestring(s, l);  
6,022 ( 0.03%) 6 ( 1.12%) 95,483 ( 0.02%) 90,977 ( 0.02%)  => /usr/src/debug/glibc/glibc/libio/iofwrite.c:fwrite (7x)
  751 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
   21 ( 0.00%) .          .          .               lua_pop(L, 1);  
  637 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop (7x)
    .          .          .          .             }
   88 ( 0.00%) .          .          .             lua_writeline();
2,128 ( 0.01%) 7 ( 1.31%) 123,193 ( 0.02%) 118,085 ( 0.02%)  => /usr/src/debug/glibc/glibc/libio/iofwrite.c:fwrite (7x)
  758 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
  441 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/libio/iofflush.c:fflush (7x)
    .          .          .          .             return 0;
   84 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           static int luaB_warn (lua_State *L) {
    .          .          .          .             int n = lua_gettop(L);  
    .          .          .          .             int i;
    .          .          .          .             luaL_checkstring(L, 1);  
    .          .          .          .             for (i = 2; i <= n; i++)
    .          .          .          .               luaL_checkstring(L, i);  
    .          .          .          .             for (i = 1; i < n; i++)  
-- line 562 ----------------------------------------
-- line 607 ----------------------------------------
    .          .          .          .           
    .          .          .          .           static int luaB_rawlen (lua_State *L) {
    .          .          .          .             int t = lua_type(L, 1);
    .          .          .          .             luaL_argexpected(L, t == LUA_TTABLE || t == LUA_TSTRING, 1, "table or string");
    .          .          .          .             lua_pushinteger(L, lua_rawlen(L, 1));
    .          .          .          .             return 1;
    .          .          .          .           }
    .          .          .          .           
   10 ( 0.00%) .          .          .           static int luaB_rawget (lua_State *L) {
   15 ( 0.00%) .          .          .             luaL_checktype(L, 1, LUA_TTABLE);
  580 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_checktype (5x)
   15 ( 0.00%) .          .          .             luaL_checkany(L, 2);
  580 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_checkany (5x)
   15 ( 0.00%) .          .          .             lua_settop(L, 2);
  495 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop (5x)
   15 ( 0.00%) .          .          .             lua_rawget(L, 1);
2,434 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_rawget (5x)
    .          .          .          .             return 1;
   15 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           static int luaB_rawset (lua_State *L) {
    .          .          .          .             luaL_checktype(L, 1, LUA_TTABLE);
    .          .          .          .             luaL_checkany(L, 2);
    .          .          .          .             luaL_checkany(L, 3);
    .          .          .          .             lua_settop(L, 3);
    .          .          .          .             lua_rawset(L, 1);
    .          .          .          .             return 1;
-- line 629 ----------------------------------------
-- line 635 ----------------------------------------
    .          .          .          .             else
    .          .          .          .               lua_pushstring(L, (oldmode == LUA_GCINC) ? "incremental"
    .          .          .          .                                                        : "generational");
    .          .          .          .             return 1;
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           #define checkvalres(res) { if (res == -1) break; }
    .          .          .          .           
    6 ( 0.00%) .          .          .           static int luaB_collectgarbage (lua_State *L) {
    .          .          .          .             static const char *const opts[] = {"stop", "restart", "collect",
    .          .          .          .               "count", "step", "setpause", "setstepmul",
    .          .          .          .               "isrunning", "generational", "incremental", NULL};
    .          .          .          .             static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
    .          .          .          .               LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL,
    .          .          .          .               LUA_GCISRUNNING, LUA_GCGEN, LUA_GCINC};
   26 ( 0.00%) .          .          .             int o = optsnum[luaL_checkoption(L, 1, "collect", opts)];
  579 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_checkoption (1x)
    8 ( 0.00%) .          .          .             switch (o) {
    .          .          .          .               case LUA_GCCOUNT: {
    5 ( 0.00%) .          .          .                 int k = lua_gc(L, o);
   75 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_gc (1x)
    4 ( 0.00%) .          .          .                 int b = lua_gc(L, LUA_GCCOUNTB);
   72 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_gc (1x)
    2 ( 0.00%) .          .          .                 checkvalres(k);
    8 ( 0.00%) .          .          .                 lua_pushnumber(L, (lua_Number)k + ((lua_Number)b/1024));
   69 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushnumber (1x)
    2 ( 0.00%) .          .          .                 return 1;
    .          .          .          .               }
    .          .          .          .               case LUA_GCSTEP: {
    .          .          .          .                 int step = (int)luaL_optinteger(L, 2, 0);
    .          .          .          .                 int res = lua_gc(L, o, step);
    .          .          .          .                 checkvalres(res);
    .          .          .          .                 lua_pushboolean(L, res);
    .          .          .          .                 return 1;
    .          .          .          .               }
-- line 665 ----------------------------------------
-- line 692 ----------------------------------------
    .          .          .          .                 int res = lua_gc(L, o);
    .          .          .          .                 checkvalres(res);
    .          .          .          .                 lua_pushinteger(L, res);
    .          .          .          .                 return 1;
    .          .          .          .               }
    .          .          .          .             }
    .          .          .          .             luaL_pushfail(L);  
    .          .          .          .             return 1;
    6 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           static int luaB_type (lua_State *L) {
    .          .          .          .             int t = lua_type(L, 1);
    .          .          .          .             luaL_argcheck(L, t != LUA_TNONE, 1, "value expected");
    .          .          .          .             lua_pushstring(L, lua_typename(L, t));
    .          .          .          .             return 1;
    .          .          .          .           }
    .          .          .          .           
-- line 708 ----------------------------------------
-- line 799 ----------------------------------------
    .          .          .          .               const char *chunkname = luaL_optstring(L, 2, "=(load)");
    .          .          .          .               luaL_checktype(L, 1, LUA_TFUNCTION);
    .          .          .          .               lua_settop(L, RESERVEDSLOT);  
    .          .          .          .               status = lua_load(L, generic_reader, NULL, chunkname, mode);
    .          .          .          .             }
    .          .          .          .             return load_aux(L, status, env);
    .          .          .          .           }
    .          .          .          .           
    4 ( 0.00%) .          .          .           static int luaB_assert (lua_State *L) {
    8 ( 0.00%) .          .          .             if (l_likely(lua_toboolean(L, 1)))  
  206 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_toboolean (2x)
   12 ( 0.00%) .          .          .               return lua_gettop(L)-1;  
   72 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_gettop (2x)
    .          .          .          .             else {  
    .          .          .          .               luaL_checkany(L, 1);  
    .          .          .          .               lua_remove(L, 1);  
    .          .          .          .               lua_pushliteral(L, "assertion failed!");  
    .          .          .          .               lua_settop(L, 1);  
    .          .          .          .               return luaB_error(L);  
    .          .          .          .             }
    4 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           static int luaB_select (lua_State *L) {
    .          .          .          .             int n = lua_gettop(L);
    .          .          .          .             if (lua_type(L, 1) == LUA_TSTRING && *lua_tostring(L, 1) == '#') {
    .          .          .          .               lua_pushinteger(L, n-1);
    .          .          .          .               return 1;
    .          .          .          .             }
    .          .          .          .             else {
-- line 825 ----------------------------------------
-- line 889 ----------------------------------------
    .          .          .          .             {"type", luaB_type},
    .          .          .          .             {"xpcall", luaB_xpcall},
    .          .          .          .             
    .          .          .          .             {LUA_GNAME, NULL},
    .          .          .          .             {"_VERSION", NULL},
    .          .          .          .             {NULL, NULL}
    .          .          .          .           };
    .          .          .          .           
    2 ( 0.00%) .          .          .           LUAMOD_API int luaopen_base (lua_State *L) {
    .          .          .          .             
    3 ( 0.00%) .          .          .             lua_pushglobaltable(L);
  328 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_rawgeti (1x)
    4 ( 0.00%) .          .          .             luaL_setfuncs(L, base_funcs, 0);
103,169 ( 0.48%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_setfuncs (1x)
    .          .          .          .             
    3 ( 0.00%) .          .          .             lua_pushvalue(L, -1);
  234 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushvalue (1x)
    4 ( 0.00%) .          .          .             lua_setfield(L, -2, LUA_GNAME);
  822 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_setfield (1x)
    .          .          .          .             
    3 ( 0.00%) .          .          .             lua_pushliteral(L, LUA_VERSION);
1,166 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushstring (1x)
    4 ( 0.00%) .          .          .             lua_setfield(L, -2, "_VERSION");
  701 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_setfield (1x)
    .          .          .          .             return 1;
    3 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           // root include ./lualib/lcorolib.c
    .          .          .          .           
    .          .          .          .           //included "stdlib.h" 
    .          .          .          .           
    .          .          .          .           static lua_State *getco (lua_State *L) {
    .          .          .          .             lua_State *co = lua_tothread(L, 1);
    .          .          .          .             luaL_argexpected(L, co, 1, "thread");
-- line 916 ----------------------------------------
-- line 1071 ----------------------------------------
    .          .          .          .             {"status", luaB_costatus},
    .          .          .          .             {"wrap", luaB_cowrap},
    .          .          .          .             {"yield", luaB_yield},
    .          .          .          .             {"isyieldable", luaB_yieldable},
    .          .          .          .             {"close", luaB_close},
    .          .          .          .             {NULL, NULL}
    .          .          .          .           };
    .          .          .          .           
    2 ( 0.00%) .          .          .           LUAMOD_API int luaopen_coroutine (lua_State *L) {
   11 ( 0.00%) .          .          .             luaL_newlib(L, co_funcs);
18,899 ( 0.09%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_setfuncs (1x)
1,457 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_createtable (1x)
   20 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_checkversion_ (1x)
    .          .          .          .             return 1;
    3 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           // root include ./lualib/ldblib.c
    .          .          .          .           
    .          .          .          .           //included "stdio.h" 
    .          .          .          .           //included "stdlib.h" 
    .          .          .          .           //included "string.h" 
    .          .          .          .           
    .          .          .          .           static const char *const HOOKKEY = "_HOOKKEY";
-- line 1090 ----------------------------------------
-- line 1605 ----------------------------------------
    .          .          .          .           #endif
    .          .          .          .           
    .          .          .          .           #endif
    .          .          .          .           
    .          .          .          .           #if defined(Rand64)  
    .          .          .          .           
    .          .          .          .           #define trim64(x)	((x) & 0xffffffffffffffffu)
    .          .          .          .           
  320 ( 0.00%) .          .          .           static Rand64 rotl (Rand64 x, int n) {
  960 ( 0.00%) .          .          .             return (x << n) | (trim64(x) >> (64 - n));
  256 ( 0.00%) .          .          .           }
    .          .          .          .           
  256 ( 0.00%) .          .          .           static Rand64 nextrand (Rand64 *state) {
  160 ( 0.00%) .          .          .             Rand64 state0 = state[0];
  256 ( 0.00%) .          .          .             Rand64 state1 = state[1];
  352 ( 0.00%) .          .          .             Rand64 state2 = state[2] ^ state0;
  352 ( 0.00%) .          .          .             Rand64 state3 = state[3] ^ state1;
  160 ( 0.00%) .          .          .             Rand64 res = rotl(state1 * 5, 7) * 9;
  768 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:rotl (32x)
  224 ( 0.00%) .          .          .             state[0] = state0 ^ state3;
  224 ( 0.00%) .          .          .             state[1] = state1 ^ state2;
  256 ( 0.00%) .          .          .             state[2] = state2 ^ (state1 << 17);
  288 ( 0.00%) .          .          .             state[3] = rotl(state3, 45);
  768 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:rotl (32x)
    .          .          .          .             return res;
  288 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           #define shift64_FIG	(64 - FIGS)
    .          .          .          .           
    .          .          .          .           #define scaleFIG	(l_mathop(0.5) / ((Rand64)1 << (FIGS - 1)))
    .          .          .          .           
    .          .          .          .           static lua_Number I2d (Rand64 x) {
    .          .          .          .             return (lua_Number)(trim64(x) >> shift64_FIG) * scaleFIG;
    .          .          .          .           }
-- line 1636 ----------------------------------------
-- line 1806 ----------------------------------------
    .          .          .          .             luaL_argcheck(L, low <= up, 1, "interval is empty");
    .          .          .          .             
    .          .          .          .             p = project(I2UInt(rv), (lua_Unsigned)up - (lua_Unsigned)low, state);
    .          .          .          .             lua_pushinteger(L, p + (lua_Unsigned)low);
    .          .          .          .             return 1;
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           static void setseed (lua_State *L, Rand64 *state,
   22 ( 0.00%) .          .          .                                lua_Unsigned n1, lua_Unsigned n2) {
    .          .          .          .             int i;
   10 ( 0.00%) .          .          .             state[0] = Int2I(n1);
   18 ( 0.00%) .          .          .             state[1] = Int2I(0xff);  
   18 ( 0.00%) .          .          .             state[2] = Int2I(n2);
   18 ( 0.00%) .          .          .             state[3] = Int2I(0);
  200 ( 0.00%) .          .          .             for (i = 0; i < 16; i++)
   64 ( 0.00%) .          .          .               nextrand(state);  
4,352 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:nextrand (32x)
    6 ( 0.00%) .          .          .             lua_pushinteger(L, n1);
  138 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushinteger (2x)
    6 ( 0.00%) .          .          .             lua_pushinteger(L, n2);
  138 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushinteger (2x)
   16 ( 0.00%) .          .          .           }
    .          .          .          .           
   10 ( 0.00%) .          .          .           static void randseed (lua_State *L, RanState *state) {
    8 ( 0.00%) .          .          .             lua_Unsigned seed1 = (lua_Unsigned)time(NULL);
   12 ( 0.00%) 2 ( 0.37%) 11,983 ( 0.00%) 8,951 ( 0.00%)  => /usr/src/debug/glibc/glibc/time/../sysdeps/unix/sysv/linux/time.c:time_syscall (2x)
    .          .          .          .             lua_Unsigned seed2 = (lua_Unsigned)(size_t)L;
   18 ( 0.00%) .          .          .             setseed(L, state->s, seed1, seed2);
5,006 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:setseed (2x)
    8 ( 0.00%) .          .          .           }
    .          .          .          .           
    6 ( 0.00%) .          .          .           static int math_randomseed (lua_State *L) {
    3 ( 0.00%) .          .          .             RanState *state = (RanState *)lua_touserdata(L, lua_upvalueindex(1));
  210 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_touserdata (1x)
    5 ( 0.00%) .          .          .             if (lua_isnone(L, 1)) {
  126 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_type (1x)
    4 ( 0.00%) .          .          .               randseed(L, state);
2,531 ( 0.01%) 1 ( 0.19%) 5,839 ( 0.00%) 4,458 ( 0.00%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:randseed (1x)
    .          .          .          .             }
    .          .          .          .             else {
    .          .          .          .               lua_Integer n1 = luaL_checkinteger(L, 1);
    .          .          .          .               lua_Integer n2 = luaL_optinteger(L, 2, 0);
    .          .          .          .               setseed(L, state->s, n1, n2);
    .          .          .          .             }
    .          .          .          .             return 2;  
    7 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           static const luaL_Reg randfuncs[] = {
    .          .          .          .             {"random", math_random},
    .          .          .          .             {"randomseed", math_randomseed},
    .          .          .          .             {NULL, NULL}
    .          .          .          .           };
    .          .          .          .           
    2 ( 0.00%) .          .          .           static void setrandfunc (lua_State *L) {
    4 ( 0.00%) .          .          .             RanState *state = (RanState *)lua_newuserdatauv(L, sizeof(RanState), 0);
33,561 ( 0.15%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_newuserdatauv (1x)
    2 ( 0.00%) .          .          .             randseed(L, state);  
2,531 ( 0.01%) 1 ( 0.19%) 6,144 ( 0.00%) 4,493 ( 0.00%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:randseed (1x)
    3 ( 0.00%) .          .          .             lua_pop(L, 2);  
   91 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop (1x)
    4 ( 0.00%) .          .          .             luaL_setfuncs(L, randfuncs, 1);
3,860 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_setfuncs (1x)
    2 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           #if defined(LUA_COMPAT_MATHLIB)
    .          .          .          .           
    .          .          .          .           static int math_cosh (lua_State *L) {
    .          .          .          .             lua_pushnumber(L, l_mathop(cosh)(luaL_checknumber(L, 1)));
    .          .          .          .             return 1;
    .          .          .          .           }
    .          .          .          .           
-- line 1864 ----------------------------------------
-- line 1937 ----------------------------------------
    .          .          .          .             {"randomseed", NULL},
    .          .          .          .             {"pi", NULL},
    .          .          .          .             {"huge", NULL},
    .          .          .          .             {"maxinteger", NULL},
    .          .          .          .             {"mininteger", NULL},
    .          .          .          .             {NULL, NULL}
    .          .          .          .           };
    .          .          .          .           
    2 ( 0.00%) .          .          .           LUAMOD_API int luaopen_math (lua_State *L) {
   11 ( 0.00%) .          .          .             luaL_newlib(L, mathlib);
75,693 ( 0.35%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_setfuncs (1x)
2,588 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_createtable (1x)
   20 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_checkversion_ (1x)
    3 ( 0.00%) .          .          .             lua_pushnumber(L, PI);
   69 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushnumber (1x)
    4 ( 0.00%) .          .          .             lua_setfield(L, -2, "pi");
  706 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_setfield (1x)
    3 ( 0.00%) .          .          .             lua_pushnumber(L, (lua_Number)HUGE_VAL);
   69 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushnumber (1x)
    4 ( 0.00%) .          .          .             lua_setfield(L, -2, "huge");
  706 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_setfield (1x)
    3 ( 0.00%) .          .          .             lua_pushinteger(L, LUA_MAXINTEGER);
   69 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushinteger (1x)
    4 ( 0.00%) .          .          .             lua_setfield(L, -2, "maxinteger");
  706 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_setfield (1x)
    3 ( 0.00%) .          .          .             lua_pushinteger(L, LUA_MININTEGER);
   69 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushinteger (1x)
    4 ( 0.00%) .          .          .             lua_setfield(L, -2, "mininteger");
  720 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_setfield (1x)
    2 ( 0.00%) .          .          .             setrandfunc(L);
40,060 ( 0.18%) 1 ( 0.19%) 6,144 ( 0.00%) 4,493 ( 0.00%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:setrandfunc (1x)
    .          .          .          .             return 1;
    3 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           // root include ./lualib/lstrlib.c
    .          .          .          .           
    .          .          .          .           //included "ctype.h" 
    .          .          .          .           //included "float.h" 
    .          .          .          .           //included "limits.h" 
    .          .          .          .           //included "math.h" 
    .          .          .          .           
-- line 1965 ----------------------------------------
-- line 2122 ----------------------------------------
    .          .          .          .               state->init = 1;
    .          .          .          .               luaL_buffinit(L, &state->B);
    .          .          .          .             }
    .          .          .          .           	fprintf(stderr, "FUCK MORE > writing...\n");
    .          .          .          .             luaL_addlstring(&state->B, (const char *)b, size);
    .          .          .          .             return 0;
    .          .          .          .           }
    .          .          .          .           
    7 ( 0.00%) .          .          .           static int str_dump (lua_State *L) {
  136 ( 0.00%) .          .          .             struct str_Writer state = {0};
    4 ( 0.00%) .          .          .             int strip = lua_toboolean(L, 2);
  103 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_toboolean (1x)
    4 ( 0.00%) .          .          .             luaL_checktype(L, 1, LUA_TFUNCTION);
107,654 ( 0.50%) 31 ( 5.81%) 578,926 ( 0.11%) 556,494 ( 0.11%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_checktype (1x)
    .          .          .          .             lua_settop(L, 1);  
    .          .          .          .             state.init = 0;
    .          .          .          .             if (l_unlikely(lua_dump(L, writerbc, &state, strip) != 0))
    .          .          .          .               return luaL_error(L, "unable to dump given function");
    .          .          .          .             luaL_pushresult(&state.B);
    .          .          .          .             return 1;
    .          .          .          .           }
    .          .          .          .           
-- line 2141 ----------------------------------------
-- line 2880 ----------------------------------------
    .          .          .          .                 break;
    .          .          .          .               }
    .          .          .          .               default: {
    .          .          .          .                 luaL_argerror(L, arg, "value has no literal form");
    .          .          .          .               }
    .          .          .          .             }
    .          .          .          .           }
    .          .          .          .           
   48 ( 0.00%) .          .          .           static const char *get2digits (const char *s) {
  180 ( 0.00%) .          .          .             if (isdigit(uchar(*s))) {
  740 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
   32 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/ctype/../include/ctype.h:__ctype_b_loc (8x)
   10 ( 0.00%) .          .          .               s++;
   36 ( 0.00%) .          .          .               if (isdigit(uchar(*s))) s++;  
    .          .          .          .             }
    .          .          .          .             return s;
   56 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           static void checkformat (lua_State *L, const char *form, const char *flags,
   54 ( 0.00%) .          .          .                                                  int precision) {
   18 ( 0.00%) .          .          .             const char *spec = form + 1;  
   72 ( 0.00%) .          .          .             spec += strspn(spec, flags);  
  216 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strspn-sse4.c:__strspn_sse42 (6x)
   24 ( 0.00%) .          .          .             if (*spec != '0') {  
   18 ( 0.00%) .          .          .               spec = get2digits(spec);  
  978 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:get2digits (6x)
   28 ( 0.00%) .          .          .               if (*spec == '.' && precision) {
    8 ( 0.00%) .          .          .                 spec++;
    6 ( 0.00%) .          .          .                 spec = get2digits(spec);  
  124 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:get2digits (2x)
    .          .          .          .               }
    .          .          .          .             }
  132 ( 0.00%) .          .          .             if (!isalpha(uchar(*spec)))  
   24 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/ctype/../include/ctype.h:__ctype_b_loc (6x)
    .          .          .          .               luaL_error(L, "invalid conversion specification: '%s'", form);
   36 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           static const char *getformat (lua_State *L, const char *strfrmt,
   64 ( 0.00%) .          .          .                                                       char *form) {
    .          .          .          .             
   60 ( 0.00%) .          .          .             size_t len = strspn(strfrmt, L_FMTFLAGSF "123456789.");
  714 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
  296 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strspn-sse4.c:__strspn_sse42 (8x)
    8 ( 0.00%) .          .          .             len++;  
    .          .          .          .             
   16 ( 0.00%) .          .          .             if (len >= MAX_FORMAT - 10)
    .          .          .          .               luaL_error(L, "invalid format (too long)");
   56 ( 0.00%) .          .          .             *(form++) = '%';
   72 ( 0.00%) .          .          .             memcpy(form, strfrmt, len * sizeof(char));
  116 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:memcpy@GLIBC_2.2.5 (8x)
   64 ( 0.00%) .          .          .             *(form + len) = '\0';
   48 ( 0.00%) .          .          .             return strfrmt + len - 1;
   48 ( 0.00%) .          .          .           }
    .          .          .          .           
   54 ( 0.00%) .          .          .           static void addlenmod (char *form, const char *lenmod) {
   36 ( 0.00%) .          .          .             size_t l = strlen(form);
  102 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strlen-sse2.S:__strlen_sse2 (6x)
   36 ( 0.00%) .          .          .             size_t lm = strlen(lenmod);
  102 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strlen-sse2.S:__strlen_sse2 (6x)
   60 ( 0.00%) .          .          .             char spec = form[l - 1];
   82 ( 0.00%) .          .          .             strcpy(form + l - 1, lenmod);
  756 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
  124 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strcpy-sse2-unaligned.S:__strcpy_sse2_unaligned (6x)
   66 ( 0.00%) .          .          .             form[l + lm - 1] = spec;
   48 ( 0.00%) .          .          .             form[l + lm] = '\0';
   48 ( 0.00%) .          .          .           }
    .          .          .          .           
   55 ( 0.00%) .          .          .           static int str_format (lua_State *L) {
   10 ( 0.00%) .          .          .             int top = lua_gettop(L);
  180 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_gettop (5x)
    5 ( 0.00%) .          .          .             int arg = 1;
    .          .          .          .             size_t sfl;
   25 ( 0.00%) .          .          .             const char *strfrmt = luaL_checklstring(L, arg, &sfl);
1,254 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_checklstring (5x)
   35 ( 0.00%) .          .          .             const char *strfrmt_end = strfrmt+sfl;
    .          .          .          .             const char *flags;
    .          .          .          .             luaL_Buffer b;
   15 ( 0.00%) .          .          .             luaL_buffinit(L, &b);
6,945 ( 0.03%) 5 ( 0.94%) 81,271 ( 0.02%) 78,829 ( 0.02%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_buffinit (5x)
  169 ( 0.00%) .          .          .             while (strfrmt < strfrmt_end) {
  308 ( 0.00%) .          .          .               if (*strfrmt != L_ESC)
1,449 ( 0.01%) .          .          .                 luaL_addchar(&b, *strfrmt++);
   64 ( 0.00%) .          .          .               else if (*++strfrmt == L_ESC)
    .          .          .          .                 luaL_addchar(&b, *strfrmt++);  
    .          .          .          .               else { 
    .          .          .          .                 char form[MAX_FORMAT];  
    2 ( 0.00%) .          .          .                 int maxitem = MAX_ITEM;  
   32 ( 0.00%) .          .          .                 char *buff = luaL_prepbuffsize(&b, maxitem);  
32,584 ( 0.15%) 24 ( 4.49%) 346,121 ( 0.07%) 337,420 ( 0.07%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_prepbuffsize (8x)
    4 ( 0.00%) .          .          .                 int nb = 0;  
   48 ( 0.00%) .          .          .                 if (++arg > top)
    .          .          .          .                   return luaL_argerror(L, arg, "no value");
   40 ( 0.00%) .          .          .                 strfrmt = getformat(L, strfrmt, form);
1,562 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:getformat (8x)
  122 ( 0.00%) .          .          .                 switch (*strfrmt++) {
    .          .          .          .                   case 'c': {
    .          .          .          .                     checkformat(L, form, L_FMTFLAGSC, 0);
    .          .          .          .                     nb = l_sprintf(buff, maxitem, form, (int)luaL_checkinteger(L, arg));
    .          .          .          .                     break;
    .          .          .          .                   }
    .          .          .          .                   case 'd': case 'i':
    6 ( 0.00%) .          .          .                     flags = L_FMTFLAGSI;
    .          .          .          .                     goto intcase;
    .          .          .          .                   case 'u':
    .          .          .          .                     flags = L_FMTFLAGSU;
    .          .          .          .                     goto intcase;
    .          .          .          .                   case 'o': case 'x': case 'X':
    .          .          .          .                     flags = L_FMTFLAGSX;
    .          .          .          .                    intcase: {
    8 ( 0.00%) .          .          .                     lua_Integer n = luaL_checkinteger(L, arg);
  296 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_checkinteger (2x)
   12 ( 0.00%) .          .          .                     checkformat(L, form, flags, 1);
1,028 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:checkformat (2x)
    6 ( 0.00%) .          .          .                     addlenmod(form, LUA_INTEGER_FRMLEN);
1,014 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:addlenmod (2x)
   20 ( 0.00%) .          .          .                     nb = l_sprintf(buff, maxitem, form, (LUAI_UACINT)n);
1,174 ( 0.01%) .          .          .           => /usr/src/debug/glibc/glibc/stdio-common/snprintf.c:snprintf (2x)
  756 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_fxsave (1x)
    .          .          .          .                     break;
    .          .          .          .                   }
    .          .          .          .                   case 'a': case 'A':
    .          .          .          .                     checkformat(L, form, L_FMTFLAGSF, 1);
    .          .          .          .                     addlenmod(form, LUA_NUMBER_FRMLEN);
    .          .          .          .                     nb = lua_number2strx(L, buff, maxitem, form,
    .          .          .          .                                             luaL_checknumber(L, arg));
    .          .          .          .                     break;
    .          .          .          .                   case 'f':
    2 ( 0.00%) .          .          .                     maxitem = MAX_ITEMF;  
    8 ( 0.00%) .          .          .                     buff = luaL_prepbuffsize(&b, maxitem);
8,146 ( 0.04%) 6 ( 1.12%) 73,704 ( 0.01%) 72,227 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_prepbuffsize (2x)
    2 ( 0.00%) .          .          .           					goto ft_3f;
    .          .          .          .                   case 'e': case 'E': case 'g': case 'G': 
    .          .          .          .           				ft_3f : {
   16 ( 0.00%) .          .          .                     lua_Number n = luaL_checknumber(L, arg);
  572 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_checknumber (4x)
   24 ( 0.00%) .          .          .                     checkformat(L, form, L_FMTFLAGSF, 1);
  710 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:checkformat (4x)
   12 ( 0.00%) .          .          .                     addlenmod(form, LUA_NUMBER_FRMLEN);
  500 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:addlenmod (4x)
   32 ( 0.00%) .          .          .                     nb = l_sprintf(buff, maxitem, form, (LUAI_UACNUMBER)n);
6,712 ( 0.03%) .          .          .           => /usr/src/debug/glibc/glibc/stdio-common/snprintf.c:snprintf (4x)
    4 ( 0.00%) .          .          .                     break;
    .          .          .          .                   }
    .          .          .          .                   case 'p': {
    .          .          .          .                     const void *p = lua_topointer(L, arg);
    .          .          .          .                     checkformat(L, form, L_FMTFLAGSC, 0);
    .          .          .          .                     if (p == NULL) {  
    .          .          .          .                       p = "(null)";  
    .          .          .          .                       form[strlen(form) - 1] = 's';  
    .          .          .          .                     }
-- line 3001 ----------------------------------------
-- line 3005 ----------------------------------------
    .          .          .          .                   case 'q': {
    .          .          .          .                     if (form[2] != '\0')  
    .          .          .          .                       return luaL_error(L, "specifier '%%q' cannot have modifiers");
    .          .          .          .                     addliteral(L, &b, arg);
    .          .          .          .                     break;
    .          .          .          .                   }
    .          .          .          .                   case 's': {
    .          .          .          .                     size_t l;
   10 ( 0.00%) .          .          .                     const char *s = luaL_tolstring(L, arg, &l);
3,798 ( 0.02%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_tolstring (2x)
    4 ( 0.00%) .          .          .                     if (form[2] == '\0')  
    4 ( 0.00%) .          .          .                       luaL_addvalue(&b);  
8,880 ( 0.04%) 6 ( 1.12%) 92,478 ( 0.02%) 89,270 ( 0.02%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_addvalue (2x)
    .          .          .          .                     else {
    .          .          .          .                       luaL_argcheck(L, l == strlen(s), arg, "string contains zeros");
    .          .          .          .                       checkformat(L, form, L_FMTFLAGSC, 1);
    .          .          .          .                       if (strchr(form, '.') == NULL && l >= 100) {
    .          .          .          .                         
    .          .          .          .                         luaL_addvalue(&b);  
    .          .          .          .                       }
    .          .          .          .                       else {  
-- line 3023 ----------------------------------------
-- line 3026 ----------------------------------------
    .          .          .          .                       }
    .          .          .          .                     }
    .          .          .          .                     break;
    .          .          .          .                   }
    .          .          .          .                   default: {  
    .          .          .          .                     return luaL_error(L, "invalid conversion '%s' to 'format'", form);
    .          .          .          .                   }
    .          .          .          .                 }
   12 ( 0.00%) .          .          .                 lua_assert(nb < maxitem);
   24 ( 0.00%) .          .          .                 luaL_addsize(&b, nb);
    .          .          .          .               }
    .          .          .          .             }
   10 ( 0.00%) .          .          .             luaL_pushresult(&b);
21,806 ( 0.10%) 10 ( 1.87%) 172,262 ( 0.03%) 156,831 ( 0.03%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_pushresult (5x)
    5 ( 0.00%) .          .          .             return 1;
   55 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           static const luaL_Reg strlib[] = {
    .          .          .          .             {"byte", str_byte},
    .          .          .          .             {"char", str_char},
    .          .          .          .             {"dump", str_dump},
    .          .          .          .             {"find", str_find},
    .          .          .          .             {"format", str_format},
    .          .          .          .             {"gmatch", gmatch},
-- line 3048 ----------------------------------------
-- line 3053 ----------------------------------------
    .          .          .          .             {"rep", str_rep},
    .          .          .          .             {"reverse", str_reverse},
    .          .          .          .             {"sub", str_sub},
    .          .          .          .             {"upper", str_upper},
    .          .          .          .             
    .          .          .          .             {NULL, NULL}
    .          .          .          .           };
    .          .          .          .           
    2 ( 0.00%) .          .          .           static void createmetatable (lua_State *L) {
    .          .          .          .             
    3 ( 0.00%) .          .          .             luaL_newlibtable(L, stringmetamethods);
1,344 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_createtable (1x)
    4 ( 0.00%) .          .          .             luaL_setfuncs(L, stringmetamethods, 0);
1,949 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_setfuncs (1x)
    3 ( 0.00%) .          .          .             lua_pushliteral(L, "");  
1,045 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushstring (1x)
    3 ( 0.00%) .          .          .             lua_pushvalue(L, -2);  
  234 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushvalue (1x)
    3 ( 0.00%) .          .          .             lua_setmetatable(L, -2);  
  235 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_setmetatable (1x)
    3 ( 0.00%) .          .          .             lua_pop(L, 1);  
   91 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop (1x)
    3 ( 0.00%) .          .          .             lua_pushvalue(L, -2);  
  234 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushvalue (1x)
    4 ( 0.00%) .          .          .             lua_setfield(L, -2, "__index");  
  701 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_setfield (1x)
    3 ( 0.00%) .          .          .             lua_pop(L, 1);  
   91 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop (1x)
    2 ( 0.00%) .          .          .           }
    .          .          .          .           
    2 ( 0.00%) .          .          .           LUAMOD_API int luaopen_string (lua_State *L) {
   11 ( 0.00%) .          .          .             luaL_newlib(L, strlib);
32,991 ( 0.15%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_setfuncs (1x)
1,745 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_createtable (1x)
   20 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_checkversion_ (1x)
    2 ( 0.00%) .          .          .             createmetatable(L);
5,957 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:createmetatable (1x)
    .          .          .          .             return 1;
    3 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           // root include ./lualib/ltablib.c
    .          .          .          .           
    .          .          .          .           //included "limits.h" 
    .          .          .          .           //included "stddef.h" 
    .          .          .          .           //included "string.h" 
    .          .          .          .           
    .          .          .          .           #define TAB_R	1			
-- line 3086 ----------------------------------------
-- line 3391 ----------------------------------------
    .          .          .          .             {"pack", tpack},
    .          .          .          .             {"unpack", tunpack},
    .          .          .          .             {"remove", tremove},
    .          .          .          .             {"move", tmove},
    .          .          .          .             {"sort", sort},
    .          .          .          .             {NULL, NULL}
    .          .          .          .           };
    .          .          .          .           
    2 ( 0.00%) .          .          .           LUAMOD_API int luaopen_table (lua_State *L) {
   11 ( 0.00%) .          .          .             luaL_newlib(L, tab_funcs);
16,519 ( 0.08%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_setfuncs (1x)
1,731 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_createtable (1x)
   20 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_checkversion_ (1x)
    .          .          .          .             return 1;
    3 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           // root include ./lualib/lutf8lib.c
    .          .          .          .           
    .          .          .          .           #include <assert.h>
    .          .          .          .           //included "limits.h" 
    .          .          .          .           //included "stdlib.h" 
    .          .          .          .           //included "string.h" 
    .          .          .          .           
-- line 3410 ----------------------------------------
-- line 3616 ----------------------------------------
    .          .          .          .             {"char", utfchar},
    .          .          .          .             {"len", utflen},
    .          .          .          .             {"codes", iter_codes},
    .          .          .          .             
    .          .          .          .             {"charpattern", NULL},
    .          .          .          .             {NULL, NULL}
    .          .          .          .           };
    .          .          .          .           
    2 ( 0.00%) .          .          .           LUAMOD_API int luaopen_utf8 (lua_State *L) {
   11 ( 0.00%) .          .          .             luaL_newlib(L, funcs);
12,932 ( 0.06%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_setfuncs (1x)
1,731 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_createtable (1x)
   20 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_checkversion_ (1x)
    4 ( 0.00%) .          .          .             lua_pushlstring(L, UTF8PATT, sizeof(UTF8PATT)/sizeof(char) - 1);
1,131 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushlstring (1x)
    4 ( 0.00%) .          .          .             lua_setfield(L, -2, "charpattern");
  701 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_setfield (1x)
    .          .          .          .             return 1;
    3 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           // root include ./lualib/linit.c
    .          .          .          .           
    .          .          .          .           //included "stddef.h" 
    .          .          .          .           
    .          .          .          .           static const luaL_Reg loadedlibs[] = {
    .          .          .          .             {LUA_GNAME, luaopen_base},
    .          .          .          .             {LUA_COLIBNAME, luaopen_coroutine},
    .          .          .          .             {LUA_TABLIBNAME, luaopen_table},
    .          .          .          .             {LUA_STRLIBNAME, luaopen_string},
    .          .          .          .             {LUA_MATHLIBNAME, luaopen_math},
    .          .          .          .             {LUA_UTF8LIBNAME, luaopen_utf8},
    .          .          .          .             {NULL, NULL}
    .          .          .          .           };
    .          .          .          .           
    4 ( 0.00%) .          .          .           LUALIB_API void luaL_openlibs (lua_State *L) {
    .          .          .          .             const luaL_Reg *lib;
    .          .          .          .             
  103 ( 0.00%) .          .          .             for (lib = loadedlibs; lib->func; lib++) {
   90 ( 0.00%) .          .          .               luaL_requiref(L, lib->name, lib->func, 1);
435,650 ( 2.01%) 13 ( 2.43%) 386,380 ( 0.07%) 363,695 ( 0.07%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_requiref (6x)
   18 ( 0.00%) .          .          .               lua_pop(L, 1);  
  546 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop (6x)
    .          .          .          .             }
    4 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           // root include ./lualib/lbuffer.c
    .          .          .          .           
    .          .          .          .           //included "stdarg.h" 
    .          .          .          .           //included "stdio.h" 
    .          .          .          .           //included "stdlib.h" 
    .          .          .          .           //included "string.h" 
    .          .          .          .           
-- line 3660 ----------------------------------------
-- line 3699 ----------------------------------------
    .          .          .          .           
    .          .          .          .           #define buffonstack(B)	((B)->b != (B)->init.b)
    .          .          .          .           
    .          .          .          .           //included "stdio.h" 
    .          .          .          .           //included "assert.h" 
    .          .          .          .           
    .          .          .          .           #define FUNCHANDLER fprintf(stderr, "CCALL > CFUNC %s in %s:%i\n", __ASSERT_FUNCTION, __FILE__, __LINE__);
    .          .          .          .           
  130 ( 0.00%) .          .          .           static inline void checkbufferlevel(luaL_Buffer *B, int idx) {
  286 ( 0.00%) .          .          .           	FUNCHANDLER
33,384 ( 0.15%) 26 ( 4.87%) 343,377 ( 0.07%) 337,373 ( 0.07%)  => /usr/src/debug/glibc/glibc/stdio-common/fprintf.c:fprintf (26x)
  390 ( 0.00%) .          .          .           	if (buffonstack(B))
    .          .          .          .           		lua_assert(lua_touserdata(B->L, idx) != NULL);
  234 ( 0.00%) .          .          .           	else if (lua_touserdata(B->L, idx) != (void*)B) {
2,834 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_touserdata (26x)
    .          .          .          .           		fprintf(stderr, "%s is on index %i, but buffer excepted!\n", lua_typename(B->L, lua_type(B->L, idx)), idx);
    .          .          .          .           		lua_assert(0 && "buffer is not on top of the stack!");
    .          .          .          .           	}
  104 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           static size_t newbuffsize (luaL_Buffer *B, size_t sz) {
    .          .          .          .           	FUNCHANDLER
    .          .          .          .             size_t newsize = B->size * 2;  
    .          .          .          .             if (l_unlikely(MAX_SIZET - sz < B->n))  
    .          .          .          .               return luaL_error(B->L, "buffer too large");
    .          .          .          .             if (newsize < B->n + sz)  
    .          .          .          .               newsize = B->n + sz;
    .          .          .          .             return newsize;
    .          .          .          .           }
    .          .          .          .           
  160 ( 0.00%) .          .          .           static char *prepbuffsize (luaL_Buffer *B, size_t sz, int boxidx) {
  220 ( 0.00%) .          .          .           	FUNCHANDLER
25,320 ( 0.12%) 20 ( 3.75%) 291,029 ( 0.06%) 284,977 ( 0.06%)  => /usr/src/debug/glibc/glibc/stdio-common/fprintf.c:fprintf (20x)
   60 ( 0.00%) .          .          .             checkbufferlevel(B, boxidx);
28,740 ( 0.13%) 20 ( 3.75%) 260,466 ( 0.05%) 255,994 ( 0.05%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:checkbufferlevel (20x)
  380 ( 0.00%) .          .          .             if (B->size - B->n >= sz)  
  300 ( 0.00%) .          .          .               return B->b + B->n;
    .          .          .          .             else {
    .          .          .          .               lua_State *L = B->L;
    .          .          .          .               char *newbuff;
    .          .          .          .               size_t newsize = newbuffsize(B, sz);
    .          .          .          .               
    .          .          .          .               if (buffonstack(B))  
    .          .          .          .                 newbuff = (char *)resizebox(L, boxidx, newsize);  
    .          .          .          .               else {  
-- line 3739 ----------------------------------------
-- line 3743 ----------------------------------------
    .          .          .          .                 lua_toclose(L, boxidx);
    .          .          .          .                 newbuff = (char *)resizebox(L, boxidx, newsize);
    .          .          .          .                 memcpy(newbuff, B->b, B->n * sizeof(char));  
    .          .          .          .               }
    .          .          .          .               B->b = newbuff;
    .          .          .          .               B->size = newsize;
    .          .          .          .               return newbuff + B->n;
    .          .          .          .             }
  120 ( 0.00%) .          .          .           }
    .          .          .          .           
   50 ( 0.00%) .          .          .           LUALIB_API char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz) {
  110 ( 0.00%) .          .          .           	FUNCHANDLER
12,840 ( 0.06%) 10 ( 1.87%) 167,344 ( 0.03%) 161,200 ( 0.03%)  => /usr/src/debug/glibc/glibc/stdio-common/fprintf.c:fprintf (10x)
   40 ( 0.00%) .          .          .             return prepbuffsize(B, sz, -1);
27,650 ( 0.13%) 20 ( 3.75%) 252,481 ( 0.05%) 248,447 ( 0.05%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:prepbuffsize (10x)
   40 ( 0.00%) .          .          .           }
    .          .          .          .           
   16 ( 0.00%) .          .          .           LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {
   22 ( 0.00%) .          .          .           	FUNCHANDLER
2,532 ( 0.01%) 2 ( 0.37%) 33,127 ( 0.01%) 32,394 ( 0.01%)  => /usr/src/debug/glibc/glibc/stdio-common/fprintf.c:fprintf (2x)
    4 ( 0.00%) .          .          .             if (l > 0) {  
   10 ( 0.00%) .          .          .               char *b = prepbuffsize(B, l, -1);
5,530 ( 0.03%) 4 ( 0.75%) 53,483 ( 0.01%) 52,431 ( 0.01%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:prepbuffsize (2x)
   18 ( 0.00%) .          .          .               memcpy(b, s, l * sizeof(char));
   38 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:memcpy@GLIBC_2.2.5 (2x)
   26 ( 0.00%) .          .          .               luaL_addsize(B, l);
    .          .          .          .             }
   14 ( 0.00%) .          .          .           }
    .          .          .          .           
   10 ( 0.00%) .          .          .           LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {
   22 ( 0.00%) .          .          .           	FUNCHANDLER
2,532 ( 0.01%) 2 ( 0.37%) 32,542 ( 0.01%) 31,179 ( 0.01%)  => /usr/src/debug/glibc/glibc/stdio-common/fprintf.c:fprintf (2x)
   18 ( 0.00%) .          .          .             luaL_addlstring(B, s, strlen(s));
8,210 ( 0.04%) 6 ( 1.12%) 86,610 ( 0.02%) 84,825 ( 0.02%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:luaL_addlstring (2x)
   96 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strlen-sse2.S:__strlen_sse2 (2x)
    8 ( 0.00%) .          .          .           }
    .          .          .          .           
   24 ( 0.00%) .          .          .           LUALIB_API void luaL_pushresult (luaL_Buffer *B) {
   66 ( 0.00%) .          .          .           	FUNCHANDLER
7,596 ( 0.04%) 6 ( 1.12%) 117,405 ( 0.02%) 102,631 ( 0.02%)  => /usr/src/debug/glibc/glibc/stdio-common/fprintf.c:fprintf (6x)
   48 ( 0.00%) .          .          .             lua_State *L = B->L;
   18 ( 0.00%) .          .          .             checkbufferlevel(B, -1);
8,622 ( 0.04%) 6 ( 1.12%) 82,911 ( 0.02%) 81,379 ( 0.02%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:checkbufferlevel (6x)
   78 ( 0.00%) .          .          .             lua_pushlstring(L, B->b, B->n);
6,124 ( 0.03%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushlstring (6x)
   90 ( 0.00%) .          .          .             if (buffonstack(B))
    .          .          .          .               lua_closeslot(L, -2);  
   42 ( 0.00%) .          .          .             lua_remove(L, -2);  
2,376 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_rotate (6x)
  546 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop (6x)
   24 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           LUALIB_API void luaL_pushresultsize (luaL_Buffer *B, size_t sz) {
    .          .          .          .           	FUNCHANDLER
    .          .          .          .             luaL_addsize(B, sz);
    .          .          .          .             luaL_pushresult(B);
    .          .          .          .           }
    .          .          .          .           
   80 ( 0.00%) .          .          .           LUALIB_API void luaL_addvalue (luaL_Buffer *B) {
   88 ( 0.00%) .          .          .           	FUNCHANDLER
10,128 ( 0.05%) 8 ( 1.50%) 210,394 ( 0.04%) 197,749 ( 0.04%)  => /usr/src/debug/glibc/glibc/stdio-common/fprintf.c:fprintf (8x)
   64 ( 0.00%) .          .          .             lua_State *L = B->L;
    .          .          .          .             size_t len;
   40 ( 0.00%) .          .          .             const char *s = lua_tolstring(L, -1, &len);
1,856 ( 0.01%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_tolstring (8x)
   40 ( 0.00%) .          .          .             char *b = prepbuffsize(B, len, -2);
22,120 ( 0.10%) 16 ( 3.00%) 245,531 ( 0.05%) 240,093 ( 0.05%)  => /home/utoecat/Github/protected_github/onlylua/lualib.c:prepbuffsize (8x)
   80 ( 0.00%) .          .          .             memcpy(b, s, len * sizeof(char));
   92 ( 0.00%) .          .          .           => /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:memcpy@GLIBC_2.2.5 (8x)
   88 ( 0.00%) .          .          .             luaL_addsize(B, len);
   24 ( 0.00%) .          .          .             lua_pop(L, 1);  
  728 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_settop (8x)
   80 ( 0.00%) .          .          .           }
    .          .          .          .           
   30 ( 0.00%) .          .          .           LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {
   66 ( 0.00%) .          .          .           	FUNCHANDLER
7,596 ( 0.04%) 6 ( 1.12%) 100,265 ( 0.02%) 96,995 ( 0.02%)  => /usr/src/debug/glibc/glibc/stdio-common/fprintf.c:fprintf (6x)
   48 ( 0.00%) .          .          .             B->L = L;
   78 ( 0.00%) .          .          .             B->b = B->init.b;
   30 ( 0.00%) .          .          .             B->n = 0;
   30 ( 0.00%) .          .          .             B->size = LUAL_BUFFERSIZE;
   18 ( 0.00%) .          .          .             lua_pushlightuserdata(L, (void*)B);  
  414 ( 0.00%) .          .          .           => /home/utoecat/Github/protected_github/onlylua/lua.c:lua_pushlightuserdata (6x)
   24 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           LUALIB_API char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz) {
    .          .          .          .           	FUNCHANDLER
    .          .          .          .             luaL_buffinit(L, B);
    .          .          .          .             return prepbuffsize(B, sz, -1);
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           LUALIB_API void luaL_addgsub (luaL_Buffer *b, const char *s,
-- line 3814 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /usr/src/debug/glibc/glibc/elf/../bits/stdlib-bsearch.h
  /usr/src/debug/glibc/glibc/elf/../sysdeps/generic/dl-new-hash.h
  /usr/src/debug/glibc/glibc/elf/../sysdeps/generic/dl-protected.h
  /usr/src/debug/glibc/glibc/elf/../sysdeps/generic/ldsodefs.h
  /usr/src/debug/glibc/glibc/elf/../sysdeps/x86/dl-cacheinfo.h
  /usr/src/debug/glibc/glibc/elf/../sysdeps/x86_64/dl-machine.h
  /usr/src/debug/glibc/glibc/elf/dl-cache.c
  /usr/src/debug/glibc/glibc/elf/dl-deps.c
  /usr/src/debug/glibc/glibc/elf/dl-load.c
  /usr/src/debug/glibc/glibc/elf/dl-lookup.c
  /usr/src/debug/glibc/glibc/elf/dl-misc.c
  /usr/src/debug/glibc/glibc/elf/dl-reloc.c
  /usr/src/debug/glibc/glibc/elf/dl-runtime.c
  /usr/src/debug/glibc/glibc/elf/dl-tunables.c
  /usr/src/debug/glibc/glibc/elf/dl-tunables.h
  /usr/src/debug/glibc/glibc/elf/dl-version.c
  /usr/src/debug/glibc/glibc/elf/do-rel.h
  /usr/src/debug/glibc/glibc/io/../sysdeps/unix/sysv/linux/write.c
  /usr/src/debug/glibc/glibc/libio/fileops.c
  /usr/src/debug/glibc/glibc/libio/libioP.h
  /usr/src/debug/glibc/glibc/malloc/arena.c
  /usr/src/debug/glibc/glibc/malloc/malloc.c
  /usr/src/debug/glibc/glibc/stdio-common/../include/printf_buffer.h
  /usr/src/debug/glibc/glibc/stdio-common/../libio/libioP.h
  /usr/src/debug/glibc/glibc/stdio-common/Xprintf_buffer_done.c
  /usr/src/debug/glibc/glibc/stdio-common/Xprintf_buffer_write.c
  /usr/src/debug/glibc/glibc/stdio-common/_itoa.c
  /usr/src/debug/glibc/glibc/stdio-common/fprintf.c
  /usr/src/debug/glibc/glibc/stdio-common/printf-parse.h
  /usr/src/debug/glibc/glibc/stdio-common/printf_buffer_to_file.c
  /usr/src/debug/glibc/glibc/stdio-common/printf_fp.c
  /usr/src/debug/glibc/glibc/stdio-common/vfprintf-internal.c
  /usr/src/debug/glibc/glibc/stdio-common/vfprintf-process-arg.c
  /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S
  /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memcmp-sse2.S
  /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strchr-sse2.S
  /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strcmp-sse4_2.S
  /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strlen-sse2.S

--------------------------------------------------------------------------------
Ir                  sysCount sysTime sysCpuTime 
--------------------------------------------------------------------------------
17,128,635 (79.03%) .          .          .           events annotated

